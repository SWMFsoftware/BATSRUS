<!-- The syntax is described by share/Scripts/CheckParam.pl and the manual -->

<commandList name="BATSRUS: GM, EE, SC, IH and OH Components">

List of MH (GM, EE, SC, IH, and OH) commands used in the PARAM.in file

<!-- Set variables for expressions and rules -->
<set name="nVar"              type="integer" value="$_Value{nVar}"             />
<set name="nSpecies"          type="integer" value="$_Value{nSpecies}"         />
<set name="nFluid"            type="integer" value="($_Value{nFluid} or 1)"    />
<set name="nIonFluid"         type="integer" value="($_Value{nIonFluid} or 1)" />
<set name="nNeutralFluid"     type="integer" value="$_Value{nNeutralFluid}"    />
<set name="UsePe"             type="integer" value="$_Value{UsePe}"            />
<set name="UsePpar"           type="integer" value="$_Value{UsePpar}"          />
<set name="nG"                type="integer" value="$_Value{nG}"               />
<set name="nI"                type="integer" value="$_Value{nI}"               />
<set name="nJ"                type="integer" value="$_Value{nJ}"               />
<set name="nK"                type="integer" value="$_Value{nK}"               />
<set name="nDim"              type="integer" value="3-($nJ==1)-($nK==1)"       />
<set name="NameComp"          type="string"  value="$_NameComp"                />
<set name="NameRestartOutDir" type="string"  value="$NameComp/restartOUT"      />
<set name="NamePlotDir"       type="string"  value="$NameComp/IO2"             />
<set name="lLine"             type="integer" value="400"                       />

<!-- Initialize MaxBlock to 0 so we can check if it was set or not -->
<set name="MaxBlock"     type="integer" value="0" />

<commandgroup name="STAND ALONE MODE">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!! STAND ALONE PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

<command name="COMPONENT">
  <parameter name="NameComp" type="string" input="select">
    <option name="GM" default="T" />
    <option name="EE" />
    <option name="SC" />
    <option name="IH" />
    <option name="OH" />
  </parameter>
  <set name="NameRestartOutDir" type="string" value="$NameComp/restartOUT"/>
  <set name="NamePlotDir"       type="string" value="$NameComp/IO2"/>
#COMPONENT
GM			NameComp

This command can be used in the stand-alone mode to make BATSRUS behave as
if it was the Global Magnetosphere (GM), Eruptive Event (EE),
Solar Corona (SC), Inner Heliosphere (IH) or Outer Heliosphere (OH)
component of the SWMF. The NameComp
variable contains the two-character component ID of the selected component.
If NameComp is different from the default component value, then
the default values for all parameters (including the component dependent
defaults, like coordinate system) are reset, therefore it should occur
as the first command if it is used to change the behavior of BATSRUS.
The default behavior is Global Magnetosphere (GM) for the stand-alone BATSRUS.

The command is also saved into the restart header files.

In the SWMF the BATSRUS codes are configured to the appropriate components,
so the default components should not be changed by this command.
</command>

<command name="DESCRIPTION" multiple="T" if="$_IsStandAlone">
  <parameter name="StringDescription" type="string" length="$lLine" />

#DESCRIPTION
This is a test run for Jupiter with no rotation.

This command is only used in the stand alone mode.

The StringDescription string can be used to describe the simulation
for which the parameter file is written. The #DESCRIPTION command and
the StringDescription string are saved into the restart file,
which helps in identifying the restart files.

The default value is ``Please describe me!", which is self explanatory.
</command>

<command name="ECHO" if="$_IsStandAlone">
  <parameter name="DoEcho" type="logical" default="F"/>

#ECHO
T                       DoEcho

This command is only used in the stand alone mode.

If the DoEcho variable is true, the input parameters are echoed back.
The default value for DoEcho is .false., but it is a good idea to
set it to true at the beginning of the PARAM.in file.
</command>

<command name="PROGRESS" if="$_IsStandAlone">
  <parameter name="DnProgressShort" type="integer" min="-1" default="10"  />
  <parameter name="DnProgressLong"  type="integer" min="-1" default="100" />
#PROGRESS
10			DnProgressShort
100			DnProgressLong

The frequency of short and long progress reports for BATSRUS in
stand alone mode. These are the defaults. Set -1-s for no progress reports.
</command>

<command name="TIMEACCURATE" if="$_IsStandAlone">
  <parameter name="IsTimeAccurate" type="logical" default="T" />

#TIMEACCURATE
F               IsTimeAccurate

This command is only used in stand alone mode.

If IsTimeAccurate is set to true, BATSRUS solves
a time dependent problem. If IsTimeAccurate is false, a steady-state
solution is sought for. It is possible to use steady-state mode
in the first few sessions to obtain a steady state solution,
and then to switch to time accurate mode in the following sessions.
In time accurate mode saving plot files, log files and restart files,
or stopping conditions are taken in simulation time, which is the
time relative to the initial time. In steady state mode the simulation
time is not advanced at all, instead the time step or iteration number
is used to control the frequencies of various actions.

In steady-state mode BATSRUS uses different time steps in different
grid cells (limited only by the local stability conditions)
to accelerate the convergence towards steady state.

The default is time accurate mode.
</command>

<command name="TIMEWARP">
  <parameter name="UseTimeWarp" type="logical" default="F"/>
  <parameter name="uWarpDim" type="real" min="0" default="0"
	     if="$UseTimeWarp"/>

#TIMEWARP
T			UseTimeWarp
10.0			uWarpDim (read if UseTimeWarp is true)

The goal is to solve the equations in a coordinate system where time is
shifted with the d = X, Y, Z, or R coordinate as t' = t + d/uWarpDim,
where uWarpDim is a positive speed larger than the fastest
characteristic speed in dimensional units.
Time warping works only if the flow is supersonic/superfast at the
outer boundaries in the positive warp direction (see #WARPDIM)
and the warp speed exceeds the fastest wave speed.

The default is UseTimeWarp false.
</command>

<command name="WARPDIM">
  <parameter name="iDimWarp" type="integer" min="0" max="3" default="0"/>

#WARPDIM
1			iDimWarp

Direction of time warping if it is switched on (see #TIMEWARP).
The iDimWarp=0 setting means radial direction, while 1 to 3
corresponds to the X, Y, and Z directions, respectively.

Default is iDimWarp = 0.
</command>

<command name="WARPCMAX">
   <parameter name="UseWarpCmax" type="logical" default="T"/>

#WARPCMAX
F			UseWarpCmax

If UseWarpCmax is true then use the maximum speed of the warped variables
times the jump in the warped variables in the numerical flux.
If UseWarpCmax is false, use the original maximum speed with the jump
in the original variables.

Default value is true.
</command>

<command name="WARPSCHEME">
  <parameter name="Tolerance" type="real" min="0" default="1e-8"/>
  <parameter name="MaxIteration" type="integer" min="1" default="20"/>
  <parameter name="DnJacobian" type="integer" min="1" default="1"/>
  <parameter name="EpsRel" type="real" min="0" default="1e-6"/>
  <parameter name="EpsAbs" type="real" min="0" default="1e-8"/>

#WARPSCHEME
1e-8			Tolerance
20			MaxIteration
1			DnJacobian
1e-6			EpsRel
1e-8			EpsAbs

The conversion from the warped variables
W=U-F_r/uWarp back to normal state variable U 
uses a Newton iterative scheme.

The Tolerance parameter sets if the iterative solution Witer is close
enough to W, abs(W-Witer).le.Tolerance*[abs(W)+abs(Witer)], to finish
the iteration.

MaxIteration limits the number of iterations performed to reach
the tolerance. If MaxIteration is 1 then the scheme is linearized in dU/dW.

DnJacobian sets how often the dU/dW Jacobian is calculated, which requires
calculating dW/dU and an LU decomposition. Performing this less frequently
saves computation time per iteration, but it may increase the required
number of iterations.

EpsRel and EpsAbs are used to set the perturbation of U for calculating
a row of the dW/dU matrix for a given variable u as dW/du=[W(u+Eps)-W]/Eps
where Eps=EpsRel*abs(u)+EpsAbs.

Default values are shown above.
</command>

<command name="SUBCYCLING" alias="LOCALTIMESTEP">
  <parameter name="UseSubcycling" type="logical" default="F" />
  <parameter name="UseMaxTimeStep" type="logical" default="T"
	     if="$UseSubcycling"/>
  <parameter name="DtLimitDim" type="real" min="0"
	     if="$UseSubcycling"/>

#SUBCYCLING
T               UseSubcycling (rest read if UseSubcycling is true)
T		UseMaxTimeStep
10.0		DtLimitDim

This command controls how the time stepping works in time accurate mode.

If UseSubcycling is true, the time step size in each grid block
can be different.
This algorithm is sometimes called "subcycling" because some of the blocks
will take several small time steps during a single global time step.
This should not be confused with the "steady state" mode
(see the TIMEACCURATE command) where each grid cell takes different
time steps and the result is only valid if a steady state is reached.

If UseMaxTimeStep is true, each blocks takes the time step determined by
the local stability condition but limited by the DtLimitDim parameter.

If UseMaxTimeStep is false, then the local time step will be set by
the AMR level.  For Cartesian grids the time step will be proportional
to the physical cell size, which is optimal if the wave speeds are
roughly constant in the whole domain.  Note that the global time step
is set so that the stability conditions hold in every grid block. A
conservative flux correction is applied at the resolution changes.  On
the other hand, the normal velocity, normal magnetic/electric field
etc. used in some source terms are not "corrected", which is different
from the default uniform time step algorithm.

The DtLimitDim parameter sets an upper limit on the time step for
all the grid blocks in dimensional time units (typically seconds).
Setting this parameter to a reasonable value can greatly improve the
accuracy and robustness of the scheme with minimal effect on the
computational speed, since typically there are relatively few blocks that
would allow very large time steps. Setting DtLimitDim to a very large
value will result in a global time step based on the block with the
largest stable time step.

Currently the subcycling algorithm is either first or second order
accurate in time depending on the value of nStage set in the
#TIMESTEPPING command.

For spherical grids the #FIXAXIS command does not work with the subcycling
algorithm, on the other hand the #COARSENAXIS command can be used.

See also the #PARTSTEADY, #PARTLOCALTIMESTEP and #TIMESTEPLIMIT commands
for related time stepping algorithms.

The default is using a uniform time step for the whole domain.
</command>

<command name="BEGIN_COMP" multiple="T" if="$_IsStandAlone">

This command is allowed in stand alone mode only for the sake of the
test suite, which contains these commands when the framework is tested.
</command>

<command name="END_COMP" multiple="T" if="$_IsStandAlone">

This command is allowed in stand alone mode only for the sake of the
test suite, which contains these commands when the framework is tested.
</command>

<command name="RUN" if="$_IsStandAlone">

#RUN

This command is only used in stand alone mode.

The #RUN command does not have any parameters. It signals the end
of the current session, and makes BATSRUS execute the session with
the current set of parameters. The parameters for the next session
start after the #RUN command. For the last session there is no
need to use the #RUN command, since the #END command or simply
the end of the PARAM.in file makes BATSRUS execute the last session.
</command>

<command name="END">

#END

The #END command signals the end of the included file or the
end of the PARAM.in file. Lines following the #END command are
ignored. It is not required to use the #END command. The end
of the included file or PARAM.in file is equivalent with an
#END command in the last line.
</command>

</commandgroup>

<commandgroup name="PLANET PARAMETERS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!! PLANET PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

The planet commands can only be used in stand alone mode.
The commands allow to work with an arbitrary planet.
It is also possible to change some parameters of the planet relative
to the real values.

By default Earth is assumed with its real parameters.
Another planet (moon, comet) can be selected with the #PLANET
(#MOON, #COMET) command. The real planet parameters can be modified
and simplified with the other planet commands listed in this subsection.
These modified commands cannot precede the #PLANET command!

<command name="PLANET" alias="MOON,COMET"
	 if="$_IsFirstSession and $_IsStandAlone">
  <parameter name="NamePlanet" type="string" case="upper" input="select">
    <option name="NONE"			/>
    <option name="NEW"                  />
    <option name="MERCURY"		/>
    <option name="VENUS"		/>
    <option name="EARTH" default="T"	/>
    <option name="MARS"			/>
    <option name="JUPITER"		/>
    <option name="SATURN"		/>
    <option name="URANUS"		/>
    <option name="NEPTUNE" 		/>
    <option name="PLUTO" 		/>
    <option name="MOON"			/>
    <option name="IO"			/>	
    <option name="EUROPA"		/>
    <option name="GANYMEDE"		/>
    <option name="TITAN"		/>
    <option name="ENCELADUS"		/>
    <option name="HALLEY"		/>
    <option name="COMET1P"		/>
    <option name="BORRELLY"		/>
    <option name="COMET19P"		/>
    <option name="CHURYUMOVGERASIMENKO"	/>
    <option name="COMET67P"		/>
    <option name="HALEBOPP"		/>
  </parameter>
  <if expr="$NamePlanet =~ /NEW|GANYMEDE|COMET[16]|BORRELLY|PLUTO|NEPTUNE/">
    <parameter name="RadiusPlanet" type="real" min="0" />
    <parameter name="MassPlanet"   type="real" min="0" />
    <parameter name="OmegaPlanet"  type="real" min="0" />
    <parameter name="TiltRotation" type="real" min="0" />
    <parameter name="TypeBField"   type="string" input="select">
      <option name="NONE" />
      <option name="DIPOLE" default="T" />
    </parameter>
  </if>
  <if expr="$TypeBField eq 'DIPOLE'">
    <parameter name="MagAxisThetaGeo" type="real" min="0" max="180"/>
    <parameter name="MagAxisPhiGeo"   type="real" min="0" max="360"/>
    <parameter name="DipoleStrength"  type="real"    />
  </if>
  <rule expr="not $PlanetCommand">
    PLANET should precede $PlanetCommand
  </rule>

#PLANET
NEW			NamePlanet (rest of parameters read for unknown planet)
6300000.0		RadiusPlanet [m]
5.976E+24		MassPlanet   [kg]
0.000000199		OmegaPlanet  [radian/s]
23.5			TiltRotation [degree]
DIPOLE			TypeBField
11.0			MagAxisThetaGeo [degree]
289.1			MagAxisPhiGeo   [degree]
-31100.0E-9		DipoleStrength  [T]

The NamePlanet parameter contains the name of the planet
with arbitrary capitalization. In case the name of the planet
is not recognized, the following variables are read:
RadiusPlanet is the radius of the planet,
MassPlanet is the mass of the planet,
OmegaPlanet is the angular speed relative to an inertial frame, and
TiltRotation is the tilt of the rotation axis relative to ecliptic North,
TypeBField, which can be "NONE" or "DIPOLE".
TypeBField="NONE" means that the planet does not have magnetic field.
If TypeBField is set to "DIPOLE" then the following variables are read:
MagAxisThetaGeo and MagAxisPhiGeo are the colatitude and longitude
of the north magnetic pole in corotating planetocentric coordinates.
Finally DipoleStrength is the equatorial strength of the magnetic dipole
field. The units are indicated in the above example, which shows the
Earth values approximately.

The default value is NamePlanet="Earth". Although many other planets
and some of the moons are recognized, some of the parameters,
like the equinox time are not yet properly set.
</command>

<command name="ROTATIONAXIS" if="$_IsStandAlone">
  <parameter name="IsRotAxisPrimary" type="logical" default="T" />
  <if expr="$IsRotAxisPrimary">
    <parameter name="RotAxisTheta" type="real" min="0" max="180"/>
    <parameter name="RotAxisPhi"   type="real" min="0" max="360"/>
  </if>
  <set name="PlanetCommand" type="string" value="ROTATIONAXIS" />

#ROTATIONAXIS
T			IsRotAxisPrimary (rest of parameters read if true)
23.5			RotAxisTheta
198.3			RotAxisPhi

If the IsRotAxisPrimary variable is false, the rotational axis
is aligned with the magnetic axis. If it is true, the other two variables
are read, which give the position of the rotational axis at the
initial time in the GSE coordinate system. Both angles are read in degrees
and stored internally in radians.

The default is to use the true rotational axis determined by the
date and time given by #STARTTIME.
</command>

<command name="ROTATION" if="$_IsStandAlone">
  <parameter name="UseRotation" type="logical" default="T" />
  <if expr="$UseRotation">
    <parameter name="RotationPeriod" type="real" />
  </if>
  <set name="PlanetCommand" type="string" value="ROTATION" />

#ROTATION
T			UseRotation
24.06575		RotationPeriod [hour] (read if UseRotation is true)

If UseRotation is false, the planet is assumed to stand still,
and the OmegaPlanet variable is set to zero.
If UseRotation is true, the RotationPeriod variable is read in hours,
and it is converted to the angular speed OmegaPlanet given in radians/second.
Note that OmegaPlanet is relative to an inertial coordinate system,
so the RotationPeriod is not 24 hours for the Earth, but the
length of the astronomical day.

The default is to use rotation with the real rotation period of the planet.
</command>

<command name="MAGNETICAXIS" if="$_IsStandAlone">
  <parameter name="IsMagAxisPrimary" type="logical" default="T" />
  <if expr="$IsMagAxisPrimary">
    <parameter name="MagAxisTheta" type="real" min="0" max="180"/>
    <parameter name="MagAxisPhi"   type="real" min="0" max="360"/>
  </if>
  <set name="PlanetCommand" type="string" value="MAGNETICAXIS" />

#MAGNETICAXIS
T			IsMagAxisPrimary (rest of parameters read if true)
34.5			MagAxisTheta [degree]
0.0			MagAxisPhi   [degree]

If the IsMagAxisPrimary variable is false, the magnetic axis
is aligned with the rotational axis. If it is true, the other two variables
are read, which give the position of the magnetic axis at the
initial time in the GSE coordinate system. Both angles are read in degrees
and stored internally in radians.

The default is to use the true magnetic axis determined by the
date and time given by #STARTTIME.
</command>

<command name="MAGNETICCENTER" if="$_IsStandAlone">
  <parameter name="MagCenterX" type="real" default="0.0" />
  <parameter name="MagCenterY" type="real" default="0.0" />
  <parameter name="MagCenterZ" type="real" default="0.0" />
  <set name="PlanetCommand" type="string" value="MAGNETICCENTER" />

#MAGNETICCENTER
0.1			MagCenterX
-0.02			MagCenterY
0.0			MagCenterZ

Shifts the magnetic center (e.g. the center of the dipole) to the location
given by the three parameters. The default is no shift
(at least for most planets).
</command>

<command name="MONOPOLEB0">
  <parameter name="MonopoleStrengthSi" type="real" default="0"/>

#MONOPOLEB0
16.0			MonopoleStrengthSi [Tesla]

The MonopoleStrengthSi variable contains the
magnetic strength of the monopole B0 field at R=1 radial distance.
The unit is Tesla unless the normalization is set to NONE
(see #NORMALIZATION command), when it is just the normalized value.

The default value is zero.
</command>

<command name="DIPOLE" if="$_IsStandAlone">
  <parameter name="DipoleStrengthSi" type="real" />

#DIPOLE
-3.11e-5		DipoleStrengthSi [Tesla]

The DipoleStrengthSi variable contains the
magnetic equatorial strength of the dipole magnetic field in Tesla.

The default value is the real dipole strength for the planet.
For the Earth the default is taken to be the IGRF dipole field that
depends on the #STARTTIME.
The sign is taken to be negative so that the magnetic axis can
point northward as usual.
</command>

<command name="UPDATEB0" if="$_IsStandAlone">
  <parameter name="DtUpdateB0" type="real" min="-1" default="0.0001" />

#UPDATEB0
0.0001			DtUpdateB0

The DtUpdateB0 variable determines how often the position of
the magnetic axis is recalculated. A negative value indicates that
the motion of the magnetic axis during the course of the simulation
is neglected. This is an optimization parameter, since recalculating
the values which depend on the orientation of the magnetic
field can be costly. Since the magnetic field moves relatively
slowly as the planet rotates around, it may not be necessary
to continuously update the magnetic field orientation.

The default value is 0.0001, which means that the magnetic axis
is continuously followed.
</command>

<command name="IDEALAXES" if="$_IsStandAlone">

#IDEALAXES

The #IDEALAXES command has no parameters. It sets both the rotational
and magnetic axes parallel with the ecliptic North direction. In fact
it is identical with the commands:

#ROTATIONAXIS
T               IsRotAxisPrimary
0.0             RotAxisTheta
0.0             RotAxisPhi

#MAGNETICAXIS
F               IsMagAxisPrimary

but much shorter.
</command>

<command name="MULTIPOLEB0" if="$_IsStandAlone">
  <parameter name="UseMultipoleB0" type="logical"         default="F" />
  <parameter name="MaxHarmonicDegree" type="integer"      default="-1" />
  <parameter name="NamePlanetHarmonicsFile" type="string" length="$lLine"/>

#MULTIPOLEB0
T                        UseMultipoleB0
10                       MaxHarmonicDegree
planetharmonics.txt      NamePlanetaryHarmonicsFile

Using this command, you can specify the
planetary magnetic field (B0) using the Spherical Harmonics
expansion. This is useful for e.g. to model the IGRF or complicated
planetary magnetic field. Planetary rotation is allowed when using 
this option. We suggest using the GSE coordinate system using 
the #COORDSYSTEM command. If UseMultipoleB0 is true, the 
#IDEALAXES command is enforced i.e. the dipole magnetic axis 
is aligned with the rotation axis. No matter what coordinate system
you use in GM, the multipole B0 calculation is always done in the 
GEO coordinate system. 

As of now this feature cannot be used with the IE solver, and 
should be used in standalone GM/BATSRUS only. Secular variation 
has not been implemented yet. 

The planetharmonics.txt file should be of the form -

\begin{verbatim}
Header line (is not read) - n m g h (follow this specific order)
0  0   0.000000      0.000000
1  0  -29619.400000  0.000000
1  1  -1728.200000   5186.100000
2  0  -2267.700000   0.000000
2  1   3068.400000  -2481.600000
2  2   1670.900000  -458.000000
\end{verbatim}

Where g and h are the Legendre coefficients in units of nT.
</command>

</commandgroup>

<commandgroup name="USER DEFINED INPUT">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!  USER DEFINED INPUT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

<command name="USERSWITCH" alias="USERSWITCHES">
  <parameter name="StringSwitch" type="string" length="$lLine" case="lower"/>

#USERSWITCH
-all +init +ic -perturb +B0 +source +update +timestep +progress    StringSwitch

This command controls the use of user defined routines in src/ModUser.f90.
The string contains a single-space separated list of switches starting
with a + sign or a - sign for switching the routines on or off, respectively.
This command can occur multiple times in the same session.
Previous settings are preserved for the next session. The possible
switches are (with alternative names):
\begin{verbatim}
all                     : switch all routines on or off
init, init_session      : initialize user module before running session
ic, initial_condition   : initial conditions
perturb, perturbation   : perturbation (default is false)
B0, get_b0              : user defined B0 field
source                  : user source terms (explicit and implicit)
Sexpl, source_expl      : explicit user source terms
Simpl, source_impl      : point-implicit user source terms
update, update_state    : user defined state update
timestep, time_step     : user defined time step calculation
progress, write_progress: user progress report
\end{verbatim}
Default is that init is on all others are off.
When the perturbation is switched on, it gets switched off after
the perturbation is applied. The corresponding logicals can be
changed in the user module. 
</command>

<command name="USERINPUTBEGIN" multiple="T">

#USERINPUTBEGIN

This command signals the beginning of the section of the file which
is read by the subroutine user\_read\_inputs in the ModUser.f90 file.
The section ends with the #USERINPUTEND command.
There is no XML based parameter checking in the user section.
</command>

<command name="USERINPUTEND" multiple="T">

#USERINPUTEND

This command signals the end of the section of the file which
is read by the subroutine user\_read\_inputs in the ModUser.f90 file.
The section begins with the #USERINPUTBEGIN command.
There is no XML based parameter checking in the user section.
</command>

</commandgroup>

<commandgroup name="TESTING AND TIMING">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!  TESTING AND TIMING PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="TESTINFO">
  <parameter name="DoWriteCallSequence" type="logical" default="F"/>

#TESTINFO
T		DoWriteCallSequence

If DoWriteCallSequence is set to true, the code will attempt to produce
a call sequence from the stop_mpi subroutine (which is called when the
code finds an error) by making an intentional floating point exception.
This will work only if the compiler is able to and requested to produce a
call sequence. The NAGFOR compiler combined with the -debug flag can do that.

Default is DoWriteCallSequence=F.
</command>

<command name="TEST">
  <parameter name="StringTest" type="string" length="$lLine"/>
#TEST
read_inputs

A space separated list of subroutine names. Default is empty string.

Examples:\\
  read_inputs  - echo the input parameters following the #TEST line\\
  project_B    - info on projection scheme\\
  implicit     - info on implicit scheme\\
  krylov       - info on the Krylov solver\\
  message_count- count messages\\
  initial_refinement\\
  ...

Check the subroutines for call setoktest("...",oktest,oktest_me) to
see the appropriate strings.
</command>

<command name="TESTIJK">
  <parameter name="iTest"      type="integer" min="-$nG"
	     max="$nI+$nG" default="1" />
  <parameter name="jTest"      type="integer" min="-$nG"
	     max="$nJ+$nG" default="1" if="$nDim!=1" />
  <parameter name="kTest"      type="integer" min="-nG"
	     max="$nK+2" default="1" if="$nDim==3" />
  <parameter name="iBlockTest" type="integer" min="1" default="1" />
  <parameter name="iProcTest"  type="integer" min="0" />
#TESTIJK
1                       iTest           (cell index for testing)
1                       jTest           (read for nDim = 2 or 3)
1                       kTest           (read for nDim = 3)
1                       iBlockTest      (block index for testing)
0                       iProcTest       (processor index for testing)

The location of test info in terms of indices, block and processor number.
Note that the user should set #TESTIJK or #TESTXYZ, not both.

The default test cell is shown by the example.
</command>

<command name="TESTXYZ">
  <parameter name="xTest" type="real" min="$xMin" max="$xMax" />
  <parameter name="yTest" type="real" min="$yMin" max="$yMax" if="$nJ!=1"/>
  <parameter name="zTest" type="real" min="$zMin" max="$zMax" if="$nK!=1"/>
#TESTXYZ
1.5                     xTest           (X coordinate of cell for testing)
-10.5                   yTest           (Y coordinate for nDim=2 or 3)
-10.                    zTest           (Z coordinate for nDim=3)

The location of test info in terms of coordinates.
Note that the user should set #TESTIJK or #TESTXYZ, not both.

The default test cell is described in #TESTIJK.
</command>

<command name="TESTVAR">
  <parameter name="NameTestVar" type="string" length="20" case="lower"
	     default="1" />
#TESTVAR
12		     NameTestVar

#TESTVAR
p                    NameTestVar

Index or the name of the variable to be tested. The name should agree with
one of the names in the NameVar_V array in ModEquation.f90 (case insensitive).
If an index is given instead of a name, it should be in the range 1 to nVar.

Default is the first variable that is usually density.
</command>

<command name="TESTDIM">
  <parameter name="iDimTest" type="integer" input="select">
    <option name="all" value="0" />
    <option name="x"   value="1" default="T" />
    <option name="y"   value="2" />
    <option name="z"   value="3" />
  </parameter>
#TESTDIM
1                       iDimTest

Index of dimension/direction to be tested. Default is X dimension.
</command>

<command name="TESTSIDE">
  <parameter name="iSideTest" type="integer" input="select">
    <option name="all"   value="0" default="T"/>
    <option name="left"  value="-1" />
    <option name="right" value="1" />
  </parameter>

#TESTSIDE
0                       iSideTest (-1, 0, 1)

Select the side of the cell to be tested. -1 is for "left" side, +1 is
for right side, 0 is for both sides. Currently this is implemented in the
UpdateStateFast code only, where the sides are done with multiple threads
on the GPU. Default value is shown.
</command>

<command name="TESTPIXEL">
  <parameter name="iPixTest" type="integer"/>
  <parameter name="jPixTest" type="integer"/>

#TESTPIXEL
200                     iPixTest
200                     jPixTest

Indexes of the test pixel of the LOS plot.
</command>

<command name="STRICT" multiple="T">
  <parameter name="UseStrict" type="logical" default="T" />
#STRICT
T                       UseStrict

If true then stop when parameters are incompatible. If false, try to
correct parameters and continue. Default is true, i.e. strict mode
</command>

<command name="VERBOSE">
  <parameter name="lVerbose" type="integer" input="select">
    <option name="errors and warnings only"  value="-1" />
    <option name="start and end of sessions" value="0"  />
    <option name="default"                   value="1" default="T"/>
    <option name="calls on test processor"   value="10" />
    <option name="calls on all processors"   value="100" />
        </parameter>
#VERBOSE
-1                      lVerbose

Verbosity level controls the amount of output to STDOUT. Default level is 1.
\\
  lVerbose $\leq -1$ only warnings and error messages are shown.\\
  lVerbose $\geq  0$ start and end of sessions is shown.\\
  lVerbose $\leq  1$ a lot of extra information is given.\\
  lVerbose $\leq 10$ all calls of set_oktest are shown for the test processor.\\
  lVerbose $\leq 100$ all calls of set_oktest are shown for all processors.\\
</command>

<command name="DEBUG">
  <parameter name="DoDebug"      type="logical" default="F" />
  <parameter name="DoDebugGhost" type="logical" default="F" />
#DEBUG
F                       DoDebug         (use it as if(okdebug.and.oktest)...)
F                       DoDebugGhost    (parameter for show_BLK in library.f90)

Excessive debug output can be controlled by the global okdebug parameter
</command>



<command name="USERMODULE" if="$_IsFirstSession">
  <parameter name="NameUserModule" type="string" length="$lLine"
	     default="EMPTY" />

#USERMODULE
TEST PROBLEM Smith

Checks the selected user module. If the name differs from that of the
compiled user module, a warning is written,
and the code stops in strict mode (see #STRICT command).
This command is written into the restart header file too,
so the user module is checked when a restart is done.
There are no default values. If the command is not present, the user
module is not checked.
</command>

<command name="EQUATION" if="$_IsFirstSession">
  <parameter name="NameEquation" type="string" length="$lLine"
	     default="MHD" />
  <parameter name="nVar" type="integer" default="8" />
#EQUATION
MHD			NameEquation
8			nVar

Define the equation name and the number of variables.
If any of these do not agree with the values determined
by the code, BATSRUS stops with an error. Used in restart
header files and can be given in PARAM.in as a check
and as a description.
</command>

<command name="RESTARTVARIABLES">
  <parameter name="NameRestartVar" type="string" length="$lLine"/>
#RESTARTVARIABLES
Rho Mx My Mz Bx By Bz p           NameRestartVar

The NameRestartVar string contains a space separated list of variable names
that are stored in a restart file. This command is saved automatically
into the restart files. Other then useful information about the content of
the restart file, it is also needed for the #CHANGEVARIABLES command.

The default assumption is that the restart file contains the same variables
as the equation module that the code is compiled with.
</command>

<command name="CHANGEVARIABLES">
  <parameter name="DoChangeRestartVariables"  type="logical" default="F"/>

#CHANGEVARIABLES
T			DoChangeRestartVariables

This command allows reading restart files that were produced with different
equation and user modules than what the restarted code is using.
If DoChangeRestartVariables is set to true, the code attempts to copy the
corresponding variables correctly.
This typically works if the restart file contains all the variables
that the restarted code is using. See subroutine match\_copy\_restart\_variables
in ModRestartFile.f90 for more detail.

The default is to use the same variables and equation modules during restart.
</command>


<command name="SPECIFYRESTARTVARMAPPING">
  <parameter name="DoSpecifyRestartVarMapping" type="logical" default="F"/>
  <parameter name="NameVarsRestartFrom"        type="string" length="$lLine"/>
  <parameter name="NameVarsRestartTo"          type="string" length="$lLine"/>

#SPECIFYRESTARTVARMAPPING
T			DoSpecifyRestartVarMapping
H2OpRho H2OpP		NameVarsRestartFrom
H3OpRho P		NameVarsRestartTo

This command allows specifying the mapping of variables when reading restart
files in one equation/user file to another equation/user file. In the above
example, the code will use the values of H2OpRho/H2OpP in the old equation/user
file to initialize the variables H3OpRho/P in the new equation/user file.

This mapping applies after the default mapping which maps the variables with
the same variable names, meaning that it will overwrite the default mapping
algorithm. For example, if both the original equation/user file and the new
equation/user file have the variable P, the code will initialize P in the new
equation/user file with the values of P in the old equation/user file by
default. However, in the above example, users choose to map H2OpP in the
old equation/user file to the varaible P in the new equation/user file. The
mapping of variables is also shown in the runlog in case the user wants to
see how the variables are mapped.

The deafult is not to apply user specified mapping even a different
equation/user file is used during restart.
</command>


<command name="PRECISION" if="$_IsFirstSession">
  <parameter name="nByteReal" type="integer" input="select">
    <option name="single precision" value="4" default="$_nByteReal==4"/>
    <option name="double precision" value="8" default="$_nByteReal==8" />
  </parameter>
  <rule expr="$nByteReal==$_nByteReal or not $UseStrict">
    nByteReal in file must agree with _nByteReal in strict mode.
  </rule>

#PRECISION
8                       nByteReal

Define the number of bytes in a real number. If it does not agree
with the value determined by the code, BATSRUS stops with an error
unless the strict mode is switched off.
This is used in restart header files to store (and check) the precision
of the restart files. It is now possible to read restart files with
a precision that differs from the precision the code is compiled with,
but strict mode has to be switched off with the #STRICT command.
The #PRECISION command may also be used to enforce a certain precision.
</command>

<command name="CHECKGRIDSIZE" if="$_IsFirstSession">
  <parameter name="nI" type="integer" min="$nI" max="$nI" />
  <parameter name="nJ" type="integer" min="$nJ" max="$nJ" />
  <parameter name="nK" type="integer" min="$nK" max="$nK" />
  <parameter name="MinBlockAll" type="integer" default="4000" min="1" />
  <set name="MaxBlock" value="$MinBlockAll+1"/>

#CHECKGRIDSIZE
  4                        nI
  4                        nJ
  4                        nK
576                        MinBlockAll

This command is typically used in the restart headerfile to check consistency.
The nI, nJ, nK parameters provide the block size in terms of number of
grid cells in the 3 directions. The code stops with an error message
if nI, nJ, or nK differ from the values set with Config.pl -g=...

The MinBlockAll parameter stores the total number of grid blocks 
actually used at the time the restart file was saved. 
When doing a restart, it is used to set the number of grid blocks 
to be sufficient to coninue the run as long as no AMR is performed. 
To allocate more blocks, use the #GRIDBLOCKALL command.

This command can also be used directly in PARAM.in to check the block size
and to set the total number of blocks at the same time. 
</command>

<command name="BLOCKLEVELSRELOADED">
#BLOCKLEVELSRELOADED

This command means that the restart file contains the information about
the minimum and maximum allowed refinement levels for each block.
This command is only used in the restart header file.
</command>

<command name="TIMING" if="$_IsStandAlone">
  <parameter name="UseTiming" type="logical" default="T" />
  <if expr="$UseTiming">
    <parameter name="DnTiming" type="integer" min="-3"     default="-2" />
    <parameter name="nDepthTiming" type="integer" min="-1" default="-1" />
    <parameter name="TypeTimingReport" type="string" input="select">
      <option name="cumulative" value="cumu" default="1" />
      <option name="list" />
      <option name="tree" />
    </parameter>
  </if>
#TIMING
T                       UseTiming      (rest of parameters read if true)
-2                      DnTiming       (-3 none, -2 final, -1 each session)
-1                      nDepthTiming   (-1 for arbitrary depth)
cumu                    TypeTimingReport   (cumu/list/tree + optional 'all')

This command can only be used in stand alone mode. In the SWMF the
#TIMING command should be issued for CON.

If UseTiming=.true., the TIMING module must be on.
If UseTiming=.false., the execution is not timed.

Dntiming determines the frequency of timing reports.
If DnTiming .ge.  1, a timing report is produced every dn_timing step.
If DnTiming .eq. -1, a timing report is shown at the end of each session.
If DnTiming .eq. -2, a timing report is shown at the end of the whole run.
If DnTiming .eq. -3, no timing report is shown.

nDepthTiming determines the depth of the timing tree. A negative number
means unlimited depth. If TimingDepth is 1, only the full BATSRUS execution
is timed.

TypeTimingReport determines the format of the timing reports:
'cumu' - cumulative list sorted by timings
'list' - list based on caller and sorted by timings
'tree' - tree based on calling sequence

If the word 'all' is added, the timing is done on all the CPU-s. One output
file will be created for each processor.

The default values are shown above.
</command>

</commandgroup>

<commandgroup name="INITIAL AND BOUNDARY CONDITIONS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!! MAIN INITIAL AND BOUNDARY CONDITION PARAMETERS  !!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="SUBTRACTB0" if="$_IsFirstSession">
  <parameter name="DoSubtractB0" type="logical" default="T"/>

#SUBTRACTB0
F			DoSubtractB0

If the magnetic field is split to B0 and B1, then the initial condition
set by #UNIFORMSTATE and similar commands can either apply to the total field
when DoSubtractB0 true, or to B1 only when DoSubtractB0 is set to false.

The default is DoSubtractB0 true.
</command>
  
<command name="UNIFORMSTATE" if="$_IsFirstSession">
  <for from="1" to="$nVar">
    <parameter name="StateVar" type="real"/>
  </for>

#UNIFORMSTATE
0.125		StateVar Rho
1.0		StateVar Ux
-0.5		StateVar Uy
0.0             StateVar Uz
1.0             StateVar p

The #UNIFORMSTATE command sets up a uniform initial state. This uniform
state can be perturbed or modified by the user module.
The command sets the primitive variables in the order defined in
the equation module.
</command>

<command name="SHOCKTUBE" if="$_IsFirstSession">
  <for from="1" to="$nVar">
    <parameter name="LeftState" type="real"/>
  </for>
  <for from="1" to="$nVar">
    <parameter name="RightState" type="real"/>
  </for>
    
#SHOCKTUBE
1.		LeftState Rho
0.		LeftState Ux
0.		LeftState Uy
0.		LeftState Uz
0.75		LeftState Bx
1.		LeftState By
0.		LeftState Bz
1.              LeftState p
0.125		RightState Rho
0.		RightState Ux
0.		RightState Uy
0.              RightState Uz
0.75            RightState Bx
-1.		RightState By
0.		RightState Bz
0.1             RightState p

The #SHOCKTUBE command can be used to set up a shocktube problem.
The left and right state values are given in terms of the primitive
variables as defined in the equation module.
The shock can be shifted and rotated by the #SHOCKPOSITION command.

By default the initial condition is uniform, and the
values are determined by the #SOLARWIND command. The user module
can be used to set up more complicated initial conditions.
</command>

<command name="SHOCKPOSITION" if="$_IsFirstSession">
  <parameter name="ShockPosition" type="real" default="0"/>
  <parameter name="ShockSlope" type="real" default="0"/>
#SHOCKPOSITION
5.0			ShockPosition
1/2			ShockSlope

The ShockPosition parameter sets the position where the shock,
ie. the interface between the left and right states given by
the #SHOCKTUBE command, intersects the X axis.
When ShockSlope is 0, the shock normal points in the X direction.
Otherwise the shock is rotated around the Z axis, and the tangent of
the rotation angle is given by ShockSlope. Possible values are
\begin{verbatim}
  ShockSlope = 0., 1/4, 1/3, 1/2, 1., 2., 3., 4.
\end{verbatim}
because these angles can be accurately represented
on the grid. The default values are zero, ie. the shock is in the
X=0 plane.
</command>

<command name="RADIALSTATE" multiple="T" if="$_IsFirstSession">
  <for from="1" to="$nVar">
    <parameter name="Amplitude" type="real" default="0"/>
    <parameter name="ExponentR" type="real" default="0" if="$Amplitude!=0"/>
  </for>

#RADIALSTATE
1000.0			Amplitude Rho
-2.0			ExponentR Rho (read if amplitude is not 0)
400.0			Amplitude Ur
0.0			ExponentR Ur (read if amplitude is not 0)
0.0			Amplitude Ulon
0.0			Amplitude Ulat
100.0			Amplitude Br
-2.0			ExponentR Br (read if amplitude is not 0)
-10.0			Amplitude Blon
-1.0			ExponentR Blon (read if amplitude is not 0)
0.0			Amplitude Blat
100.0			Amplitude p
-10/3			ExponentR p (-2*Gamma)

Initialize the variables with a radially dependent state
Amplitude*r**ExponentR. The vector variables are given
in r,lon,lat components. The above example can be
used to set up initial conditions for a "solar wind" with
constant radial velocity, Parker spiral magnetic field,
and adiabatic expansion. Note that this initial state is
singular at the origin, so the origin should not be part of
the computational domain. 
</command>

<command name="WAVE" alias="WAVE2,WAVE4,WAVE6" multiple="T"
	 if="$_IsFirstSession">
  <parameter name="NameVar"   type="string" length="20"/>
  <parameter name="Width"     type="real" min="0"  default="0"/>
  <parameter name="Amplitude" type="real"          default="0"/>
  <parameter name="LambdaX"   type="real" min="-1" default="-1"/>
  <parameter name="LambdaY"   type="real" min="-1" default="-1"/>
  <parameter name="LambdaZ"   type="real" min="-1" default="-1"/>
  <parameter name="Phase"     type="real"          default="0"/>

#WAVE
Ux                    NameVar
10.0                  Width
0.1                   Amplitude
5.0                   LambdaX
-1.0                  LambdaY
-1.0                  LambdaZ
90.0                  Phase [deg]

Add a wave to the initial condition.

NameVar selects the primitive variable to be changed.
Width limits the extent of the wave relative to the origin.
Inside the width the following formula is applied:
\begin{verbatim}
   Var = Var + Amplitude*cos(Phase + Kx*x + Ky*y + Kz*z)**Exponent
\end{verbatim}
where Kx = max(2*pi/LambdaX, 0), so negative LambdaX results in Kx=0.
Ky and Kz are calculated similarly. The exponent is given by the
name of the command. For #WAVE it is 1, for #WAVE2, #WAVE4 and #WAVE6
it is 2, 4 and 6, respectively. The high power allows setting up
tests for the fifth order scheme.

The wave vectors and the amplitudes of vector variables are rotated
around the Z axis with the angle of the shock slope if it is not zero.

This command can be repeated to add different waves to different
variables. There is no wave perturbation by default. 
</command>

<command name="BUMP" multiple="T" if="$_IsFirstSession">
  <parameter name="NameVar"   type="string" length="20"/>
  <parameter name="Amplitude" type="real"          default="0"/>
  <parameter name="WidthX"    type="real" min="-1" default="-1"/>
  <parameter name="WidthY"    type="real" min="-1" default="-1"/>
  <parameter name="WidthZ"    type="real" min="-1" default="-1"/>
  <parameter name="CenterX"   type="real" default="0"/>
  <parameter name="CenterY"   type="real" default="0"/>
  <parameter name="CenterZ"   type="real" default="0"/>
  <parameter name="nPower"    type="integer" min="0" default="1"/>

#BUMP
Rho                     NameVar
0.1                     Amplitude
5.0                     WidthX
3.0                     WidthY
-1.0                    WidthZ
4.2                     CenterX
0.0                     CenterY
-0.2                    CenterZ
4                       nPower

Add a "bump" perturbation to a variable.

NameVar selects the primitive variable to be perturbed.

Amplitude sets the amplitude of the perturbation.

WidthX, WidthY and WidthZ define the spatial extent of the perturbation
in the 3 directions. Negative value means that there is no restriction,
so 1/Width is set to 0.

CenterX, CenterY and CenterZ define the center of the perturbation.

nPower is the power of the cosine functions, which sets the smoothness.
nPower=0 defines a bump with a constant value with a sharp edge.
nPower=2 is suitable for convergence studies up to 2nd order.

For a given point at x, y, z, the normalized radial distances from
the center is
\begin{verbatim}
  r = sqrt( ((x-CenterX)/WidthX)**2 + ((y-CenterY)/WidthY)**2 ...)
\end{verbatim}
The perturbation is applied for r less than 0.5 as
\begin{verbatim}
  Var = Var + Amplitude * cos(pi*r)**nPower
\end{verbatim}
This command can be repeated multiple times to add perturbations to
multiple variables. No perturbation is applied by default.
</command>

<command name="SOLARWIND">
  <parameter name="SwNDim"   type="real" min="-1"	default="5"	/>
  <parameter name="SwTDim"   type="real" min="-1"	default="100000." />
  <parameter name="SwUxDim"  type="real"		default="-400"	/>
  <parameter name="SwUyDim"  type="real"		default="0"	/>
  <parameter name="SwUzDim"  type="real"		default="0"	/>
  <parameter name="SwBxDim"  type="real"		default="0"	/>
  <parameter name="SwByDim"  type="real"		default="0"	/>
  <parameter name="SwBzDim"  type="real"		default="-5"	/>
#SOLARWIND
5.0			SwNDim  [n/cc]
100000.0		SwTDim  [K]
-400.0			SwUxDim [km/s]
0.0			SwUyDim [km/s]
0.0			SwUzDim [km/s]
0.0			SwBxDim [nT]
0.0			SwByDim [nT]
-5.0			SwBzDim [nT]

This command defines the solar wind parameters for the GM component.
The default values are all 0.0-s.
</command>

<command name="SOLARWINDFILE" alias="UPSTREAM_INPUT_FILE">
  <parameter name="UseSolarWindFile" type="logical" default="F"/>
  <if expr="$UseSolarWindFile">
    <parameter name="NameSolarWindFile" type="string"
	       length="$lLine"/>
  </if>
  <rule expr="-f $NameSolarWindFile">
    Solar wind file $NameSolarWindFile must exist
  </rule>
#SOLARWINDFILE
T			UseSolarWindFile (rest of parameters read if true)
IMF.dat                 NameSolarWindFile

Default is UseSolarWindFile = .false.

Read IMF data from file NameSolarWindFile if UseSolarWindFile is true.
The data file contains all information required for setting the upstream
boundary conditions. Parameter TypeBcWest should be set to 'vary' for
the time dependent boundary condition.

If the #SOLARWIND command is not provided then the first time read from
the solar wind file will set the normalization of all variables
in the GM component. Consequently either the #SOLARWIND command or
the #SOLARWINDFILE command with UseSolarWindFile=.true.
is required by the GM component.

The input files are strutured similar to the PARAM.in file.  There are
{\tt #commands} that can be  inserted as well as the data.
The file containing the upstream conditions should include data in the
following order:
\begin{verbatim}
yr mn dy hr min sec msec bx by bz vx vy vz dens temp
\end{verbatim}
The units of the variables should be:
\begin{verbatim}
Magnetic field (b)     nT
Velocity (v)           km/s
Number Density (dens)  cm^-3
Temperature (Temp)     K
\end{verbatim}

The input files  can have the following optional commands at the beginning
\begin{verbatim}
#REREAD      Reread the file if the simulation runs beyond the final time
             See also the #REFRESHSOLARWINDFILE command

#COOR
GSM          The coordinate system of the data: GSM (default) or GSE

#VAR
rho ux uy uz bx by bz p pe

#PLANE       The input data represents values on a tilted plane
20.0         Angle to rotate in the XY plane [deg]
15.0         Angle to rotate in the XZ plane [deg]

#POSITION    Y-Z Position of the satellite (also origin of plane rotation)
20.0         Y location
30.0         Z location

#SATELLITEXYZ  3D Position of the satellite
65.0         X location
0.0          Y location
0.0          Z location

#ZEROBX
T            Bx is ignored and set to zero if true

#TIMEDELAY
3600.0       A constant delay added to the time in the file [s]
\end{verbatim}
The #REREAD command tells BATS-R-US to reread the solarwind file
when the simulation goes past the time of the last data in the current file.
The default behavior is to keep using the last data point, but
this can also be changed with the #REFRESHSOLARWINDFILE command.

The #VAR command allows reading an extended set of variables,
e.g. densities of multiple species, electron pressure, etc.

Finally, the data should be preceded by a {\tt #START}.  The beginning of
a typical solar wind input file might look like:
\begin{verbatim}
#COOR
GSM

#START
 2004  6  24   0   0  58   0  2.9  -3.1 - 3.7  -300.0  0.0  0.0  5.3  2.00E+04
 2004  6  24   0   1  58   0  3.0  -3.2 - 3.6  -305.0  0.0  0.0  5.4  2.01E+04
\end{verbatim}

The maximum number of lines of data allowed in the input file is 50,000.
However, this can be modified by changing the variable Max_Upstream_Npts
in the file GM/BATSRUS/get_solar_wind_point.f90.
</command>

<command name="REFRESHSOLARWINDFILE">
  <parameter name="DoReadAgain" type="logical" default="F"/>

#REFRESHSOLARWINDFILE
T			DoReadAgain

If DoReadAgain is set to true and the code is using a solar wind data file,
the code will stop running when the time goes beyond the end of the last
data point in the solar wind input file and wait until new data arrives
(see #SOLARWINDFILE command). The same effect can be achieved with the #REREAD
command put into the solar wind input file itself (see #SOLARWIND command).

Default is DoReadAgain false, so the code keeps running with the last
value read.
</command>

<command name="BODY" alias="MAGNETOSPHERE" if="$_IsFirstSession">
  <parameter name="UseBody" type="logical" default="F"/>
  <if expr="$UseBody">
    <parameter name="rBody" type="real" min="0" default="3"/>
    <parameter name="rCurrents" type="real" min="-1" default="4"
	       if="$NameComp eq 'GM'"/>
    <if expr="$nSpecies != 0">
      <for from="1" to="$nSpecies">
	<parameter name="BodyNDim" type="real" min="0" default="28"/>
      </for>
      <parameter name="BodyTDim" type="real" min="0" default="50000"/>
    </if>
    <if expr="$nSpecies == 0">  
      <for from="1" to="$nFluid">
	<parameter name="BodyNDim" type="real" min="0" default="28"/>
	<parameter name="BodyTDim" type="real" min="0" default="50000"/>
      </for>
    </if>
  </if>
#BODY
T			UseBody (rest of parameters read if true)
3.0			rBody
4.0			rCurrents (only read for GM component)
1.0			BodyNDim (/cc) for fluid 1
10000.0			BodyTDim (K)   for fluid 1
0.01			BodyNDim (/cc) for fluid 2
300.0			BodyTDim (K)   for fluid 2

#BODY
T			UseBody (rest of parameters read if true)
3.0			rBody
4.0			rCurrents (only read for GM component)
1.0			BodyNDim (/cc) for species 1
0.01			BodyNDim (/cc) for species 2
300.0			BodyTDim (K)

#MAGNETOSPHERE
T                       UseBody (rest of parameters read if true)
2.5                     rBody
3.5                     rCurrents (only read for GM component)
28.0                    BodyNDim (/cc)
25000.0                 BodyTDim (K)

Note that the #BODY command is most useful for Cartesian grids so that a sphere
can be cut out as the inner boundary.
For spherical grids the cell based boundary at the minimum radius
can be controlled with the #OUTERBOUNDARY and #BOUNDARYSTATE commands.

If UseBody is true, the inner boundary is a spherical surface
with radius rBody. The rBody is defined in units of the planet/solar
radius. It can be 1.0, in which case the simulation extends all the
way to the surface of the central body. In many cases it is more
economic to use an rBody larger than 1.

The rCurrents parameter defines where the currents are calculated for
the GM-IE coupling as well as for calculating the FAC contribution
of ground magnetic field perturbations.

The BodyNDim and BodyTDim parameters define the number density and temperature
inside the body, respectively. For multifluid MHD the number density and
temperature are given for all the fluids. For multispecies MHD the number
density is given for all species followed by the (common) temperature.
The exact effect of these parameters depends on the settings
in the #INNERBOUNDARY command.

The default is UseBody=F. Some typical settings are shown above.
</command>

<command name="CORONA" if="$_IsFirstSession">
  <parameter name="rCorona" type="real" min="0" default="1"/>  
  <for from="1" to="$nFluid">
    <parameter name="CoronaNDim" type="real" min="0" default="1.5e8"/>
    <parameter name="CoronaTDim" type="real" min="0" default="1.5e6"/>
  </for>
#CORONA
1.0                     rCorona
1.5E8			CoronaNDim (/cc) for fluid 1
1.5E6			CoronaTDim (K)
1.5E2                   CoronaNDim (/cc) for fluid 2
1.5E6                   CoronaTDim (K)

This command can be used to set physical parameters at the inner
boundary of the solar domain. Unlike the #BODY command, this command does
not switch on the face boundary. 
rCorona sets the radius of the inner boundary (typically 1 Rs).
The rest of the parameters set the density and temperature for AWSoM(-R).
For multi-fluid case, the values are repeated.

Default values are shown.
</command>

<command name="STAR" if="$_IsFirstSession">
  <parameter name="RadiusStar" type="real" minimum="0" default="1"/>
  <parameter name="MassStar"   type="real" minimum="0" default="1"/>
  <parameter name="RotationPeriodStar" type="real"/>

#STAR
1.0                     RadiusStar (in solar radius)
1.0                     MassStar   (in solar mass)
25.38                     RotationPeriodStar (in days)

Modify the parameters of the central star (when BATSRUS is running
in heliospheric mode). Setting zero for the rotation period will
switch off the rotation as shown by the example.

By default the Sun is the central star.
</command>

<command name="ROTPERIOD">
  <parameter name="RotPeriodSi" type="real" minimum="0"/>

#ROTPERIOD
0.0                     RotPeriodSI (in second)

If goal is to switch off (or modify) the effects of the star rotation
FOR A GIVEN MODEL (SC, IH, OH, EE), the #STAR command is not applicable,
since it also modifies the infrastructure (HGI to HGR stransformation matrix,
Earth location, Carrington rotations etc). For this purpose #ROTPERIOD
command works, which affects only the model, not the infrastructure.
</command>



<command name="NORMALIZATION" if="$_IsFirstSession">
  <parameter name="TypeNormalization" type="string" case="upper"
	     input="select">
    <option name="SI"/>
    <option name="PLANETARY" default="T"/>
    <option name="HELIOSPHERIC"/>
    <option name="OUTERHELIO"/>
    <option name="SOLARWIND"/>
    <option name="NONE"/>
    <option name="USER"/>
    <option name="READ"/>
  </parameter>
  <if expr="$TypeNormalization =~ /READ/">
    <parameter name="No2SiUnitX" type="real" min="0"   default="1"/>
    <parameter name="No2SiUnitU" type="real" min="0"   default="1"/>
    <parameter name="No2SiUnitRho" type="real" min="0" default="1"/>
  </if>
#NORMALIZATION
READ			TypeNormalization
1000.0			No2SiUnitX   (only read if TypeNormalization=READ)
1000.0			No2SiUnitU   (only read if TypeNormalization=READ)
1.0e-6			No2SiUnitRho (only read if TypeNormalization=READ)

This command determines what units are used internally in BATSRUS.
The units are normalized so that several physical constants become
unity (e.g. the permeability of vacuum), so the equations are simpler
in the code. The normalization also helps to keep the various
quantities within reasonable ranges. For example density of space
plasma is very small in SI units, so it is better to use some normalization,
like amu/cm$^3$. Also note that distances and positions (like grid size,
grid resolution, plotting resolution, radius of the inner body etc)
are always read in normalized units from the PARAM.in file.
Other quantities are read in I/O units (see the #IOUNITS command).

The normalization of the distance, velocity and density are
determined by the TypeNormalization parameter. The normalization
of all other quantities are derived from these three values.
It is important to note that the normalization of number density
(defined as the density normalization divided by the proton mass)
is usually not consistent with the inverse cube of the normalization
of distance.

Possible values for TypeNormalization are NONE, PLANETARY,
HELIOSPHERIC, OUTERHELIO, SOLARWIND, USER and READ.

If TypeNormalization="NONE" then the distance, velocity and density
units are the SI units, i.e. meter, meter/sec, and kg/m$^3$.
Note that the magnetic field and the temperature are still normalized
differently from SI units so that the Alfven speed is $B/\sqrt{\rho}$
and the ion temperature is simply $p/(\rho/AverageIonMass)$,
where the AverageIonMass is given relative to the mass of proton.

If TypeNormalization="PLANETARY" then the distance unit is the
radius of the central body (moon, planet, or the Sun). If there is
no central body, the length normalization is 1km. The velocity unit
is rPlanet/s (so time unit is seconds), and the density unit is amu/cm3.

If TypeNormalization="HELIOSPHERIC" then the distance unit is the
radius of the central body (Sun, star), the velocity unit is km/s,
and the density unit is amu/cm3.

If TypeNormalization="OUTERHELIO" then the distance unit is 1 AU,
the velocity unit is km/s, and the density unit is amu/cm3.

TypeNormalization="SOLARWIND" is depreciated! Don't use it.
If it is used then the distance unit is the radius of the
planet, and the velocity and density are normalized to
the density and the sound speed of the solar wind defined by
the #SOLARWIND or #SOLARWINDFILE commands. This normalization
is very impractical, because it depends on the solar wind values
that are variable, and may not even make sense (e.g. for a shock tube test).
This normalization is only kept for sake of backwards compatibility
for a few user modules (Mars, Venus, Titan, Saturn).

If TypeNormalization="USER" the normalization is set in the user module.
This may be useful if the normalization depends on some input parameters.

Finally TypeNormalization="READ" reads the three basic normalization units from
the PARAM.in file as shown in the example. This allows arbitrary normalization.

The restart header file saves the normalization with TypeNormalization="READ"
and the actual values of the distance, velocity and density normalization
factors. This avoids the problem of continuing the run with inconsistent
normalization (e.g. if the SOLARWIND normalization is used and the
solar wind parameters have been changed). It also allows other programs
to read the data saved in the restart files and convert them to appropriate
units.

The default normalization is PLANETARY for GM
and SOLARWIND for all other components.
</command>

<command name="IOUNITS" if="$_IsFirstSession">
  <parameter name="TypeIoUnit" type="string" input="select">
    <option name="SI"/>
    <option name="PLANETARY"    default="$NameComp eq 'GM'"    />
    <option name="OUTERHELIO"   default="$NameComp eq 'OH'"    /> 
    <option name="HELIOSPHERIC" default="$NameComp !~ /GM|OH/" />
    <option name="NONE"/>
    <option name="USER"/>
  </parameter>
#IOUNITS
PLANETARY			TypeIoUnit

This command determines the physical units of various parameters read from the
PARAM.in file and written out into log files and plot files (if they are
dimensional. The units are determined by the TypeIoUnit string.
Note that distances and positions are always read in normalized units from
PARAM.in but they are written out in I/O units.
In most cases the two coincides.

Also note that the I/O units are NOT necessarily physically consistent units.
For example one cannot divide distance with time and compare it with
the velocity because they may be in inconsistent units.
One needs to convert into some consistent units before the various quantities
can be combined.

If TypeIoUnits="SI" the input and output values are taken in SI units
(m, s, kg, etc).

The PLANETARY units use the radius of the planet for distance,
seconds for time, amu/cm$^3$ for mass density, cm$^-3$ for number density,
km/s for speed, nPa for pressure, nT for magnetic field, micro Amper/m$^2$
for current density, mV/m for electric field, nT/planet radius for div B,
and degrees for angles. For any other quantity SI units are used.
If there is no planet (see the #PLANET command) then the distance
unit is 1 km.

The HELIOSPHERIC units use the solar radius for distance, seconds for time,
km/s for velocity, degrees for angle, and
CGS units for mass density, number density, pressure,
magnetic field, momentum, energy density, current, and div B.

When TypeIoUnit="NONE" the input and output units are the same as
the normalized units (see the #NORMALIZATION command).

Finally when TypeIoUnit="USER", the user can modify the I/O units
(Io2Si_V) and the names of the units (NameTecUnit_V and NameIdlUnit_V)
in the subroutine user_io_units of the user module.
Initially the values are set to SI units.

The #IOUNITS command and the value of TypeIoUnits is saved into the
restart header file so that one continues with the same I/O units
after restart.

The default is "PLANETARY" unit if BATSRUS is used as the GM component
and "HELIOSPHERIC" otherwise (EE, SC, IH or OH).
</command>

<command name="RESTARTINDIR" if="$_IsFirstSession">
  <parameter name="NameRestartInDir" type="string" length="$lLine"
	     default="GM/restartIN" />
  <rule expr="-d $NameRestartInDir">
    Restart input directory $NameRestartInDir must exist!
  </rule>

#RESTARTINDIR
GM/restart_n5000	NameRestartInDir

The NameRestartInDir variable contains the name of the directory
where restart files are saved relative to the run directory.
The directory should be inside the subdirectory with the name
of the component.

Default value is "GM/restartIN".
</command>

<command name="RESTARTINFILE" if="$_IsFirstSession">
  <parameter name="StringRestartInFile" type="strings" min="1" max="2">
    <part name="TypeRestartInFile" type="string" input="select" required="T">
      <option name="single data.rst file" value="one"/>
      <option name="separate files/proc"  value="proc" default="T"/>
    </part>
    <part name="StringSeries" type="string" input="select"
	  required="F">
      <option name="series"/>
    </part>
  </parameter>

#RESTARTINFILE
one series			TypeRestartInFile

This command is saved in the restart header file which is included during
restart, so normally the user does not have to use this command at all.
The TypeRestartInFile parameter describes how the restart data was saved:
into separate files for each processor ('proc'),
or into a single direct access file ('one').
The optional 'series' string means that a series of restart files
were saved with the iteration number added to the beginning of the file names.

The default value is 'proc'.
</command>

<command name="NEWRESTART" if="$_IsFirstSession">
  <parameter name="DoRestartBFace" type="logical" default="F" />

#NEWRESTART
T		DoRestartBFace

The RESTARTINDIR/restart.H file always contains the #NEWRESTART command.
This command is really used only in the restart headerfile.  Generally
it is not inserted in a PARAM.in file by the user.

The #NEWRESTART command sets the following global variables:
DoRestart=.true. (read restart files),
DoRestartGhost=.false.  (no ghost cells are saved into restart file)
DoRestartReals=.true.   (only real numbers are saved in blk*.rst files).

The DoRestartBFace parameter tells if the face centered magnetic field
is saved into the restart files. These values are used by the
Constrained Transport scheme.
</command>

<command name="RESTARTFULLB">
  <parameter name="UseRestartWithFullB" type="logical" default="T"/>

#RESTARTFULLB
F                   UseRestartWithFullB

This command decides if the restart file contains the full magnetic field
(B=B0+B1) or only B1. The command is written ino the restart header file
to indicate the content of the restart file.

Saving the total field allows changing B0 during restart and also allows using
the restart files without knowledge of B0.

The current default is saving total B.
</command>

<command name="RESTARTWITHFULLB">
#RESTARTWITHFULLB

This command is only for backward compatibility. It is present in prior
restart file headers and it sets UseRestartWithFullB to true value.
</command>

<command name="OUTERBOUNDARY">
  <for name="iSide" from="1" to="2*$nDim">
    <parameter name="TypeBc$iSide" type="string" input="select">
      <option name="none" default="T"/>
      <option name="coupled" />
      <option name="periodic"/>
      <option name="float"/>
      <option name="outflow" />
      <option name="reflect"/>
      <option name="linetied"/>
      <option name="fixed"/>
      <option name="fixed B1" value="fixedb1"/>
      <option name="inflow/vary"/>
      <option name="ihbuffer"/>
      <option name="shear"/>
      <option name="fieldlinethreads"/>
      <option name="user"/>
      <option name="userfixvalue"/>
      <option name="usernoinflow"/>
    </parameter>
  </for>
  <set name="_OUTERBOUNDARY" type="logical" value="T"/>
  <rule
      expr="not($TypeBc1 eq 'periodic' xor $TypeBc2 eq 'periodic')">
    First and second BCs must be both periodic or neither
  </rule>
  <rule
      expr="not($TypeBc3 eq 'periodic' xor $TypeBc4 eq 'periodic')">
    Third and fourth BCs must be both periodic or neither
  </rule>
  <rule
      expr="not($TypeBc5 eq 'periodic' xor $TypeBc6 eq 'periodic')">
    Fifth and sixth BCs must be both periodic or neither
  </rule>
#OUTERBOUNDARY
outflow                 TypeBc1
inflow                  TypeBc2
float                   TypeBc3 (only read in 2D and 3D)
float                   TypeBc4 (only read in 2D and 3D)
float                   TypeBc5 (only read in 3D)
float                   TypeBc6 (only read in 3D)

This command defines how the ghost cells are filled in at the cell
based boundaries at the edges of the grid.  TypeBc1 and TypeBc2
describe the boundaries at the minimum and maximum values of the first
(generalized) coordinate.  For a Cartesian grid these are at xMin and
xMax, while for a spherical or cylindrical grid these are at rMin and
rMax.  TypeBc3 and TypeBc4 describe the boundaries at the minimum and
maximum values of the second (generalized) coordinate for 2D and 3D
grids.  TypeBc5 and TypeBc6 describe the boundaries at the minimum and
maximum values of the third (generalized) coordinate for 3D grids.

Possible values:
\begin{verbatim}
coupled       - set from coupling with another component
periodic      - periodic
float         - zero gradient for all variables except:
                Phi=0 set for the scalar in hyperbolic div B control (see #HYPERBOLICDIVB)
		radiative outflow boundaries are applied for radiation energy densities
outflow       - same as 'float' but the pressure is set to pOutflow from #OUTFLOWPRESSURE
reflect       - reflective (anti-symmetric for the normal components of V and B,
                            symmetric for all other variables)
linetied      - symmetric for density, anti-symmetric for momentum, float all others
fixed         - fixed solarwind values, total B is set
fixedB1       - fixed solarwind values, B1 is set
inflow/vary   - time dependent boundary based on solar wind input file (#SOLARWINDFILE)
shear         - sheared (intended for shock tube problem only)
ihbuffer      - values obtained from the IH component (this is set automatically)
none          - do not change ghost cells. This is useful if the outer boundary is not used.
fieldlinethreads - threaded magnetic field BC for AWSOM-R solar model
user          - user defined
\end{verbatim}

Here are some tips for spherical grids. If the box defined in the
#GRID command is completely inside the spherical grid (defined by
#LIMITRADIUS) then the outer cell boundary at rMax is not used.  If a
"body" is used (see #BODY command) with a radius larger or equal than
the minimum radius of the spherical grid (defined by #LIMITRADIUS)
then the cell boundary at rMin is not used.  On the other hand, if the
box defined by #GRID is completely outside the spherical grid then the
rMax cell boundary is used, and if there is no body defined, or if it
has smaller radius than rMin, then the cell boundary at rMin is used.
One can mix cell and face based boundaries. For example the xMin
defined by #GRID may cut through the spherical grid, while the xMax
... zMax may be outside. This can be used to define inflow at the face
based boundary at xMin using the #BOXBOUNDARY command, while the cell
boundaries at the rMax boundary can be set to outflow using the
#OUTERBOUNDARY command.

The default values are 'none' on all sides.
</command>

<command name="BOXBOUNDARY">
  <for name="iSide" from="1" to="2*$nDim">
    <parameter name="TypeBc$iSide" type="string" input="select">
      <option name="float"          default="T"/>
      <option name="outflow"/>
      <option name="reflect"/>
      <option name="reflectb"/>
      <option name="reflectall"/>
      <option name="fixed"/>
      <option name="fixed B1" value="fixedB1"/>
      <option name="zeroB1"/>
      <option name="inflow/vary"/>
      <option name="user"/>
    </parameter>
  </for>
  <set name="_BOXBOUNDARY" type="logical" value="T"/>
  
#BOXBOUNDARY
outflow                 TypeBcXmin
inflow                  TypeBcXmax
float                   TypeBcYmin (only read in 2D and 3D)
float                   TypeBcYmax (only read in 2D and 3D)
float                   TypeBcZmin (only read in 3D)
float                   TypeBcZmax (only read in 3D)

This command defines how the face boundary values are set at the
brick-shaped box cut out of a generalized coordinate grid.  Normally
this command should not be used for a Cartesian grid, but it is still
allowed.  The size of the box is defined by the xMin ... zMax
parameters of the #GRID command.

General notes: face based boundary conditions are 1st order accurate
in general, while cell based boundary conditions can be 2nd order accurate.
Sometimes, however, it is easier to define a face value than the state
of the ghost cells that are outside the computational domain.
In our current implementation cell based boundaries can be used only at the
outer edges of the grid.

On the other hand, face based boundaries can be applied
anywhere. For a face boundary each cell center is marked as either
physical or boundary cell, and the boundary conditions are applied at
cell faces between a physical and a boundary cell center.
The actual boundary will be ragged (along the cell faces) and this can
in fact cause numerical problems. For supersonic outflow, the dot product
of the face normal and the flow velocity should be positive, for inflow
it should be negative.

The outer boundaries have to be face based if a brick-shaped
computational domain is cut out from the sphere/cylinder
(see the #LIMITRADIUS and #GRID commands) because the boundary is not
aligned with the grid boundaries.
If the computational domain is the full sphere/cylinder, then cell based
boundaries can be used (see #OUTERBOUNDARY).

Possible values:
\begin{verbatim}
float         - zero gradient for all variables except:
                Phi=0 set for the scalar in hyperbolic div B control (see #HYPERBOLICDIVB)
                radiative outflow boundaries are applied for radiation energy densities
outflow       - same as 'float' but the pressure is set to pOutflow from #OUTFLOWPRESSURE
reflect       - reflect the normal component of B1, reflect the full velocity vector
reflectb      - reflect the normal component of full B, reflect the full velocity vector
reflectall    - reflect the normal component of B1 and velocity, symmetric for all other
linetied      - reflective for velocity, float for all others
fixed         - fixed values (set by #SOLARWIND or #BOUNDARYSTATE), total B is set
fixedB1       - fixed values (set by #SOLARWIND or #BOUNDARYSTATE), B1 is set
zeroB1	      - B1 is reflected, all other variables float
inflow/vary   - time dependent boundary based on solar wind input file (#SOLARWINDFILE)
user          - user defined
\end{verbatim}

There are no default values. User must set face boundary type if a box is cut out of a non-Cartesian grid.
</command>

<command name="BOUNDARYSTATE" multiple="T">
  <parameter name="StringBoundary" type="string" length="$lLine"/>
  <for from="1" to="$nVar">
    <parameter name="BoundaryStateDim_V" type="real"/>
  </for>

#BOUNDARYSTATE
body1 1 2 xminbox	StringBoundary
1.0			BoundaryStateDim_V Rho
1.0			BoundaryStateDim_V Ux
1.0			BoundaryStateDim_V Uy
1.0			BoundaryStateDim_V Uz
0.0			BoundaryStateDim_V Bx
0.0			BoundaryStateDim_V By
0.0			BoundaryStateDim_V Bz
0.0			BoundaryStateDim_V Hyp
1.0			BoundaryStateDim_V P

This command sets the primitive variables BoundaryState_V
at one or more boundaries.
The first parameter StringBoundary contains a space separated list
of the names or indexes of the desired boundaries to be set.
Both face and cell type boundaries can be listed.

The BoundaryStateDim_V are the nVar primitive variables used at the boundary
in the order defined in the equation module ModEquation.
The values are given in I/O units (see #IOUNITS command).

All boundaries can be identified with strings. Some boundaries can
also be idenitified with an index between -3 and 6.
Possible idenitfiers that can be listed in StringBoundary:
\begin{verbatim}
solid, -3	- solid face boundary            (#SOLIDSTATE)
body2, -2	- second body face boundary      (#INNERBOUNDARY, #SECONDBODY)
body1, -1	- first body face boundary       (#INNERBOUNDARY, #BODY)
extra,  0	- extra face boundary            (#EXTRABOUNDARY)
xminbox		- min x coordinate face boundary (#BOXBOUNDARY, #GRID)
xmaxbox		- max x coordinate face boundary
yminbox		- min y coordinate face boundary
ymaxbox		- max y coordinate face boundary
zminbox		- min z coordinate face boundary
zmaxbox		- max z coordinate face boundary
coord1min, 1	- min 1st (gen. coord.) cell boundary (#OUTERBOUNDARY)
coord1max, 2	- max 1st (gen. coord.) cell boundary (#GRIDGEOMETRY)
coord2min, 3    - min 2nd (gen. coord.) cell boundary (#LIMITRADIUS)
coord2max, 4    - max 2nd (gen. coord.) cell boundary (#GRIDGEOMETRYLIMIT)
coord3min, 5    - min 3rd (gen. coord.) cell boundary
coord3max 6     - max 3rd (gen. coord.) cell boundary
\end{verbatim}

For each boundary name/index the commands controlling the boundary are
shown on the right. Note that for Cartesian grids the outer boundaries
are always cell based and the box boundary cannot be used.
For non-cartesian grids the cell based outer boundaries refer to the edges
of the domain given in generalized coordinates (for example rMin or rMax),
while the face based box boundaries refer to a box cut out of the
non-cartesian grid at the values xMin ... zMax given in the #GRID command.

There are no default values. The boundary name(s)/index(es) and primitive
state values must be given.
</command>

<command name="SOLIDSTATE">
  <parameter name="UseSolidState" type="logical"/>
  <if expr="$UseSolidState">
    <parameter name="TypeBcSolid" type="string"/>
    <parameter name="TypeSolidGeometry" type="string"/>
    <parameter name="rSolid" type="real" if="$TypeSolidGeometry eq 'sphere'"/>
    <parameter name="SolidLimitDt" type="real"/>
  </if>

#SOLIDSTATE
F			UseSolidState (rest read if true)
user			TypeBcSolid
sphere			TypeSolidGeometry
1.0			rSolid
5e-3			SolidLimitDt

This command sets the solid boundary parameters. Solid boundary is one type of
face boundary. Currently it works only for a sphere geometry with radius
rSolid. In local time stepping mode the timestep inside the solid body
is set to SolidLimitDt.

Default is UseSolidState=.false.
</command>

<command name="OUTFLOWPRESSURE">
  <parameter name="UseOutflowPressure" type="logical" default="F"/>
  <parameter name="pOutflowSi" type="real" min="0" defaulte="1e5"
	     if="$UseOutflowPressure"/>

#OUTFLOWPRESSURE
T			UseOutflowPressure
1e5			pOutflowSi (read if UseOutflowPressure is true)

Set pressure for "outflow" boundary condition. This matters for
subsonic outflow. Default is UseOutflowPressure=.false.
</command>

<command name="INNERBOUNDARY">
  <parameter name="TypeBcBody" type="string" case="lower"
	     input="select">
    <option name="absorb"			/>
    <option name="radialstate"                  />
    <option name="reflect"			/>
    <option name="reflectb"			/>
    <option name="reflectall"			/>
    <option name="float"			/>
    <option name="outflow"			/>
    <option name="fixed"			/>
    <option name="fixedb1"			/>
    <option name="inflow"			/>
    <option name="vary"				/>
    <option name="ionosphere"	    default="T" />
    <option name="ionosphereoutflow"		/>
    <option name="ionospherefloat"		/>
    <option name="linetied"			/>
    <option name="polarwind"			/>
    <option name="buffergrid"			/>
    <option name="user"				/>
  </parameter>
  <if expr="$UseBody2">
    <parameter name="TypeBcBody2" type="string" case="lower"
	       input="select">
      <option name="absorb"			/>
      <option name="fixed"			/>
      <option name="radialstate"                />
      <option name="reflect"	default="T" 	/>
      <option name="reflectb"			/>
      <option name="reflectall"			/>
      <option name="float"			/>
      <option name="ionosphere"	    		/>
      <option name="ionospherefloat"		/>
      <option name="linetied"			/>
      <option name="buffergrid"			/>
      <option name="body2orbit"			/>
      <option name="user"			/>
    </parameter>
  </if>
  <rule
      expr="not($TypeBcBody2 =~ /ionosphere/)">
    For the second body COROTATION AND AN IONOSPHERIC BOUNDARY DO NOT WORK.
  </rule>
#INNERBOUNDARY
ionosphere              TypeBcBody
ionosphere              TypeBcBody2  !read only if UseBody2=T

TypeBcBody determines the boundary conditions at the spherical surface of
the inner body when these are described with face boundary conditions.
For Cartesian grids this is always the case, because the spherical surface
is not aligned with the grid blocks, so a ghost cell based boundary condition
is not possible. For spherical grids, however, both the cell and face based
boundary conditions can be used depending on the combination of commands.
If face based boundary is used then the boundary condition at the body
surface is determined here as TypeBcBody; if cell based boundary is used then
the boundary condition at the body surface is determined by the TypeBc1
parameter of the #OUTERBOUNDARY command.

TypeBcBody2 is only read if the second body is used (see the #SECONDBODY
command that has to occur BEFORE this command).
The second body can be anywhere in the computational domain,
so its sperical surface is never aligned with the grid block boundaries,
consequently only face boundary conditions can be applied which
is controlled by this command. It can have the same types as TypeBcBody,
although not all those options are meaningful.

Possible values for TypeBcBody are:
\begin{verbatim}
'absorb'          - float all variables but reflect Vr if Vr > 0
'radialstate'     - fixed with the state defined by #RADIALSTATE
'reflect'         - reflect all components of velocity relative to corotation,
                    reflect the normal component of B1, other variables float
'reflectb'        - same as reflect, but the normal component of full B is reflected.
'reflectall'      - reflect the normal component of B1 and all velocities.
		    This is the perfectly conducting sphere. B0 should be 0.
'float'           - float all variables
'outflow'	  - same as 'float' but the pressure is set to pOutflow from #OUTFLOWPRESSURE
'fixed'           - use initial solar wind values. Total B is set to solar wind B.
'fixedb1'	  - use initial solar wind values. B1 is set is to solar wind B.
'inflow/vary'     - set the solar wind values. Total B is set to solar wind B.
'ionosphere'      - reflect velocity relative to corotation + ionosphere ExB drift
                    float B, fix rho, float P
'ionospherefloat/linetied' - same as ionosphere but density floats too
'ionosphereoutflow' - same as ionosphere but an empirical outflow formula
                    is applied above 55 degrees latitude.  See #OUTFLOWCRITERIA for more information.
'polarwind'       - same as ionosphere, but in the polar region use
                    the density and velocity from PW component if coupled,
                    or apply values read from the #POLARBOUNDARY command
'buffergrid'      - IH(OH) component obtains inner boundary from the SC(IH)
		    component, through a buffer grid. The buffer grid is set
		    by the #BUFFERGRID or #HELIOBUFFERGRID commands. In
		    SC/GM coipling the second body BC is implemented via the
		    buffer grid filled in from GM, for exoplanet orbiting in
		    the stellar corona.
'user'            - user defined
\end{verbatim}
For 'ionosphere' and 'ionospherefloat' types and a coupled GM-IE run,
the velocity at the inner boundary is determined by the ionosphere model.

The 'absorb' inner BC only works with #ROTATION false.

The boundary condition on Br can be changed with the #MAGNETICINNERBOUNDARY
command.

For the second body TypeBcBody2 can have the following values:
'absorb', 'reflect', 'reflectb', 'reflectall', 'float', 'ionosphere',
'ionospherefloat/linetied',
however, the corotation and ionospheric drift velocities
are zero for the second body.

Default value for TypeBcBody is 'none' for the GM, EE, SC, IH and OH components,
so the inner boundary must be set by this command except the cell boundary for
spherical coordinates case.
Default value for TypeBcBody2 is 'none'.
</command>

<command name="#ELECTRONPRESSURERATIO">
  <parameter name="ElectronTemperatureRatio" type="real" min="0" default="0"/>
  <parameter name="InnerBcPeRatio" type="real" min="0" default="0.1282"/>

#ELECTRONPRESSURERATIO
1.0             ElectronTemperatureRatio  
1/7.8           InnerBcPeRatio

The ElectronTemperatureRatio is the same as the last parameter of the
#PLASMA command. It is used to set the electron pressure at the outer
boundary and for the initial condition. 

The InnerBcPeRatio is the electron pressure ratio assumed at or near the inner
boundary. This parameter is used in two different ways.
When BATSRUS solves for the electron pressure as a separate variable,
it is used for inner boundary conditions for Pe.
When 'ionosphere', 'polarwind' or 'ionosphereoutflow' inner boundary is used,
the electron pressure is set to be float at the inner boundary by default.
In order to avoid extremely low electron pressure in the inner magnetosphere,
this command ensures the ratio between the electron pressure and ion pressure
at the inner boundary is at least InnerBcPeRatio.

When BATSRUS does not solve for electron pressure, the InnerBcPeRatio constant
is used in the coupling with RCM to set the electron pressure passed to RCM
to InnerBcPeRatio times the pressure of the first ion fluid.

The default values are ElectronTemperatureRatio=0 and InnerBcPeRatio=1/7.8.
</command>

<command name="OUTFLOWCRITERIA">
  <parameter name="OutflowVelocity" type="real" min="-1" default="-1"/>
  <parameter name="FluxAlpha" type="real" default="2.142E7"/>
  <parameter name="FluxBeta"  type="real" default="1.265"/>
#OUTFLOWCRITERIA
-1              OutflowVelocity [km/s]
2.142E7         FluxAlpha
1.265           FluxBeta

This command configures the empirical outflow relationship that is activated
via the #INNERBOUNDARY command when TypeBcBody is set to 'ionosphereoutflow'.
The empirical relationship is based on the work of \textit{Strangeway et al.,
2005}:
\begin{equation}
F_{O^+} = \alpha S_{\parallel}^{\beta}
\end{equation}
...where $F_{O^+}$ is the local upflowing oxygen flux, $S_{\parallel}$ is the
local field-aligned Poynting flux, and $\alpha$ and $\beta$ are fitting
coefficients based on observations from the FAST spacecraft.  Default values
for $\alpha$ and $\beta$, shown above, are taken directly from
\textit{Strangeway et al., 2005}.  In BATS-R-US, Poynting flux is taken
from coupling with the IE module.

The OutflowVelocity paramter sets the radial velocity of the outflow, which
also controls how flux is converted into number density:
\begin{equation}
n_{O^+} = F_{O^+} / U_{R}
\end{equation}
If OutflowVelocity is negative, the radial velocity of oxygen is set using the
energy of the fluid as obtained via the local Joule heating and field-aligned-
current conditions (obtained via IE coupling).  This is the default behavior.

For more information on the empirical relationship for flux, see
Strangeway, R., Ergun, J. R. E., Su, Y. J., Carlson, C. W., \& Elphic, R. C.
(2005). Factors controlling ionospheric outflows as observed at intermediate
altitudes. Journal of Geophysical Research, 110(A3), A03221.
http://doi.org/10.1029/2004JA010829

</command>

<command name="MAGNETICINNERBOUNDARY">
  <parameter name="B1rCoef" type="real" min="-1" max="1" default="-1"/>

#MAGNETICINNERBOUNDARY
-1.0		B1rCoef

The radial component of B1 on the ghost face is set as
B1rGhost = B1rCoef*B1rTrue at the inner boundary. B1rCoef=-1 corresponds
to a reflective boundary, while B1rCoef=1 is a floating
(zero gradient) boundary. Any value between -1 and 1 is possible.
Using floating condition, however, will not work well for strong storms,
as there is no mechanism to restore the dipole after the storm.
Reflective will recover the dipole, but it may result in some less
stable behavior. The optimal value may be problem dependent.

The default value corresponding to reflection is shown above.
</command>

<command name="BUFFERGRID">
  <parameter name="nRBuff" type="integer" min="2"        default="2" />
  <parameter name="nLonBuff" type="integer" min="2"      default="90" />
  <parameter name="nLatBuff" type="integer" min="2"      default="45" />
  <parameter name="RBuffMin" type="real" min="0"         default="19" />
  <parameter name="RBuffMax" type="real" min="$rBuffMin" default="21" />
  <parameter name="LonBuffMin" type="real"               default="0"
	     min="0" max="360" />
  <parameter name="LonBuffMax" type="real"               default="360"
	     min="$PhiBuffMin" max="360" />
  <parameter name="LatBuffMin" type="real"               default="-90"
	      min="-90" max="90" />
  <parameter name="LatBuffMax" type="real"               default="90"
	     min="$LatBuffMin" max="90" />

#BUFFERGRID
2	nRBuff
90	nLonBuff
45	nLatBuff
19.0	rBuffMin
21	rBuffMax
0.0	LonBuffMin
360.0	LonBuffMax
-90.0	LatBuffMin
90.0	LatBuffMax

Define the radius, angular extent and the grid resolution of the
uniform spherical buffer grid used to pass information between two
coupled components running BATSRUS.

The parameters nRBuff, nPhiBuff and nThetaBuff determine the number of
points in the radial, azimuthal and latitudinal directions,
respectively.

The parameters rBuffMin and rBuffMax determine the inner and outer
radii of the spherical shell.

PhiBuffMin, PhiBuffMax, LatBuffMin and LatBuffMax determine the
limits (in degrees) of the buffer grid in the azimuthal and
latitudinal directions.

When used to pass information from the SC(IH)
component to the IH(OH) component, the entire shperical shell should
be used (alternativly, use the #HELIOBUFFERGRID command), but in
certain application only a part of the shell may be needed. The buffer
should be placed in a region where the two components overlap, and the
grid resolution should be similar to the grid resolution of the
coarser of the two component grids.  This command can only be used in
the first session by the IH(OH) component.  The buffer grid will only
be used if 'buffergrid' is chosen for TypeBcBody in the
#INNERBOUNDARY command of the target component.  Default values are
shown above.

</command>

<command name="BUFFERBODY2">
  <parameter name="nRBuff" type="integer" min="2"        default="2" />
  <parameter name="nLonBuff" type="integer" min="2"      default="90" />
  <parameter name="nLatBuff" type="integer" min="2"      default="45" />
  <parameter name="RBuffMin" type="real" min="0"         default="19" />
  <parameter name="RBuffMax" type="real" min="$rBuffMin" default="21" />
  <parameter name="LonBuffMin" type="real"               default="0"
	     min="0" max="360" />
  <parameter name="LonBuffMax" type="real"               default="360"
	     min="$PhiBuffMin" max="360" />
  <parameter name="LatBuffMin" type="real"               default="-90"
	      min="-90" max="90" />
  <parameter name="LatBuffMax" type="real"               default="90"
	     min="$LatBuffMin" max="90" />

#BUFFERBODY2
2	nRBuff
90	nLonBuff
45	nLatBuff
19.0	rBuffMin
21	rBuffMax
0.0	LonBuffMin
360.0	LonBuffMax
-90.0	LatBuffMin
90.0	LatBuffMax

Define the radius, angular extent and the grid resolution of the
uniform spherical buffer grid used to pass information between two
coupled components running BATSRUS. In contrast with the #BUFFERGRID
command, the grid is concetric with the second body, not heliocentric.

The parameters nRBuff, nPhiBuff and nThetaBuff determine the number of
points in the radial, azimuthal and latitudinal directions,
respectively.

The parameters rBuffMin and rBuffMax determine the inner and outer
radii of the spherical shell.

PhiBuffMin, PhiBuffMax, LatBuffMin and LatBuffMax determine the
limits (in degrees) of the buffer grid in the azimuthal and
latitudinal directions.

When used to pass information from the GM component to the SC component,
the entire shperical shell should be used. The buffer should be placed in
a region where the two components
overlap, and the grid resolution should be similar to the grid resolution
of the coarser of the two component grids.  This command can only be used in
the first session by the SC component.  The buffer grid will only
be used if 'buffergrid' is chosen for TypeBcBody2 in the
#INNERBOUNDARY command of the target component.  Default values are
shown above.

</command>

<command name="EXTRABOUNDARY">
  <parameter name="UseExtraBoundary" type="logical" default="F"/>
  <if expr="$UseExtraBoundary">
    <parameter name="TypeExtraBoundary" type="string"/>
  </if>

#EXTRABOUNDARY
T		UseExtraBoundary
user		TypeExtraBoundary

If UseExtraBoundary is true, the user can define an extra face boundary
condition in the user files. The location of this boundary is defined
in the user_set_boundary_cells routine, while the boundary condition
itself is implemented into the user_set_face_boundary. The extra boundary
has index ExtraBc_=0. The TypeExtraBoundary parameter can be used to
select from multiple boundary conditions implemented in the user module.
</command>

<command name="POLARBOUNDARY">
  <parameter name="PolarNDim" type="real" min="0"     default="20"/>
  <parameter name="PolarTDim" type="real" min="-1"    default="1e5"/>
  <parameter name="PolarUDim" type="real" min="0"     default="1"/>
  <parameter name="PolarLatitude" type="real" min="0" default="75"/>
#POLARBOUNDARY
20.0		PolarNDim [amu/cc] for fluid 1
100000.0	PolarTDim [K]      for fluid 1
1.0		PolarUDim [km/s]   for fluid 1
2.0		PolarNDim [amu/cc] for fluid 2
-1.0		PolarTDim [K]      for fluid 2
1.5		PolarUDim [km/s]   for fluid 2
75.0		PolarLatitude [deg]

This command defines the boundary conditions in the polar region. The
number density, temperature and velocity can be given (for all fluids
in multifluid calculations). Negative temperature value sets the
pressure float.  This mimics polar wind like inner boundary conditions
when GM is not coupled with the PW component.  The PolarLatitude
parameter determines the latitudinal extent of the polar boundary
where the outflow is defined.
</command>

<command name="CPCPBOUNDARY">
  <parameter name="UseCpcpBc" type="logical" default="F"/>
  <if expr="$UseCpcpBc">
    <for from="1" to="max($nIonFluid,$nSpecies)">
      <parameter name="Rho0Cpcp" type="real" min="0" default="18"/>
      <parameter name="RhoPerCpcp" type="real" min="0" default="0.2"/>
    </for>
  </if>
#CPCPBOUNDARY
T                       UseCpcpBc  (rest is read if true)
28.0                    Rho0Cpcp   [amu/cc] for 1st ion fluid/species
0.1                     RhoPerCpcp [amu/cc / kV]
8.0			Rho0Cpcp   [amu/cc] for 2nd ion fluid/species
0.3			RhoPerCpcp [amu/cc / kV]

NOTE: For this feature the inner boundary type has to
be "ionosphere" and the GM and IE components have to be coupled together.

If UseCpcpBc is true, the ion mass densities at the inner boundary will
depend on the cross polar cap potential (CPCP) in a linear fashion:

RhoBc = Rho0Cpcp[i] + RhoPerCpcp[i] * Cpcp

where i is the index of the ion fluid or ion species, RhoBc and
Rho0Cpcp are in I/O units (typically amu/cc), the Cpcp is given in
[kV], and the RhoPerCpcp factor is in density units per kV.  The Cpcp
is the average of the northern and southern CPCPs.  The example shows
some reasonable values for hydrogen and oxygen.  For CPCP = 0 kV
RhoBc[H+] = 28 amu/cc and RhoBc[O+] = 8 amu/cc, while for CPCP = 400
kV RhoBc[H+] = 68 amu/cc and RhoBc[O+] = 128 amu/cc.

By default the density at the inner boundary is determined by the body
density given in the #BODY (same as #MAGNETOSPHERE) command.
</command>

<command name="YOUNGBOUNDARY">
  <parameter name="UseYoungBc" type="logical" default="F"/>
  <if expr="$UseYoungBc">
    <parameter name="F107Young" type="real" min="0" default="150.0"/>
  </if>
#YOUNGBOUNDARY
T                       UseYoungBc  (rest is read if true)
150.0                   F107Young

NOTE: For this feature the inner boundary type has to
be "ionosphere" and the GM and IE components have to be coupled together.
Kp must be calculated via #GEOMAGINDICES.

This option sets the mass density via the Young et al. 1982 empirical
relationship for composition.  It uses Kp (calculated by GM/BATSRUS)
and F10.7 flux (given as command argument) to determine the ratio of O+ to H+.
The mass density of the inner boundary will be adjusted to match this ratio.
The total number density is taken as constant from the #BODY command.

</command>

<command name="OHBOUNDARY">
  <parameter name="UseOhNeutralBc" type="logical" default="F"/>
  <if expr="$UseOhNeutralBc">
    <for from="1" to="$nNeutralFluid">
      <parameter name="RhoNeuFactor" type="real" min="0" default="1"/>
      <parameter name="uNeuFactor"   type="real" min="0" default="1"/>
    </for>
  </if>

#OHBOUNDARY
T                       UseOhNeutralBc (rest of parameters are read if true)
0.05                    RhoNeuFactor
1.0                     uNeuFactor
1.E-2                   RhoNeuFactor for Ne2
0.2                     uNeuFactor for Ne2

Read in density and velocity factors for each neutral fluid. These
factors are used to set the boundary conditions for the neutral fluids
in the outer heliosphere component. If the flow points outward from
the domain, the boundary condition is floating. If it points inward,
the density, pressure and velocity are set as RhoNeuFactor*Rho1,
RhoNeuFactor*P1 and uNeuFactor*u1, where Rho1, p1, u1 are the density,
pressure and velocity of the first fluid.

Default is UseOhNeutralBc false.
</command>

<command name="OHNEUTRALS">
  <parameter name="RhoNeutralsISW" type="real" min="0"/>
  <parameter name="TNeutralsISW"   type="real" min="0"/>
  <parameter name="UxNeutralsISW"  type="real"/>
  <parameter name="UyNeutralsISW"  type="real"/>
  <parameter name="UzNeutralsISW"  type="real"/>
  <parameter name="mNeutral"       type="real" min="0" default="1"/>

#OHNEUTRALS
0.18                    RhoNeutralsISW [amu/cc]
6519.0                  TNeutralsISW   [K]
26.3                    UxNeutralsISW  [km/s]
0.3                     UyNeutralsISW  [km/s]
-2.3                    UzNeutralsISW  [km/s]
1.0                     mNeutral       [amu]

Upstream boundary conditions for the neutrals in outer heliosphere component.
The density, temperature and velocity components are given by the first five
parameters. The mNeutral parameter defines the mass of the neutrals in
proton mass. There are no default values, so this command is required for the OH
component.
</command>

</commandgroup>

<commandgroup name="GRID GEOMETRY">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!! GRID GEOMETRY !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

<command name="GRIDBLOCK" alias="GRIDBLOCKALL" if="$_IsFirstSession">
  <parameter name="MaxBlock" type="integer" min="1" default="10"/>

#GRIDBLOCK
100		MaxBlock (per processor)

#GRIDBLOCKALL
4000            MaxBlock (for the whole simulation)

This command can be and should be used in the first session of BATSRUS. For a restarted
run, the #CHECKGRIDSIZE command in the restart header file also sets MaxBlock, 
but that can and should be overwritten if the grid is expected to change due to an AMR.

Set the maximum number of grid blocks either per processor (#GRIDBLOCK) 
or in total for the whole simulation (#GRIDBLOCKALL). 
Typically it is better to set the total number so the code can run on arbitrary 
number of CPUs. It is a good idea to set these values to be 
larger than but close to the actual number of blocks
used during the run to minimize memory use and improve performance.

The default value is 10 blocks per processor, but it is not recommended to rely on
the default setting.
</command>

<command name="GRIDBLOCKIMPL" alias="GRIDBLOCKIMPLALL">
  <parameter name="MaxBlockImpl" type="integer" min="-1" default="-1"/>

#GRIDBLOCKIMPL
100		MaxBlockImpl per processor

#GRIDBLOCKIMPLALL
1000            MaxBlockImpl on all processors

This command can be used when or before the part implicit scheme is switched on.

Set the maximum number of grid blocks advanced by the part-implicit method 
(see #IMPLICIT) either per processor (#MAXBLOCKIMPL) or in total 
(#MAXBLOCKIMPLALL). Note that MaxBlockImpl cannot be more than MaxBlock,
but it can be smaller to save memory. 

The default is that all blocks are implicit if the part-implicit scheme is used.
</command>

<command name="GRID" required="$_IsFirstSession" if="$_IsFirstSession">
  <parameter name="nRootBlock1" type="integer" min="1"  default="2" />
  <parameter name="nRootBlock2" type="integer" min="1"  default="1" />
  <parameter name="nRootBlock3" type="integer" min="1"  default="1" />
  <parameter name="xMin"   type="real"                  default="-192.0" />
  <parameter name="xMax"   type="real" min="$xMin"      default="  64.0" />
  <parameter name="yMin"   type="real"                  default=" -64.0" />
  <parameter name="yMax"   type="real" min="$yMin"      default="  64.0" />
  <parameter name="zMin"   type="real"                  default=" -64.0" />
  <parameter name="zMax"   type="real" min="$zMin"      default="  64.0" />

#GRID
2                       nRootBlock1
1                       nRootBlock2
1                       nRootBlock3
-224.                   xMin
 32.                    xMax
-64.                    yMin
 64.                    yMax
-64.                    zMin
 64.                    zMax

The nRootBlock1, nRootBlock2 and nRootBlock3 parameters define the
number of blocks of the base grid, i.e. the roots of the octree.
By varying these parameters, one can setup a grid which is elongated
in some direction. The xMin, ..., zMax parameters define a brick shaped
computational domain. An inner boundary may be cut out from the domain
with the #BODY and/or #LIMITRADIUS commands. It is also possible to define
a spherical, cylindrical computational domain using
the #GRIDGEOMETRY and the #LIMITRADIUS commands.

There are no default values, the grid size must always be given in the
first session (even if the component is switched off in the first session!).
</command>

<command name="GRIDSYMMETRY">
  <parameter name="IsMirrorX" type="logical" default="F"/>
  <parameter name="IsMirrorY" type="logical" default="F"/>
  <parameter name="IsMirrorZ" type="logical" default="F"/>

#GRIDSYMMETRY
F			IsMirrorX
T			IsMirrorY
T			IsMirrorZ

For symmetric test problems one can model only a part of the computational
domain. Providing the symmetry directions with this command allows
the proper calculation of line-of-sight plots.
</command>

<command name="COORDSYSTEM" alias="COORDINATESYSTEM" multiple="T" >
  <parameter name="TypeCoordSystem" type="string" input="select" case="upper">
    <option name="GSM" default="$NameComp eq 'GM'"/>
    <option name="GSE"                            />
    <option name="HGR" default="$NameComp eq 'SC'"/>
    <option name="HGI" default="$NameComp eq 'IH'"/>
    <option name="HGI" default="$NameComp eq 'OH'"/>
    <option name="HGC" 		                  />
  </parameter>

#COORDSYSTEM
GSM			TypeCoordSystem

TypeCoordSystem defines the coordinate system for the component.
The coordinate systems are defined in share/Library/src/CON_axes.
Here we provide general suggestions.

For GM (Global Magnetopshere) the default coordinate system is "GSM"
with the X axis pointing towards the Sun, and the (moving)
magnetic axis contained in the X-Z plane. The inertial forces are
neglected. The essentially inertial "GSE" system is also available,
but it is not fully tested.

For SC (Solar Corona) one should always use the corotating HGR system to get
an accurate solution even for complicated active regions.
Using an inertial frame would result in huge numerical errors near the Sun.

For time accurate IH solutions (e.g. CME propagation)
one should use the inertial HGI system so the grid can be refined
along the Sun-Earth line.
To obtain a steady state initial condition, the corotating HGC system
can be used which is aligned with the HGI system for the initial time
of the simuation (see #STARTTIME command). When the
run is switched to time accurate mode, the coordinate system should be
switched to HGI. The necessary transformation of the velocity
(adding the corotating velocity) is automatically performed.

For quiet steady state IH solutions the HGR system can be used.
Note however that the corotating systems may not work well if the IH
domain is extended way beyond 1AU, becasue the boundary
condition can become inflow type at the corners of a Cartesian domain.
In this case the inertial HGI system should be used in time accurate mode
even for obtaining the initial state.

For OH one should always use the inertial HGI system. A rotating frame
would have extremeley fast rotational speeds.

Note that the HGR and HGI systems can be rotated with a fixed angle
using the #ROTATEHGR and #ROTATEHGI commands. This can be used to
align the interesting plane of the simulation with the grid.

The default is component dependent:
"GSM" for GM, "HGR" for SC, and "HGI" for IH and OH.
</command>

<command name="ROTATEHGR"  if="$_IsFirstSession and $_IsStandAlone">
  <parameter name="dLongitudeHgr" type="real" min="-360" max="360"
	     default="0"/>
#ROTATEHGR
145.6			dLongitudeHgr [deg]

Rotate the HGR system by dLongitudeHgr degrees around the Z axis.
A negative value is interpreted as an offset angle which moves the
planet into the -X, Z plane (so roughly towards the -X axis).
Default value is 0, i.e. the true HGR system is used.
</command>

<command name="ROTATEHGI" if="$_IsFirstSession and $_IsStandAlone">
  <parameter name="dLongitudeHgi" type="real" min="-360" max="360"
	     default="0"/>
#ROTATEHGI
-1.0			dLongitudeHgi [deg]

Rotate the HGI and the related rotating HGC systems by
dLongitudeHgi degrees around the Z axis.
A negative value is interpreted as an offset angle which moves the
planet into the -X, Z plane (so roughly towards the -X axis).
Default value is 0, i.e. the true HGI system is used.
</command>

<command name="GRIDGEOMETRY" if="$_IsFirstSession">
  <parameter name="TypeGeometry" type="string" input="select">
    <option name="cartesian" default="T" />
    <option name="rotatedcartesian"      />
    <option name="rz"                    />
    <option name="cylindrical"		 />
    <option name="cylindrical_lnr"	 />
    <option name="cylindrical_genr"	 />
    <option name="spherical"		 />
    <option name="spherical_lnr"	 />
    <option name="spherical_genr"	 />
    <option name="roundcube"		 />
  </parameter>
  <if expr="$TypeGeometry=~/roundcube/">
    <parameter name="rRound0" type="real" min="0"/>
    <parameter name="rRound1" type="real" min="0"/>
  </if>
  <if expr="$TypeGeometry =~ /_genr/">
    <parameter name="NameGridFile" type="string"/>
    <rule expr="-f $NameGridFile">
      Grid file $NameGridFile must exist
    </rule>
  </if>

#GRIDGEOMETRY
spherical_genr			TypeGeometry
Param/CORONA/grid_TR.dat	NameGridFile (read if TypeGeometry is _genr)

#GRIDGEOMETRY
roundcube			TypeGeometry
200.0				rRound0  ! only read for roundcube geometry
320.0				rRound1  ! only read for roundcube geometry

Note: The #LIMITRADIUS command can be used to set the radial extent of the
cylindrical, spherical and roundcube grids. The #GRIDGEOMETRYLIMIT
command provides even more control.

This command determines the geometry of the grid. Possible values are
Cartesian, rotated Cartesian, RZ geometry, cylindrical, spherical and
roundcube.
The cylindrical and spherical grids can have logarithmic
(cylindrical_lnr and spherical_lnr) or arbitrarily stretched
(spherical_genr, cylindrical_genr) radial coordinates.
For the latter case the radial stretching is read from the
NameGridFile file. The roundcube geometry is a radially stretched
Cartesian grid. The stretching is controlled by the rRound0
and rRound1 parameters.

The "RZ" geometry is a 2D grid with axial symmetry.
In our particular implementation the "X" axis is the axis of symmetry,
and the "Y" axis is used for the radial direction.

The spherical coordinates are ordered as r, longitude, latitude. The longitude
is between 0 and 360 degrees, the latitude is between -90 and 90 degrees. The
cylindrical coordinates are r, phi, z with phi between 0 and 360 degrees.

The roundcube grid can be used to make the inner or outer boundary
spherical without a singularity. It works in 2D and 3D. The rRound0
parameter indicates the distance where no stretching is applied,
so the grid is Cartesian. The rRound1 parameter indicates the distance
along X, Y and Z on the original grid where full stretching is applied,
so the grid becomes round and the grid
cells will lie on a circle in 2D, or a spherical surface in 3D.
When rRound0 is less than rRound1, the grid is Cartesian up to rRound0.
Outside rRound0 the grid is stretched outward so that it becomes perfectly
round at a radius of rRound1*sqrt(2) in 2D and rRound1*sqrt(3) in 3D,
and it remains round all the way to the outer boundary. 
For this case the transformation does not affect the
main diagonals and the maximum stretching is applied along the main axes.
To reach the perfectly round shape at the outer boundary, the
xMin ... zMax parameters of the #GRID command should be equal or larger
than sqrt(nDim)*rRound1.
If rRound0 is larger than rRound1 then the grid is
contracted inwards. At the origin there is no distortion. Moving outward
the distortion is increased so that at rRound1 the grid becomes round.
From rRound1 to rRound0 the grid becomes Cartesian again. This can
be useful to create a sphere shaped inner boundary without any
singularities. For this case the grid is not contracted along the main axes
and it is maximally contracted along the diagonals.

The rotated Cartesian geometry can be used for debugging the generalized
coordinate code. It allows setting up a Cartesian test on a rotated
generalized coordinate grid. The rotation is around the Z axis
with an angle alpha that has sin(alpha)=0.6 and cos(alpha)=0.8 for sake
of getting nice rational numbers. The PostIDL code unrotates the grid
and the vector variables so it can be directly compared with
a Cartesian simulation. The initial conditions and the boundary conditions,
however, are not rotated automatically (yet), so they require some attention.
Note that only the first order schemes (see #SCHEME) will produce identical
results on rotated and non-rotated grids because nonlinear limiters produce
different face values for the vector components.

The default is Cartesian geometry.
</command>

<command name="GRIDGEOMETRYLIMIT" if="$_IsFirstSession">
  <parameter name="TypeGeometry" type="string" input="select">
    <option name="cartesian" default="T" />
    <option name="rotatedcartesian"      />
    <option name="rz"                    />
    <option name="cylindrical"		 />
    <option name="cylindrical_lnr"	 />
    <option name="cylindrical_genr"	 />
    <option name="spherical"		 />
    <option name="spherical_lnr"	 />
    <option name="spherical_genr"	 />
    <option name="roundcube"		 />
  </parameter>
  <if expr="$TypeGeometry=~/roundcube/">
    <parameter name="rRound0" type="real" min="0"/>
    <parameter name="rRound1" type="real" min="0"/>
  </if>
  <if expr="$TypeGeometry =~ /_genr/">
    <parameter name="NameGridFile" type="string"/>
    <rule expr="-f $NameGridFile">
      Grid file $NameGridFile must exist
    </rule>
  </if>
  <parameter name="Coord1Min" type="real"                  />
  <parameter name="Coord1Max" type="real" min="$Coord1Min" />
  <parameter name="Coord2Min" type="real"                  />
  <parameter name="Coord2Max" type="real" min="$Coord2Min" />
  <parameter name="Coord3Min" type="real"                  />
  <parameter name="Coord3Max" type="real" min="$Coord3Min" />
#GRIDGEOMETRYLIMIT
spherical			TypeGeometry
1.0				Coord1Min Radius
24.0				Coord1Max
0.0				Coord2Min Longitude
360.0				Coord2Max
-90.0				Coord3Min Latitude
90.0				Coord3Max

The #GRIDGEOMETRYLIMIT command is similar to the #GRIDGEOMETRY command, but
provides in addition the flexibility to change the limits of the
generalized coordinates. This allows to construct grids such as a spherical
or cylindrical wedge. The radial limits are given in true radius
even if the radial coordinate is logarithmic or stretched.
For spherical and cylindrical grids the angle limits
are provided in degrees.

Default is Cartesian grid.
</command>

<command name="LIMITRADIUS" if="$_IsFirstSession">
  <parameter name="rMin" type="real" default="0"/>
  <parameter name="rMax" type="real" min="$rMin" default="1000"/>
#LIMITRADIUS
 10.0			rMin
100.0			rMax

Note: the #GRIDGEOMETRYLIMIT command provides even more control.

This command allows setting the mimimum and maximum radial extent of
the grid. Setting rMin to a positive value excludes the origin of
a spherical grid, or the axis of the cylindrical grid.

The rMax parameter can be used to choose a spherical or cylinrical domain
instead of the brick defined by the #GRID. To achieve this, rMax has to be
set to a radius that fits inside the brick defined by #GRID.

By default the inner radius is set to the radius of the inner body
if it is present (see the #BODY command) and the outer radius is set
to the largest radial distance of the eight corners of the domain defined
by the #GRID command. If there is no inner body, the default inner radius
is set to 0.0 for regular spherical and cylindrical grids,
and to 1.0 for logarithmic and stretched radius grids.
</command>

<command name="UNIFORMAXIS" if="$_IsFirstSession">
  <parameter name="UseUniformAxis" type="logical" default="T"/>

#UNIFORMAXIS
T			UseUniformAxis

This command can only be used in the first session.
If UseUniformAxis is true, there can be no resolution change AROUND the
axis of a spherical or cylindrical grid. This is required by the supercell
algorithm that can be activated by the #FIXAXIS command. Note that there can
still be resolution changes ALONG the axis.

If UseUniformAxis is false, the AMR can produce resolution changes around
the axis of the grid. The super-cell algorithm cannot be used.
For restarted runs the false setting has to be repeated in the PARAM.in file
used for the restart.

The default is UseUniformAxis=T.
</command>

<command name="FIXAXIS">
  <parameter name="DoFixAxis" type="logical"                      default="F"/>
  <parameter name="rFixAxis"  type="real" min="0"                 default="0"/>
  <parameter name="r2FixAxis" type="real" min="0" max="$rFixAxis" default="0"/>
#FIXAXIS
T			DoFixAxis
5.0			rFixAxis
1.5			r2FixAxis

The computational cells become very small near the symmetry axis
of a spherical or cylindrical grid.

When DoFixAxis is true, the cells around the pole are merged into one
'supercell' for the blocks that are (partially) inside radius rFixAxis.
For blocks within r2FixAxis, the radius of the supercell is 2 normal
cells. Merging the small cells allows larger time steps in time accurate runs:
about a factor of 2 if only rFixAxis is used, and around factor of 3
if r2FixAxis is also used.

Note that the super-cell algorithm requires that there is no
resolution change around the axis in the phi direction. See
the #UNIFORMAXIS command for more discussion.

Default is false for DoFixAxis.
</command>

<command name="COARSEAXIS">
  <parameter name="UseCoarseAxis" type="logical" default="F"/>
  <parameter name="nCoarseLayer"  type="integer" min="1" default="3"/>

#COARSEAXIS
T			UseCoarseAxis
3			nCoarseLayer

The computational cells become very small near the symmetry axis
of a spherical or grid.

When UseCoarseAxis is true, the cells around the pole are merged into pairs, if
nCoarseLayer=1. If nCoarseLayer=2, then around the pole each 4 cells are merged
and in the second (from the pole) layer each 2 cells are merged. To achieve this,
nJ size parameter of the spherical gird should be a multiple of 4. If
nCoarseLayer=3, then around the pole each 8 cells are merged,
in the second (from the pole) layer each 4 cells are merged, and in the third
(from the pole) layer each 2 cells are merged. To achieve this,
nJ size parameter of the spherical gird should be a multiple of 8.

Default is false for UseCoarseAxis.
</command>

</commandgroup>

<commandgroup name="INITIAL TIME">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!! INITIAL TIME AND STEP !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="STARTTIME" if="$_IsFirstSession" multiple="T">
  <parameter name="iYear"  type="integer" default="2000" />
  <parameter name="iMonth" type="integer" min="1" max="12" default="3"/>
  <parameter name="iDay"   type="integer" min="1" max="31" default="21"/>
  <parameter name="iHour"   type="integer" min="0" max="23" default="0"/>
  <parameter name="iMinute" type="integer" min="0" max="59" default="0"/>
  <parameter name="iSecond" type="integer" min="0" max="59" default="0"/>
#STARTTIME
2000                    iYear
3                       iMonth
21                      iDay
10                      iHour
45                      iMinute
0                       iSecond

The #STARTTIME command sets the initial date and time for the
simulation in Universal Time (UT) in stand alone mode.
This time is stored in the BATSRUS restart header file.
It can be overwritten with a subsequent #STARTTIME comand if necessary.

In the SWMF this command checks BATSRUS start time against the SWMF start time
and warns if the difference exceeds 1 millisecond.

The default values are shown above.
This is a date and time when both the rotational and the magnetic axes
have approximately zero tilt towards the Sun.
</command>

<command name="TIMESIMULATION" if="$_IsFirstSession" multiple="T">
  <parameter name="tSimulation" type="real" min="0" default="0.0" />

#TIMESIMULATION
1 hour			tSimulation [sec]

The tSimulation variable contains the simulation time in seconds
relative to the initial time set by the #STARTTIME command.
The #TIMESIMULATION command and tSimulation are saved into the restart
header file, so the simulation can be continued from the same time. 
This value can be overwritten by a subsequent #TIMESIMULATION command 
if necessary.

In SWMF the BATSRUS time is checked against the global SWMF simulation time.

The default value is tSimulation=0.
</command>

<command name="NSTEP" if="$_IsFirstSession" multiple="T">
  <parameter name="nStep" type="integer" min="0" default="0" />

#NSTEP
100			nStep

Set nStep for the component. Typically used in the restart.H header file.
Generally it is not inserted in a PARAM.in file by the user, except
when the number of steps are reset for extremely long runs, such as
the operational run at NOAA SWPC, to avoid integer overflow.

The default is nStep=0 as the starting time step with no restart.
</command>

<command name="NPREVIOUS" if="$_IsFirstSession">
  <parameter name="nPrevious" type="integer" min="-1" default="-1" />

#NPREVIOUS
100			nPrev
1.5			DtPrev

This command should only occur in the restart.H header file.
If it is present, it indicates that the restart file contains
the state variables for the previous time step.
nPrev is the time step number and DtPrev is the length of the previous
time step in seconds.
The previous time step is needed for a second order in time restart
with the implicit scheme.

The default is that the command is not present and no previous time step
is saved into the restart files.
</command>
</commandgroup>
<commandgroup name="TIME INTEGRATION">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!  TIME INTEGRATION PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="TIMESTEPPING" alias="RUNGEKUTTA,RK">
  <parameter name="nStage" type="integer" min="1" max="4" default="2" />
  <parameter name="CflExpl" type="real" min="0" max="1" default="0.8" />

#TIMESTEPPING
1                       nStage
0.4                     CflExpl

#RUNGEKUTTA
2			nStage
0.8			CflExpl

#RK
4			nStage
1.3			CflExpl

These commands set the parameters for time integration.
For explicit time integration nStage is the number of stages.
Setting nStage=1 selects a temporally first order forward Euler scheme.
The nStage=2 corresponds to a temporally second order scheme.
The #TIMESTEPPING command uses half time step for the first stage,
and full time step for the second stage. The #RUNGEKUTTA or #RK commands
select a TVD Runge-Kutta scheme that employs full time step in both stages
and then takes their average.
The nStage=3 selects a 3rd order TVD Runge-Kutta scheme.
The nStage=4 selects the classical 4th order Runge-Kutta scheme.
These temporally high order options are useful in combination with
spatially higher order schemes (to be implemented).

For implicit time stepping nStage=2 corresponds to the BDF2 (Backward Differene
Formula 2) scheme that uses the previous time step to make the scheme
2nd order accurate in time.

For explicit time stepping the CPU time is proportional to the number of
stages. In time accurate runs the 1-stage explicit time stepping scheme
may work reasonably well with second order spatial discretization,
especially if the time step is limited to a very small value.
Using a one stage scheme can speed up the code by a factor of two with
little compromise in accuracy.

For local time stepping (steady state mode) one should always use the
2-stage scheme with 2-nd order spatial accuracy to avoid oscillations
(or use the 1-stage scheme with CflExpl=0.4).

For implicit scheme the second order BDF2 scheme is more accurate
but not more expensive than the first order backward Euler scheme,
so it is a good idea to use nStage=nOrder (or at least nStage=3 for
high order schemes).

To achieve consistency between the spatial and temporal orders of accuracy,
the #SCHEME command always sets nStage to be the same as nOrder
except for 5th order scheme, which sets nStage=3.
The #TIMESTEPPING (or #RUNGEKUTTA or #RK) command can be used AFTER the
#SCHEME command to overwrite nStage if required.

If the #SCHEME command is not used, then the defaults are
nStage=2 with the half-step predictor and CflExpl=0.8.
</command>

<command name="USEFLIC">
  <parameter name="UseFlic" type="logical" default="F" />

#USEFLIC
T                       UseFlic

MHD scheme which works similarly to the hybrid one and can work together
with hybrid. Requires nStage=3.
</command>

<command name="PARTLOCALTIMESTEP">
  <parameter name="rLocalTimeStep" type="real" default="-1.0"/>

#PARTLOCALTIMESTEP
1.1                     rLocalTimeStep  

Use local time stepping inside radial distance rLocalTimeStep and
time accurate mode in the rest of the domain. The global time step Dt
is only limited by the cells outside rLocalTimeStep. Inside rLocalTimeStep
each cell advances with the smaller of Dt and the locally stable time step.
This method can speed up the calculation when near the inner boundary the
solution is quasi-steady state.

Default value is rLocalTimeStep=-1, so the scheme is not used.
</command>

<command name="TIMESTEPLIMIT">
  <parameter name="UseDtLimit" type="logical"      default="F" />
  <parameter name="DtLimitDim" type="real" min="0" default="1.0"
	     if="$UseDtLimit" />
#TIMESTEPLIMIT
T                       UseDtLimit
10.                     DtLimitDim [sec] (read if UseDtLimit is true)

If UseDtLimit is true, the local time step is limited to DtLimitDim in
either steady state mode or time accurate mode. The only difference
between running in steady state and time accurate is that the simulation
time does not evolve in steady state mode.

Limiting the local time step in steady state mode can be useful to
reach steady state with less violent transients.

For time accurate simulations this feature can be useful when in some
stiff regions the local stable time step is very small, but the solution is
in a quasi-steady state. If this is true, selecting a suitable value
for DtLimitDim will evolve the solution in time accurate mode in the
region where the stable time step is larger than DtLimitDim*Cfl,
and it will iterate with the local time step in the stiff region.
As long as the quasi-steady state can follow the time evolution with
the local time step, the overall solution will be correct.

The limited time step approach is different from the part steady scheme
(see #PARTSTEADY), which assumes a near perfect steady state in parts of the
domain where the solution is not evolved at all.
If the stiff region cannot keep up with the time evolution,
then subcycling (see #LOCALTIMESTEP) or implicit time stepping
(see #IMPLICIT) is needed.

The default is UseDtLimit false.
</command>

<command name="FIXEDTIMESTEP">
  <parameter name="UseDtFixed" type="logical"      default="F" />
  <parameter name="DtFixedDim" type="real" min="0" default="1.0"
	     if="$UseDtFixed" />
#FIXEDTIMESTEP
T                       UseDtFixed
10.                     DtFixedDim [sec] (read if UseDtFixed is true)

The fixed time step is typically used with the implicit and partially
implicit schemes in time accurate mode. The time step is set to DtFixedDim
unless the time step control algorithm (see #TIMESTEPCONTROL or #UPDATECHECK)
reduces the time step for the sake of robustness.

The fixed time step can also be used with explicit time stepping in time
accurate mode for debugging as well as for convergence tests.

The fixed time step can not be used in steady state mode. See #TIMESTEPLIMIT
if the purpose is to make transients smaller or solve part of the domain
in time accurate mode.

The default is UseDtFixed false.
</command>

<command name="PARTSTEADY">
  <parameter name="UsePartSteady" type="logical" default="F" />

#PARTSTEADY
T			UsePartSteady

If UsePartSteady is true, the partially steady state algorithm is used.
Only blocks which are changing or next to changing blocks are evolved.
This scheme can speed up the calculation if part
of the domain is in a numerical steady state.
In steady state runs the code stops when a full steady state is
achieved. The conditions for checking the numerical steady state are set
by the #PARTSTEADYCRITERIA command.

See also the #LOCALTIMESTEP and #TIMESTEPLIMIT commands for related
approaches.

Default value is UsePartSteady = .false.
</command>

<command name="PARTSTEADYCRITERIA" alias="STEADYCRITERIA">
  <parameter name="MinCheckVar" type="integer" min="1"            default="1"/>
  <parameter name="MaxCheckVar" type="integer" min="$MinCheckVar" default="8"/>
  <for from="$MinCheckVar" to="$MaxCheckVar">
    <parameter name="RelativeEps" type="real" min="0" max="1" default="0.001"/>
    <parameter name="AbsoluteEps" type="real" min="0"	     default="0.0001"/>
  </for>
#PARTSTEADYCRITERIA
5               MinCheckVar
8               MaxCheckVar
0.001           RelativeEps(bx)
0.0001          AbsoluteEps(bx)
0.001           RelativeEps(by)
0.0001          AbsoluteEps(by)
0.001           RelativeEps(bz)
0.0001          AbsoluteEps(bz)
0.001           RelativeEps(p)
0.0001          AbsoluteEps(p)

The part steady scheme only evolves blocks which are changing,
or neighbors of changing blocks. The scheme checks the neighbor blocks
every time step if their state variable has changed significantly.
This command allows the user to select the variables to be checked,
and to set the relative and absolute limits for each variable.
Only the state variables indexed from MinCheckVar to MaxCheckVar are checked.
The change in the block is significant if
\begin{verbatim}
max(abs(State - StateOld)) / (RelativeEps*abs(State) + AbsoluteEps)
\end{verbatim}
exceeds 1.0 for any of the checked variables in any cells of the block.
(including body cells but excluding ghost cells).
The RelativeEps variable determines the maximum ratio of the change
and the norm of the old state. The AbsoluteEps variable is only needed
if the old state is very close to zero. It should be set to a positive
value which is much smaller than the typical significantly non-zero
value of the variable.

Default values are such that all variables are checked with
relative error 0.001 and absolute error 0.0001.
</command>

<command name="POINTIMPLICIT">
  <parameter name="UsePointImplicit" type="logical"  default="F"/>
  <if expr="$UsePointImplicit">
    <parameter name="BetaPointImplicit" type="real"  default="0.5"
	       min="0.5" max="1" />
    <parameter name="IsAsymmetric" type="logical"    default="T"/>
    <parameter name="DoNormalizeCell" type="logical" default="F"/>
  </if>
#POINTIMPLICIT
T		UsePointImplicit
0.5		BetaPointImplicit (read if UsePointImplicit is true)
T		IsAsymmetric
T		DoNormalizeCell

Switches on or off the point implicit scheme. The BetaPointImplicit
parameter (in the 0.5 to 1.0 range) determines the order of accuracy
for a 2-stage scheme. If BetaPointImplicit=0.5 the point implicit scheme
is second order accurate in time when used in a 2-stage scheme.
Larger values may be more robust, but only first order accurate in time.
For a 1-stage scheme or for local timestepping the BetaPointImplicit
parameter is ignored and the coefficient is set to 1.

If the IsAsymmetric parameter is true, the numerical Jacobian is calculated
with a one-sided (asymmetric) difference formula. Otherwise a two-sided
symmetric difference is used. The latter is slower somewhat but more accurate.

If DoNormalizeCell is true, the normalization of variables (this is needed
to make small perturbations for the calculation of numerical derivatives)
is done cell-by-cell. The default is false, so normalization is done
on a block-by-block basis.

For single-ion MHD the default is UsePointImplicit=.false.
For multi-ion MHD the default values are
UsePointImplicit=.true., BetaPointImplicit=1.0 and IsAsymmetric=.true.
</command>

<command name="IMPLICIT">
  <parameter name="UsePointImplicit" type="logical" default="F"/>
  <parameter name="UsePartImplicit" type="logical" default="F"/>
  <parameter name="UseFullImplicit" type="logical" default="F"/>
  <parameter name="CflImpl" type="real" min="0" default="100"
	     if="$UsePartImplicit or $UseFullImplicit"/>
  <rule expr="not ($UsePartImplicit and $UseFullImplicit)">
    UsePartImplicit and UseFullImplicit cannot be both true!
  </rule>
  <rule expr="not ($UsePointImplicit and $UseFullImplicit)">
    UsePointImplicit and UseFullImplicit cannot be both true!
  </rule>

#IMPLICIT
F               UsePointImplicit
F               UsePartImplicit
T               UseFullImplicit
100.0           CflImpl (read if UsePartImplicit or UseFullImplicit is true)

If UsePointImplicit=T is set, the source terms defined in the user module
are evaluated with a point implicit scheme. See the #POINTIMPLICIT command
for additional parameters (and another way of switching the point implicit
scheme on).

If UsePartImplicit=T is set, the code uses the explicit/implicit scheme.
This means that some of the grid blocks are advanced with explicit
time stepping, while the rest is advance with implicit time stepping.
See the #FIXEDTIMESTEP and #IMPLICITCRITERIA command on how the
explicit and implicit blocks get selected.

If UseFullImplicit=T is set, the code uses a fully implicit time
stepping scheme. This is usually more costly than the explicit/implicit
scheme unless the whole computational domain requires implicit
time stepping.

Note 1: If UseFullImplicit is true, UsePartImplicit and UsePointImplicit
must be false.

Note 2: UsePartImplicit=T and UsePointImplicit=T may be used together:
source terms are point implicit in the explicit blocks.

The ImplCFL parameter determines the CFL number used in the implicit blocks
of the fully or partially implicit schemes. This is ignored if UseDtFixed=T
is set in the #FIXEDTIMESTEP command.

Default is false for all logicals.
</command>

<command name="SEMIIMPLICIT">
  <parameter name="UseSemiImplicit" type="logical" default="F"/>
  <parameter name="TypeSemiImplicit" type="string" input="select"
	     if="$UseSemiImplicit">
    <option name="radiationsplit" default="T"/>
    <option name="radiation"/>
    <option name="radcondsplit"/>
    <option name="radcond"/>
    <option name="parcond"/>
    <option name="cond"/>
    <option name="resistivity"/>
  </parameter>
#SEMIIMPLICIT
T                       UseSemiImplicit
radiation               TypeSemiImplicit (read if UseSemiImplicit is true)

If UseSemiImplicit is true then most of the terms are evaluated explicitly,
but some of them are evaluated implicitly.

The TypeSemiImplicit parameter determines which terms and corresponding
variables are done semi-implicitly.

The "radiation" option solves for the gray or multigroup diffusion
energy density. For gray diffusion the internal energy and pressure is
calculated in a point implicit manner.
To use gray diffusion configure BATSRUS with Config.pl -nWave=1.
To use the multi-group radiation set nWave larger than one.

The "radiationsplit" option solves each radiation group separately.
The energy exchange term is calculated point-implicitly. The
internal energy is updated in a conservative way.

The "radcond" option solves implicitly the radiation diffusion and
electron heat conduction together with the radiation and internal
energy densities being the unknowns.

The "radcondsplit" option solves each radiation group and the
electrons heat conduction separately.

The "parcond" option solves for field aligned electron heat conduction only.

The "cond" option solves for electron heat conduction only.

The "resistivity" option solves for the magnetic field with dissipative
and/or Hall resistivity. The "resist" option does NOT solve Hall term
with semi-implicit. The "resisthall" option does NOT solve dissipative resistivity.

The default is UseSemiImplicit false.
</command>
</commandgroup>

<commandgroup name="IMPLICIT PARAMETERS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!! PARAMETERS FOR FULL AND PART IMPLICIT TIME INTEGRATION !!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="IMPLICITENERGY" alias="IMPLENERGY">
	<parameter name="UseImplicitEnergy" type="logical" default="T" />

#IMPLICITENERGY
F			UseImplicitEnergy

If UseImplicitEnergy is true, use the energy variable(s) as unknown(s) in the
implicit scheme, otherwise use the pressure variables(s). Note that the
explicit scheme that provides the right hand side of the implicit scheme
may still be conservative, and thus the overall scheme can provide
correct jump conditions across standing (or slowly moving) shocks.
Away from shocks, using pressure as an implicit variable provides a more
accurate and robust scheme than using the energy variable.

The default is UseImplicitEnergy=T for sake of backwards compatibility.
</command>

<command name="IMPLICITCRITERIA" alias="STEPPINGCRITERIA">
  <parameter name="TypeImplCrit" type="string" case="lower"
	     input="select">
    <option name="Time step"	value="dt" default="T"	/>
    <option name="Radial distance"	value="r"	/>
    <option name="Test block"	value="test"		/>
  </parameter>
  <parameter name="rImplicit" type="real" min="0"
	     if="$TypeImplCrit eq 'r'" />

#IMPLICITCRITERIA
r		TypeImplCrit (dt or r or test)
10.0		rImplicit    (only read for TypeImplCrit = r)

Both #IMPLICITCRITERIA and #STEPPINGCRITERIA are acceptable.
Only effective if PartImplicit is true in a time accurate run.
Default value is ImplCritType='dt'.

The options are
\begin{verbatim}
if     (TypeImplCrit =='dt'  ) then blocks with DtBLK .lt. DtFixed
elseif (TypeImplCrit =='r'   ) then blocks with rMinBLK .lt. rImplicit
elseif (TypeImplCrit =='test') then block iBlockTest on processor iProcTest
\end{verbatim}
are handled with the implicit scheme. Here DtBlock is the time step
allowed by the CFL condition for a given block, while rMinBLK is the
smallest radial distance for all the cells in the block.\\

\noindent
The iBlockTest and iProcTest can be defined in the #TESTIJK command.\\
DtFixed must be defined in the #FIXEDTIMESTEP command.
</command>

<command name="PARTIMPL" alias="PARTIMPLICIT">
  <parameter name="UsePartImplicit2" type="logical" default="F" />

#PARTIMPLICIT
T		UsePartImplicit2

If UsePartImplicit2 is set to true, the explicit scheme is executed in all
blocks before the implicit scheme is applied in the implicit blocks. This way
the fluxes at the explicit/implicit interface are second order accurate,
and the overall part implicit scheme will be fully second order in time.
When this switch is false, the explicit/implicit interface fluxes are only
first order accurate in time.
A potential drawback of the second order scheme is that the explicit scheme
may crash in the implicit blocks. This could be avoided with a more
sophisticated implementation. There may also be a slight speed penalty,
because the explicit scheme is applied in more blocks.

The default is UsePartImplicit2 = false for now, which is safe and
backward compatible.
</command>

<command name="IMPLSTEP" alias="IMPLICITSTEP">
  <parameter name="ImplCoeff" type="real" min="0" max="1" default="1"/>
  <parameter name="UseBdf2"   type="logical"              default="T" />
  <parameter name="UseSourceImpl" type="logical"          default="F" />

#IMPLSTEP
0.5			ImplCoeff
F			UseBdf2
F			UseSourceImpl

The ImplCoeff is the beta coefficient in front of the implicit terms
for the two-level implicit scheme.
The UseBdf2 parameter decides if the 3 level BDF2 scheme is used or
a 2 level scheme.
UseSourceImpl true means that the preconditioner should take point
source terms into account.

For steady state run the default is the backward Euler scheme, which
corresponds to ImplCoeff=1.0 and UsedBdf2=F.
For second order time accurate run the default is UseBdf2=T, since
BDF2 is a 3 level second order in time and stable implicit scheme.
In both cases the default value for UseSourceImpl is false.

The default values can be overwritten with #IMPLSTEP, but only
after the #TIMESTEPPING command!
For example one could use the 2-level trapezoid scheme with
ImplCoeff=0.5 and UseBDF2=F as shown in the example above.
The BDF2 scheme determines the coefficient for the implicit terms itself,
but ImplCoeff is still used in the first time step and after AMR-s, when
the code switches back to the two-level scheme for one time step.
</command>

<command name="SEMICOEFF" alias="SEMIIMPLCOEFF,SEMIIMPLICITCOEFF">
  <parameter name="SemiImplCoeff" type="real" min="0.5" max="1" default="1"/>

#SEMICOEFF
0.5			SemiImplCoeff

The SemiImplCoeff is the coefficient in front of the implicit part of the
semi-implicit terms. The value should be in the range 0.5 to 1.
The 0.5 value will make the semi-implicit term 2nd order accurate in time,
but currently the operator splitting still renders the full scheme first
order in time only. Using 1.0 is the most robust option, as it makes the
semi-implicit term to be evaluated fully implicitly, but it is first order
accurate in time only. The default value is 1.
</command>

<command name="IMPLSCHEME" alias="IMPLICITSCHEME">
  <parameter name="nOrderImpl" type="integer" min="1" max="2" default="1"/>
  <parameter name="TypeFluxImpl" type="string" case="upper" input="select">
    <option name="Rusanov" value="RUSANOV" default="T" />
    <option name="Linde"   value="LINDE"               />
    <option name="Sokolov" value="SOKOLOV"             />
    <option name="LFDW"                                />
    <option name="HLLDW"                               />
    <option name="HLLD"                                />
    <option name="Roe"     value="ROE"                 />
    <option name="RoeOld"  value="ROEOLD"              />
    <option name="Godunov" value="GODUNOV"             />
  </parameter>
#IMPLSCHEME
1               nOrderImpl
Rusanov         TypeFluxImpl

This command defines the scheme used in the implicit part ('left hand side').
The default order is first order. The default scheme is the same as the
scheme selected for the explicit part.
</command>

<command name="IMPLCHECK" alias="IMPLICITCHECK">
  <parameter name="RejectStepLevel"  type="real"
	     min="0"  max="0.9" default="0.3" />
  <parameter name="RejectStepFactor" type="real"
	     min="0"  max="0.9" default="0.5" />
  <parameter name="ReduceStepLevel"  type="real"
	     min="0"  max="0.9" default="0.6" />
  <parameter name="ReduceStepFactor" type="real"
	     min="0"  max="1"   default="0.9" />
  <parameter name="IncreaseStepLevel" type="real"
	     min="0"  max="1"   default="0.8" />
  <parameter name="IncreaseStepFactor" type="real"
	     min="1"  max="2"   default="1.05"/>

#IMPLCHECK
0.3		RejectStepLevel
0.5		RejectStepFactor
0.6		ReduceStepLevel
0.95		ReduceStepFactor
0.8		IncreaseStepLevel
1.05		IncreaseStepFactor

The update checking of the implicit scheme can be tuned with this command.
Update checking is done unless it is switched off (see UPDATECHECK command).
After each (partially) implicit time step, the code computes pRhoRelMin,
which is the minimum of the relative pressure and density drops over
the whole computational domain. The algorithm is the following:

If pRhoRelMin is less than RejectStepLevel,
the step is rejected, and the time step is reduced by RejectStepFactor;
else if pRhoRelMin is less than ReduceStepLevel,
the step is accepted, but the next time step is reduced by ReduceStepFactor;
else if pRhoRelMin is greater than IncreaseStepFactor,
the step is accepted and the next time step is increased by IncreaseStepFactor,
but it is never increased above the value given in the FIXEDTIMESTEP command.

Assigning ReduceStepFactor=1.0 means that the
time step is not reduced unless the step is rejected.
Assigning IncreaseStepFactor=1.0 means that the
time step is never increased, only reduced.

Default values are shown.
</command>

<command name="NEWTON">
  <parameter name="UseNewton" type="logical" default="F"/>
  <if expr="$UseNewton">
    <parameter name="UseConservativeImplicit" type="logical" default="F"  />
    <parameter name="MaxIterNewton" type="integer" min="1"   default="10" />
  </if>
#NEWTON
T               UseNewton (rest of parameters read if true)
F		UseConservativeImplicit
10              MaxIterNewton

If UseNewton is true a full non-linear Newton iteration is performed.
If UseConservativeImplicit is true, the Newton iteration is finished
with a conservative fix (back substitution of the solution
into the non-linear implicit equations).
MaxIterNewton is the maximum number of Newton iterations before giving up.

Default is UseNewton=F, i.e. we do a single "Newton" iteration, which
is the linearized implicit scheme. In most cases that is the best choice.
</command>

<command name="JACOBIAN">
  <parameter name="DoPrecond" type="logical" default="T"/>
  <parameter name="JacobianEps" type="real"  default="1E-12"
	     min="0" max="1e-5" />
#JACOBIAN
T               DoPrecond
1E-12           JacobianEps

The Jacobian matrix is always calculated with a matrix free approach,
however it can be preconditioned if DoPrecond is set to true.
JacobianEps contains the machine round off error for numerical derivatives.
The default value is 1.E-12 for 8 byte reals and 1.E-6 for 4 byte reals.

The default values are shown by the example.
</command>

<command name="PRECONDITIONER">
  <parameter name="TypePrecondSide" type="string" input="select">
    <option name="left"			/>
    <option name="symmetric" default="T"	/>
    <option name="right"			/>
  </parameter>
  <parameter name="TypePrecond" type="string" input="select" case="upper">
    <option value="JACOBI"      name="Jacobi"/>
    <option value="BLOCKJACOBI" name="block-Jacobi"/>
    <option value="GS"          name="Gauss-Seidel"/>
    <option name="BILU"                            />
    <option name="MBILU"        default="T"        />
  </parameter>
  <parameter name="PrecondParam" type="real" min="-1" max="1"
	     default="0.5" if="$TypePrecond eq 'MBILU'"/>
#PRECONDITIONER
symmetric       TypePrecondSide (left, symmetric, right)
MBILU           TypePrecond (JACOBI, BLOCKJACOBI, GS, BILU, MBILU)
0.5             GustafssonPar (0 to 1, read for MBILU preconditioner only)

TypePrecondSide can be left, right or symmetric. There seems to be little
difference between these in terms of performance. Right preconditioning
does not affect the normalization of the residual. The JACOBI and BLOCKJACOBI
preconditioners are implemented to always use left preconditioning.

The TypePrecond parameter can be set to JACOBI, GAUSS-SEIDEL,
BLOCKJACOBI, BILU, MBILU.

The simplest Jacobi preconditioner is mainly useful for code
development purposes.  It uses the inverse of the diagonal elements of
the approximate Jacobian matrix.  The block-Jacobi preconditioner uses
the invese of the diagonal blocks of the Jacobian matrix. It coincides
with the Jacobi preconditioner for a scalar equation.  The
Gauss-Seidel (GS) preconditioner gives better performance than Jacobi,
however, the BILU and MBILU preconditioners are usually more
efficient.  The Modified BILU (MBILU) preconditioner allows a
Gustafsson modification relative to BILU. In some cases the
modification improves the preconditioner, but sometimes it makes it
worse.

The GustafssonPar parameter is only read for the MBILU preconditioner.
If it is 0, the standard block (BILU) preconditioning is done.
This seems to be optimal for diffusion+relaxation type problems.
Setting a positive GustafssonPar up to 1 results in the modified (MBILU)
preconditioner. The maximum 1 corresponds to the full Gustafsson modification.
The default 0.5 value seems to be optimal for matrices resulting from
hyperbolic (advection) type problems.

Default parameters are shown by the first example.
</command>

<command name="SEMIPRECONDITIONER" alias="SEMIPRECOND">
  <parameter name="DoPrecond" type="logical" default="T"/>
  <if expr="$DoPrecond">
    <parameter name="TypePrecond" type="string" input="select" case="upper">
      <option name="JACOBI" />
      <option value="BLOCKJACOBI" name="block-Jacobi"/>
      <option value="GS"          name="Gauss-Seidel"/>
      <option name="DILU"  />
      <option name="BILU1" />
      <option name="BILU"  />
      <option name="MBILU" default="T" />
      <option name="HYPRE" />
    </parameter>
    <parameter name="PrecondParam" type="real" min="-1" max="1"
	       default="0.5" if="$TypePrecond eq 'MBILU'"/>
  </if>
#SEMIPRECONDITIONER
T               DoPrecond (rest of parameters are read if true)
MBILU           TypePrecond (MBILU/BILU/BILU1/DILU/GS/BLOCKJACOBI/JACOBI/HYPRE)
0.5             GustafssonPar (0 to 1, read for MBILU preconditioner only)

#SEMIPRECOND
T		DoPrecond
HYPRE		TypePrecond

Similar to the #PRECONDITIONER command but for the semi-implicit scheme.

If DoPrecond is false, no preconditioner is used. This will result in
slower convergence. It is almost always preferable to use a preconditioner.
The semi-implicit scheme always uses left side preconditioning.

The TypePrecond parameter can be set to the following values:
JACOBI, BLOCKJACOBI, GS, DILU, BILU1, BILU, MBILU or HYPRE.
Most of these options are described in some detail for the #PRECONDITIONER
command. BILU1 is same as BILU, but the preconditioner only acts
in the first spatial dimension. This allows parallelization in 2D and 3D,
which is important when running on the GPU. Currently only the scalar
case is implemented (for example heat conduction).

The Diagonal Incomplete Lower-Upper (DILU) preconditioner assumes that the
off-diagonal blocks are diagonal matrices, and it gives the same result
but faster performance than BILU in that case. This assumption
holds if the derivative of a variable in the semi-implicit terms only
affects the same variable (true for heat conduction, radiative diffusion,
dissipative resistivity, but not for Hall resistivity).

The HYPRE preconditioner can only be used if the HYPRE library
has been checked out into the util/ directory and Config.pl -hypre has
been set. The HYPRE preconditioning only works if the semi-implicit
scheme solves for 1 variable at a time (split semi-implicit scheme).

Default values are DoPrecond=T and TypePrecond='BILU'.
</command>

<command name="KRYLOV">
  <parameter name="TypeKrylov" type="string" input="select" case="upper">
    <option name="GMRES"	default="T"	/>
    <option name="BICGSTAB" 		/>
    <option name="CG" 			/>
  </parameter>
  <parameter name="TypeInitKrylov" type="string" input="select">
    <option name="0" 	value="nul" default="T"	/>
    <option name="previous" value="old"		/>
    <option name="explicit"				/>
    <option name="scaled explicit" value="explicit"	/>
  </parameter>
  <parameter name="ErrorMaxKrylov" type="real" min="0" max="0.1"
	     default="0.001" />
  <parameter name="MaxMatvecKrylov" type="integer" min="1"
	     default="100" />
#KRYLOV
GMRES           TypeKrylov  (GMRES, BICGSTAB, CG)
nul             TypeInitKrylov (nul, old, explicit, scaled)
0.001           ErrorMaxKrylov
100             MaxMatvecKrylov

Default values are shown.

The TypeKrylov parameter selects the iterative Krylov solver.
The GMRES solver is the most robust and it converges the fastest
among all Krylov solvers. It uses one matrix-vector product per iteration.
On the other hand it needs to store one copy of the vector of the unknowns
per iteration. GMRES also has to invert an NxN matrix in the N-th iteration.
This means that GMRES is the optimal choice if the
number of iterations is relatively small, typically less than 100.
This is almost always true when the HYPRE preconditioner is used
(see the #PRECONDITIONER command).

BICGSTAB is a robust Krylov scheme that only uses 4 copies of the unknown
vector, and it uses two  matrix-vector products per iteration.
It usually requires somewhat more matrix-vector products than GMRES to
achieve the same accuracy (defined by the tolerance ErrorMaxKrylov).
On the other hand all iterations have the same computational cost.

The preconditioned Conjugate Gradient (CG) scheme only
works for symmetric matrices. It only uses two copies of the unknown vector.
For symmetric matrices it is more efficient than BiCGSTAB.
In case many iterations are needed, it is more efficient than GMRES.
The CG scheme currently does not work together with the HYPRE preconditioner.

Initial guess for the Krylov type iterative scheme
can be 0 ('nul'), the previous solution ('old'), the explicit solution
('explicit'), or the scaled explicit solution ('scaled'). The iterative
scheme stops if the required accuracy is achieved or the maximum number
of matrix-vector multiplications is exceeded.

The ErrorMaxKrylov parameter defines the relative accuracy of the solution.
The iteration stops when the residual (measured in the second norm)
drops below the initial residual times ErrorMaxKrylov.

The MaxMatvecKrylov parameter limits the number of Krylov iterations.
It also defines the maximum number of copies of the unknown vector
for the GMRES solver, although this can be overwritten with the
#KRYLOVSIZE command (see the description for more detail).
If the Krylov solver does not succeed in achieving the desired accuracy
within the maximum number of iterations, an error message is printed.
</command>

<command name="SEMIKRYLOV">
  <parameter name="TypeKrylov" type="string" input="select" case="upper">
    <option name="GMRES"	default="T"	/>
    <option name="BICGSTAB" 		/>
    <option name="CG" 			/>
  </parameter>
  <parameter name="ErrorMaxKrylov" type="real" min="0" max="0.1"
	     default="0.001" />
  <parameter name="MaxMatvecKrylov" type="integer" min="1"
	     default="100" />
#SEMIKRYLOV
GMRES           TypeKrylov  (GMRES, BICGSTAB, CG)
0.001           ErrorMaxKrylov
100             MaxMatvecKrylov

Same as the #KRYLOV command, but for the semi-implicit scheme.
The initial guess is always zero, so there are only 3 parameters.

Default values are shown. For Solar Corona heat conduction, the defaults are

#SEMIKRYLOV
GMRES           TypeKrylov
1e-5            ErrorMaxKrylov
20              MaxMatvecKrylov

</command>

<command name="KRYLOVSIZE">
  <parameter name="nKrylovVector" type="integer" min="1"
	     default="$MaxMatvecKrylov"/>
#KRYLOVSIZE
10		nKrylovVector

The number of Krylov vectors only matters for GMRES (TypeKrylov='gmres').
If GMRES does not converge within nKrylovVector iterations, it needs
a restart, which usually degrades its convergence rate and robustness.
So nKrylovVector should exceed the number of iterations, but
it should not exceed the maximum number of iterations MaxMatvecKrylov.
On the other hand the dynamically allocated memory is also proportional
to nKrylovVector. The default is nKrylovVector=MaxMatvecKrylov (in #KRYLOV)
which can be overwritten by #KRYLOVSIZE after the #KRYLOV command (if any).
</command>

<command name="SEMIKRYLOVSIZE">
  <parameter name="nKrylovVector" type="integer" min="1"
	     default="$MaxMatvecKrylov"/>
#SEMIKRYLOVSIZE
10		nKrylovVector

Same as #KRYLOVSIZE but for the semi-implicit scheme. This command should
be used after the #SEMIKRYLOV command (if present).
</command>

</commandgroup>
<commandgroup name="STOPPING CRITERIA">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!! STOPPING CRITERIA !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

The commands in this group only work in stand alone mode.

<command name="STOP" if="$_IsStandAlone">
  <parameter name="MaxIteration" type="integer" min="-1" default="-1" />
  <parameter name="tSimulationMax" type="real"  min="-1" default="-1" />

#STOP
100			MaxIteration
1 week			tSimulationMax

This command is only used in stand alone mode.

The MaxIteration variable contains the
maximum number of iterations {\it since the beginning of the current run}
(in case of a restart, the time steps done before the restart do not count).
If nIteration reaches this value the session is finished.
The tSimulationMax variable contains the maximum simulation time
relative to the initial time determined by the #STARTTIME command.
If tSimulation reaches this value the session is finished.

Using a negative value for either variables means that the
corresponding condition is  not checked.

Either the #STOP or the #ENDTIME command must be used in every session.
</command>

<command name="ENDTIME" if="$_IsStandAlone">
  <parameter name="iYear"   type="integer" default="2000" />
  <parameter name="iMonth"  type="integer" min="1" max="12" default="3"/>
  <parameter name="iDay"   type="integer" min="1" max="31" default="21"/>
  <parameter name="iHour"   type="integer" min="0" max="23" default="0"/>
  <parameter name="iMinute" type="integer" min="0" max="59" default="0"/>
  <parameter name="iSecond" type="integer" min="0" max="59" default="0"/>

#ENDTIME
2000			iYear
   3			iMonth
  22			iDay
  10			iHour
  45			iMinute
   0			iSecond

This command can only be used in time accurate mode and in the final session.

The #ENDTIME command sets the date and time in Greenwich Mean Time
(GMT) or Universal Time (UT) when the simulation should be ended.
This is an alternative to the #STOP command in the final session.
This time is stored in the final restart file as the start time for
the restarted run, and the tSimulation parameter of the #TIMESIMULATION
and the nStep parameter of the #NSTEP commands are set to zero.
This avoids accumulation of tSimulation or nStep for continuously
restarted runs.

There is no default value.
</command>

<command name="CHECKSTOPFILE" if="$_IsStandAlone">
  <parameter name="DoCheckStopFile" type="logical" default="T" />

#CHECKSTOPFILE
T			DoCheckStopFile

This command is only used in stand alone mode.

If DoCheckStopFile is true then the code checks if the
BATSRUS.STOP file exists in the run directory. This file is deleted at
the beginning of the run, so the user must explicitly create the file
with e.g. the "touch BATSRUS.STOP" UNIX command.
If the file is found in the run directory,
the execution stops in a graceful manner.
Restart files and plot files are saved as required by the
appropriate parameters.

The default is DoCheckStopFile=.true.
</command>

<command name="CPUTIMEMAX" if="$_IsStandAlone">
  <parameter name="CpuTimeMax" type="real" min="-1" default="-1" />

#CPUTIMEMAX
7.5 hours                    CpuTimeMax [sec]

This command is only used in stand alone mode.

The CpuTimeMax variable contains the maximum allowed CPU time (wall clock
time) for the execution of the current run. If the CPU time reaches
this time, the execution stops in a graceful manner.
Restart files and plot files are saved as required by the
appropriate parameters.
This command is very useful when the code is submitted to a batch
queue with a limited wall clock time.

The default value is -1.0, which means that the CPU time is not checked.
To do the check the CpuTimeMax variable has to be set to a positive value.
</command>
</commandgroup>
<commandgroup name="OUTPUT PARAMETERS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!  OUTPUT PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="RESTARTOUTDIR">
  <parameter name="NameRestartOutDir" type="string" length="$lLine"
	     default="GM/restartOUT" />

#RESTARTOUTDIR
GM/restart_n5000	NameRestartOutDir

The NameRestartOutDir variable contains the name of the directory
where restart files are saved relative to the run directory.
The directory should be inside the subdirectory with the name
of the component.

Default value is "GM/restartOUT".
</command>

<command name="RESTARTOUTFILE">
  <parameter name="StringRestartOutFile" type="strings" min="1" max="2">
    <part name="TypeRestartOutFile" type="string" input="select" required="T">
      <option name="separate files/proc" value="proc" default="T" />
      <option name="single data.rst file" value="one"             />
    </part>
    <part name="StringSeries" type="string" input="select" required="F">
      <option name="series"/>
    </part>
  </parameter>

#RESTARTOUTFILE
one series			TypeRestartOutFile

This command determines if the restart information is saved
as direct access files for each processor (proc)
or into a single direct access file containing all blocks (one).

Normally saving restart files overwrites the previous files.
Adding 'series' after the type results in a series of restart files
with names starting as nITERATION_. 

The most reliable format is 'proc'. If there is any issue with the 'one' format
(some machines write empty records into the file), the 'proc' should be used. 

The default value is 'proc'.
</command>

<command name="SAVERESTART">
  <parameter name="DoSaveRestart" type="logical" default="T" />
  <if expr="$DoSaveRestart">
    <parameter name="DnSaveRestart" type="integer" min="-1" default="-1" />
    <parameter name="DtSaveRestart" type="real"    min="-1" default="-1" />
  </if>
#SAVERESTART
T			DoSaveRestart Rest of parameters read if true
100			DnSaveRestart
-1.			DtSaveRestart [seconds]

Default is DoSaveRestart=.true. with DnSaveRestart=-1 and
DtSaveRestart=-1. This results in the restart file being
saved only at the end.  A binary restart file is produced for every
block and named as RESTARTOUTDIR/blkGLOBALBLKNUMBER.rst.
In addition the grid is described by RESTARTOUTDIR/octree.rst
and an ASCII header file is produced with timestep and time info:
RESTARTOUTDIR/restart.H

The restart files are overwritten every time a new restart is done,
but one can change the name of the RESTARTOUTDIR with the #RESTARTOUTDIR
command from session to session. The default directory name is 'restartOUT'.
</command>

<command name="PLOTDIR">
  <parameter name="NamePlotDir" type="string" length="$lLine"
	     default="GM/IO2"/>

The NamePlotDir variable contains the name of the directory
where plot files and logfiles are saved relative to the run directory.
The directory should be inside the subdirectory with the name
of the component.

Default value is "GM/IO2".
</command>

<command name="SAVELOGFILE">
  <parameter name="DoSaveLogfile" type="logical" default="F" />
  <if expr="$DoSaveLogfile">
    <parameter name="StringLog" type="strings" min="1" max="5">
      <part name="StringLogVar" type="string" input="select" required="T">
	<option name="MHD variables"     value="MHD" default="T" />
	<option name="MHD vars. scaled"  value="mhd" />
	<option name="Flux variables"    value="FLX" />
	<option name="Flux vars. scaled" value="flx" />
	<option name="Raw variables"     value="RAW" />
	<option name="Raw vars. scaled"  value="raw" />
	<option name="Set variables"     value="VAR" />
	<option name="Set vars. scaled"  value="var" />
      </part>
      <part name="NameCoord" type="string" input="select" required="F">
	<option name="GEO"/>
	<option name="GSE"/>
	<option name="GSM"/>
	<option name="MAG"/>
	<option name="SMG"/>
	<option name="HGR"/>
	<option name="HGI"/>
	<option name="HGC"/>
      </part>
      <part name="StringLogTime" type="string" input="select" required="F"
	    multiple="T">
	<option name="none" exclusive="T" />
	<option name="step" 		/>
	<option name="date" 		/>
	<option name="time" 		/>
      </part>
    </parameter>
    <parameter name="DnSaveLogfile" type="integer" min="-1" default="1" />
    <parameter name="DtSaveLogfile" type="real"    min="-1" default="-1" />
    <parameter name="NameLogVars" type="string" length="$lLine"
	       if="$StringLogVar =~ /var/i" />
    <parameter name="StringLogRadii" type="strings" min="1" max="10"
	       length="$lLine" if="($StringLogVar=~/flx/i or $NameLogVars=~/flx/i)">
      <part name="LogRadii" type="real" min="$rBody" multiple="T"/>
    </parameter>
  </if>
#SAVELOGFILE
T                       DoSaveLogfile, rest of parameters read if true
VAR step date GSE       StringLog
100                     DnSaveLogfile
-1.                     DtSaveLogfile [sec]
rho p ux uy uz rhoflx   NameLogVars (read if StrigLog is 'var' or 'VAR')
4.0  10.0               rLog  (radii for the flux. Read if vars include 'flx')

If DoSaveLogFile is set to true then an ASCII logfile containing
averages, point values, fluxes and other scalar quantities is written
at the frequency determined by DnSaveLogfile and DtSaveLogfile.
The logfile is written into IO2/log_TIMESTAMP.log. The TIMESTAMP contains
the time step or the date-time string (see the #SAVELOGNAME command).
The logfile has a very simple format:
\begin{verbatim}
arbitrary header line that can define for example the units
name1 name2 name3 ... nameN
value1 value2 value3 ... valueN
value1 value2 value3 ... valueN
value1 value2 value3 ... valueN
...
\end{verbatim}
The number variables as well as the number of data lines are arbitrary.
The IDL macros getlog and plotlog can be used for visualization of one
or more logfiles.

The StringLog parameter can contain the following parts in arbitrary order:
\begin{verbatim}
StringLogVar  = 'mhd', 'raw', 'flx' or 'var' - normalized units
StringLogVar  = 'MHD', 'RAW', 'FLX' or 'VAR' - I/O units
StringLogTime = 'none', 'step', 'time', and/or 'date'
NameCoord     = 'GEO', 'GSE', 'GSM', 'MAG', 'SMG', 'HGR', 'HGI' or 'HGC'
\end{verbatim}
The StringLogVar part is required and it determines the list
of variables to be saved into the logile.
The capitalization of StringLogVar controls whether the variables
are written in normalized units (lower case) or I/O units (UPPER CASE).
(see the #IOUNITS command). The StringLogTime part is optional.

The possible values for StringLogVar and the corresponding
variables together with the default values for
StringLogTime are the following:
\begin{verbatim}
raw or RAW   - step time Dt AverageConsVars Pmin Pmax
mhd or MHD   - step date time AverageConsVars Pmin Pmax
flx or FLX   - step date time Rho Pmin Pmax RhoFlx Pvecflx e2dflx
var or VAR   - step time NameLogVars
\end{verbatim}
The right side shows what will be saved into the logfile.
The 'step', 'time' and 'date' columns correspond to the default
value of StringLogTime that is discussed below. About the other variables:
Dt is the length of the time step, the AverageConsVars contain a list of
averages of the conservative variables (defined in ModEquation) over the whole domain,
and Pmin and Pmax are the minimum and maximum pressures over the whole domain.
The flux variables are integrals of fluxes through spherical surfaces at the
radial distances defined by the rLog parameter that is read if any of the
variables contain 'flx' (see below).

If StringLogVar is 'var' or 'VAR', then the NameLogVars parameter is read and
it should contain a space separated list of any of the following log variable names:
\begin{verbatim}
Dt                  - time step
Cfl                 - CFL number (may vary due to #TIMESTEPCONTROL)

Pmin Pmax           - minimum and maximum pressure over the grid

VAR                 - average of variable VAR (listed in NameVar_V of ModEquation.f90)
Ux Uy Uz            - average velocity on the grid
Ekinx Ekiny Ekinz   - average kinetic energy in X, Y and Z directions
Ekin                - average kinetic energy
Erad Ew             - average radiation/wave energy (summed for all groups/waves)
Lat1 Lat2           - average of latitude of fieldline tracing (for testing)
Lon1 Lon2 Status    - average of longitude and status of fieldline (for testing)

VARpnt              - point value of VAR (listed in NameVar_V) at the test cell
Uxpnt Uypnt Uzpnt   - point value of velocity at test cell
B1xpnt B1ypnt B1zpnt- point value of B1 field at test cell
Jxpnt Jypnt Jzpnt   - point value of current density
Lat1pnt Lat2pnt     - point value of latitude of fieldline mapping
Lon1pnt Lon2pnt     - point value of longitude of fieldline mapping
Statuspnt           - point value of status of fieldline tracing from test cell:
  (0: open, 1: connected along B, 2: connected along -B, 3: closed)

Jinmax Joutmax      - maximum of inward and outward currents at rCurrents of #BODY
Jin Jout            - surface integral of inward and outward currents at rCurrents

Aflx                - surface integral of 1      at radii defined in rLog (area)
Rhoflx              - surface integral of rho*Ur at radii defined in rLog
Bflx                - surface integral of Br     at radii defined in rLog
B2flx               - surface integral of B.B Ur at radii defined in rLog
Pvecflx             - surface integral of ExB    at radii defined in rLog (Poynting flux)
Dstflx              - surface integral of B1z    at radii defined in rLog (Dst index)

DstDivb             - error of the dstflx integral due to finite value of div B
Dst                 - Biot-Savart integral for Dst index

E2dflx              - circular integral of Ex*y-Ey*x

ANYTHINGELSE        - quantity defined in user_get_log_var
\end{verbatim}
The possible (0 or more) values for StringLogTime are the following:
\begin{verbatim}
 none  - there will be no indication of time in the logfile (not even the number of steps)
 step  - number of time steps
 date  - date-time as 7 integers:  year month day hour minute second millisecond,
 time  - simulation time
\end{verbatim}
The rLog parameter contains a list of radius values (in normalized units)
where the *flx variables are calculated.
The rLog parameter is only read when there is at least one 'flx' variable.
The logfile will contain the name of the flx variable combined with
the radial value, for example 'dstflx_R=3.0 dstflx_R=3.5 dstflx_R=5.0'.

If the optional NameCoord part is set, the output position, velocity,
magnetic field or current density vector variables will be written out in
the NameCoord coordinate system instead of the coordinate system of the
component. In the list of log variables the X, Y and Z components of a
given vector have to be all present and following each other in this order.

The default is DoSaveLogFile false.
</command>

<command name="SATELLITE" if="$_IsFirstSession">
  <parameter name="nSatellite" type="integer" min="0" default="0" />
  <for from="1" to="$nSatellite">
    <parameter name="StringSatellite" type="strings" min="1" max="6">
      <part name="NameSatelliteVar" type="string" input="select" required="T">
	<option name="MHD variables"    value="MHD" default="T" />
	<option name="MHD vars. scaled" value="mhd" />
	<option name="All variables"    value="FUL" />
	<option name="All vars. scaled" value="ful" />
	<option name="Set variables"    value="VAR" />
	<option name="Set vars. scaled" value="var" />
      </part>
      <part name="NameCoord" type="string" input="select" required="F">
	<option name="GEO"/>
	<option name="GSE"/>
	<option name="GSM"/>
	<option name="MAG"/>
	<option name="SMG"/>
	<option name="HGR"/>
	<option name="HGI"/>
	<option name="HGC"/>
	<option name="hgr"/>
	<option name="hgi"/>
	<option name="hgc"/>
      </part>
      <part name="OptionalVar" type="string" input="select" required="F"
	    multiple="T">
	<option name="none" exclusive="T"/>
	<option name="step"       />
	<option name="date"       />
	<option name="time"       />
	<option name="ray"       />
	<option name="traj"      />
	<option name="trajrange" />
      </part>
    </parameter>
    <parameter name="DnOutput" type="integer" min="-1" default="1" />
    <parameter name="DtOutput" type="real"    min="-1" default="-1" />
    <parameter name="NameTrajectoryFile" type="string" length="$lLine" />
    <if expr="$OptionalVar eq 'trajrange'">
      <parameter name="StartTimeTraj" type="real" />
      <parameter name="EndTimeTraj"   type="real" />
      <parameter name="DtTraj"        type="real" />
    </if>
    <rule expr="-f $NameTrajectoryFile">
      Trajectory file $NameTrajectoryFile must exist
    </rule>
    <parameter name="NameSatelliteVars" type="string" length="$lLine"
	       if="$NameSatelliteVar =~ /\bvar\b/i" />
  </for>
#SATELLITE
4                       nSatellite
MHD ray                 StringSatellite
100                     DnOutput
-1.                     DtOutput [sec]
satellite1.dat          NameTrajectoryFile
MHD trajrange           StringSatellite
100                     DnOutput
-1.                     DtOutput [sec]
satellite1.dat          NameTrajectoryFile
2011-02-01T00:00:00 UT	StringStartTimeTraj ! Read if StringSatellite contains 'trajrange'
2011-02-10T00:00:00 UT	StringEndTimeTraj   ! Read if StringSatellite contains 'trajrange'
1 h			StringDtTraj	    ! Read if StringSatellite contains 'trajrange'
VAR traj                StringSatellite
100                     DnOutput
-1.                     DtOutput [sec]
satellite1.dat          NameTrajectoryFile
rho p ux uy uz
VAR step date SMG       StringSatellite
100                     DnOutput
-1.                     DtOutput [sec]
satellite2.dat          NameTrajectoryFile
rho p ux uy uz          NameSatelliteVars ! Read if StringSatellite
                                          ! contains 'var' or 'VAR'

The numerical solution can be extracted along one or more satellite
trajectories. The number of satellites is defined by the
nSatellite parameter (default is 0).

For each satellite the StringSatellite parameter determines what
is saved into the satellite file(s).
The StringSatellite can contain the following parts in arbitrary order
\begin{verbatim}
SatelliteVar   = mhd, ful or var (normalized units)
                 MHD, FUL or VAR (I/O units)
NameCoord      = GEO, GSE, GSM, MAG, SMG, HGR, HGI, HGC, hgr, hgi, hgc
OptionalVar    = ray, none, step, time, traj, trajrange, date
\end{verbatim}
The SatelliteVar part is required and determines the list
of variables to be saved along the satellite trajectory.
The capitalization of SatelliteVar controls whether the variables
are written in normalized units (lower case) or I/O units (UPPER CASE).
See the #IOUNITS command.

If SatelliteVar' is set to 'mhd' or 'MHD', the primitive variables
(rho, u, B, p, pPar) and the current density (Jx, Jy, Jz) will be saved,
while the 'ful' or 'FUL' value also saves the B1 field values.
If SatelliteVar is set to 'var' or 'VAR' then the list of variables is read
from the NameSatelliteVar parameter as a space separated list.
The choices for saved variables are any of the variable names
listed in the NameVar_V variable in ModEquation.f90,
and the following case insensitive variable names
(after the name of the fluid is removed, e.g. OpPperp is Pperp for fluid Op):
\begin{verbatim}
Mx, My, Mz, Ux, Uy, Uz       - momentum and velocity components
B1x, B1y, B1z, B0x, B0y, B0z - magnetic field perturbation and background
Jx, Jy, Jz                   - current density
n                            - number density
T, Temp                      - temperature
Pperp                        - perpendicular pressure
Lon1, Lon2                   - longitude of mapped field line along B and -B
Lat1, Lat2                   - latitude of mapped field line along B and -B
Status                       - field line topology
        (0: open, 1: closed along B, 2: closed along -B 3: fully closed)
	(-1: cells inside body, -2: loop ray within block, -3: strange)
\end{verbatim}
If the optional NameCoord part is set, the output position, velocity,
magnetic field or current density vector variables will be written out in
the NameCoord coordinate system instead of the coordinate system of the
component. In the list of log variables the X, Y and Z components of a
given vector have to be all present and following each other in this order.

If the optional OptionalVar part contains 'ray' then the ray (fieldline)
tracing variables  'Lon1 Lat1 Lon2 Lat2 Status' are saved as well.
The strings 'step', 'time' and 'date' define the corresponding
time information. The value 'none' means that no time information is saved.
\begin{verbatim}
 none  - there will be no indication of time or steps in the logfile
 step  - number of time steps
 date  - date-time as 7 integers:  year month day hour minute second millisecond
 time  - simulation time
 ray   - fieldline tracing variables: lon1 lat1 lon2 lat2 status
 traj  - extract information along the full trajectory file
 trajrange  - extract information along a part of the trajectory file
\end{verbatim}
More than one OptionalVar strings can be listed. They can be put
together in any combination. The default value for OptionalVar is
'step date'.

The DnOutput and DtOutput parameters determine the frequency of
extracting values along the satellite trajectories.

The extracted satellite information is saved into the files named
\begin{verbatim}
PLOTDIR/sat_TRAJECTORYNAME_TIMESTAMP.sat
\end{verbatim}
where TIMESTAMP contains the time step or the date-and-time
information (see #SAVELOGNAME command) and TRAJECTORYNAME is the name
of the trajectory file.  The satellite files have a very simple
format:
\begin{verbatim}
arbitrary header line that can define for example the units
name1 name2 name3 ... nameN
value1 value2 value3 ... valueN
value1 value2 value3 ... valueN
value1 value2 value3 ... valueN
...
\end{verbatim}
The number variables as well as the number of data lines are arbitrary.
The IDL macros getlog and plotlog can be used for visualization of one
or more logfiles.

Satellite input files contain the trajectory of the satellite.  They should
have the following format:
\begin{verbatim}
#COOR
GSM

#START
2004 6 24 0 0 58 0 2.9 -3.1 -3.7
2004 6 24 0 1 58 0 2.8 -3.2 -3.6
...
\end{verbatim} 
The #COOR command is optional.  It indicates which coordinate system
is used for the trajectory coordinates. Possible values (GSM, GEO,
GSE, SMG, HGI, HGR...)  and their meaning is described in
share/Library/src/CON_axes.f90.  The default coordinate system is GSM.
After the #START line, the data lines contain the date-time information
(year, month, day, hour, minute, second, millisecond) and the x, y and
z coordinates in normalized units (typically planetary or solar
radius, see the #NORMALIZATION command).

If the StringSatellite contains 'traj', then the code simply extract
the information at ALL satellite locations from the satellite file.

If the StringSatellite contains 'trajrange', then StringStartTimeTraj,
StringEndTimeTraj and StringDtTraj need to be provided followed by the
NameTrajectoryFile. This alows writing the information along the
trajectory file for a given time range, both in time accurate and
steady state.  StringStartTimeTraj and StringEndTimeTraj determine the
time range of the output satellite file and accept the following forms
of string:
\begin{verbatim}
 A time string ending with ' UT', such as 'YYYY-MM-DDTHH:MM:SS:MSC UT' or 
   	    'YYYY MM DD HH MM SS MSC UT' (single digit need to fill 0 ahead and the 
	    sperator ('-', ':', 'T', ' ') between numbers can be whatever characters)
 Any number followed by ' w'/' d'/' h'/' m'/' s', in which case the time is with respect to
            #STARTTIME. For example, 1 h here means StartTime + 1 hour. THERE IS A SPACE
	    BEFORE THE CHARACTER W/D/H/M/S.
 Any number (in which case it is assumed to be in seconds), in which case the time
     	    is with respect to #STARTTIME.
\end{verbatim}
StringDtTraj can accept the following forms:
\begin{verbatim}
 Any number followed by ' w'/' d'/' h'/' m'/' s'
 Any number (in which case it is assumed to be in seconds)
\end{verbatim}

The default is nSatellite=0, i.e. no satellite data is saved.
</command>

<command name="STEADYSTATESATELLITE" if="$_IsFirstSession">
  <parameter name="SatelliteTimeStart" type="real" default="0" />
  <parameter name="SatelliteTimeEnd" type="real" default="0" />
#STEADYSTATESATELLITE
-1 day                       SatelliteTimeStart [sec]
+1 day                       SatelliteTimeEnd   [sec]
-1 hour                      SatelliteTimeStart [sec]
+1 hour                      SatelliteTimeEnd   [sec]

In the non-time-accurate mode the numerical simulation result
converges to a steady-state solution. In the course of this simulation
mode, the progress in the iteration number is not associated with an
increase in the physical time, and the ultimate solution is a
"snapshot" of the parameter distribution at the time instant set by
the #STARTTIME command. Since time does not run, a satellite position
cannot be determined in terms of the simulation time. Instead, the
parameters along a cut of the satellite trajectory can be saved on
file for a given iteration number.  The trajectory points can be
naturally parameterized by time, so that the cut can be specified with
the choice of the start time, end time, and time interval.

The command #STEADYSTATESATELLITE is required for a steady-state
simulation.  For each of the satellites, the SatelliteTimeStart is a
real value that sets the start of trajectory cut, while
SatelliteTimeEnd sets the end of the trajectory cut. Both are in
seconds with respect to the time given in #STARTTIME. A negative
value means the is time prior to the #STARTTIME.

The DtOutput from the #SATELLITE command specifies the frequency of
the points along the satellite trajectory for the non-time-accurate
mode, while DnOutput keeps to control the iteration number at which
the data at the trajectory cut are written to the satellite output
file.

For more than one satellite (two satellites in the above given
example), the start and end times should be set for all of them.
</command>

<command name="SATELLITETIMEOFFSET">
  <parameter name="UseSatelliteTimeOffset" type="logical" default="F"/>
  <if expr="$UseSatelliteTimeOffset">
      <parameter name="SatelliteTimeOffset" type="real"/>
  </if>
    
#SATELLITETIMEOFFSET
T                            UseSatelliteTimeOffset
25 hour                      SatelliteTimeOffset [sec]
25 hour                      SatelliteTimeOffset [sec]
25 hour                      SatelliteTimeOffset [sec]

Allows to set time offset in satellite files relative to tSimulation
</command>

<command name="PARCEL" if="$_IsFirstSession">
  <parameter name="UseParcel" type="logical" default="F"/>
  <if expr="$UseParcel">
    <parameter name="UseParcelTable" type="logical" default="F"/>
    <if expr="not $UseParcelTable">
      <parameter name="nParcel" type="integer" min="0" default="0" />
      <for from="1" to="$nParcel">
	<parameter name="xParcel" type="real"/>
	<parameter name="yParcel" type="real" />
	<parameter name="zParcel" type="real" />
      </for>
    </if>
    <parameter name="StringParcel" type="string" input="select">
      <option name="MHD variables"    value="MHD" default="T" />
      <option name="MHD vars. scaled" value="mhd" />
      <option name="All variables"    value="FUL" />
      <option name="All vars. scaled" value="ful" />
      <option name="Set variables"    value="VAR" />
      <option name="Set vars. scaled" value="var" />
    </parameter>
    <parameter name="DnOutput" type="integer" default="1" />
    <parameter name="DtOutput" type="real"    default="-1" />
    <if expr="$DnOutput &gt; 0">
      <parameter name="nStartParcel" type="integer" min="0" default="0" />
      <parameter name="nEndParcel" type="integer" min="$nStartParcel" />
    </if>
    <if expr="$DtOutput &gt; 0">
      <parameter name="StartTimeParcel" type="real" min="0" default="0" />
      <parameter name="EndTimeParcel" type="real" min="$StartTimeParcel" />
    </if>
    <parameter name="NameParcelVars" type="string" length="$lLine"
	       if="$StringParcel =~ /var/i" />
  </if>

#PARCEL
T                       UseParcel ! Rest is read if true
F                       UseParcelTable
2                       nParcel ! if UseParcelTable=F
0.0508514               xParcel 1
-1.01483                yParcel 1
-0.0888                 zParcel 1
-0.178076               xParcel 2
0.442199                yParcel 2
-0.901742               zParcel 2
VAR                     StringParcelVar
1                       DnOutput
-10                     DtOutput
1                       nStartParcel !StartTimeParcel if DtOutput > 0
4                       nEndParcel   !EndTimeParcel if DtOutput > 0
rho ux pe o(9)          NameParcelVars ! if StringParcelVar = var/VAR

The numerical solution can be extracted along one or more plasma parcel
trajectories. The number of trajectories is defined by the
nParcel parameter (default is 0).

For each parcel the StringParcel parameter determines what
is saved into the file(s). Possible values are
\begin{verbatim}
StringParcel   = mhd, ful or var (normalized units)
                 MHD, FUL or VAR (I/O units)
\end{verbatim}
The capitalization of StringParcel controls whether the variables
are written in normalized units (lower case) or I/O units (UPPER CASE).
If StringParcel is set to var or VAR, then the list of plot variables are read
as the last parameter.

The DnOutput and DtOutput parameters determine the frequency of
extracting values along the parcels' trajectories.

The extracted information is saved into the files named
\begin{verbatim}
PLOTDIR/pcl_ID_TIMESTAMP.pcl
\end{verbatim}
where TIMESTAMP contains the time step or the iteration number
information and ID is the ID between 1 and nParcel 
of the file.  The pcl files have a very simple
format:
\begin{verbatim}
arbitrary header line that can define for example the units
name1 name2 name3 ... nameN
value1 value2 value3 ... valueN
value1 value2 value3 ... valueN
value1 value2 value3 ... valueN
...
\end{verbatim}
The number variables as well as the number of data lines are arbitrary.
The IDL macros getlog and plotlog can be used for visualization of one
or more logfiles.

The default is UseParcel=F, i.e. no Lagrangian data is saved.
</command>

<command name="MAGPERTURBINTEGRAL">
  <parameter name="UseSurfaceIntegral" type="logical" default="F"/>
  <parameter name="UseFastFacIntegral" type="logical" default="F"/>
  <parameter name="TypeCoordIndex" type="string" input="select">
    <option name="MAG" default="T" />
    <option name="SMG" />
  </parameter>
  <parameter name="TypeCoordFacGrid" type="string" input="select"
	     if="not $UseFastFacIntegral">
    <option name="MAG" default="T" />
    <option name="SMG" />
  </parameter>

#MAGPERTURBINTEGRAL
T			UseSurfaceIntegral
F			UseFastFacIntegral
MAG			TypeCoordIndex
MAG			TypeCoordFacGrid (read if UseFastFacIntegral=F)

Control what method is used to do the Biot-Savart integrals to
calculate the magnetic perturbations.

If UseSurfaceIntegral is true, the volume integral over the MHD grid
is replaced with a surface integral using Igor Sokolov's formulas.
This surface integral is analytically identical with the 3D volume
integral outside the sphere plus the contributions from the external
field outside the MHD grid, but computationally much less expensive.
See Appendix C.5.1 in Gombosi et al 2021 JSWSC, doi:10.1051/swsc/2021020.

If UseFastFacIntegral is true, the integrals across the gap region
are precalculated for each magnetometer and each line starting 
from the lat-lon grid and stored into an array LineContrib_DII.
At any given time this array can be multiplied with the FAC 
values calculated at rCurrents to obtain the perturbation at
a given magnetometer. The storage as well as the calculation
is parallel. See Appendix C.5.2 in Gombosi et al 2021 JSWSC,
doi:10.1051/swsc/2021020.

TypeCoordIndex defines whether the 48 virtual magnetometers used for Kp, Ae
and other indexes are in the SMG system or the co-rotating MAG system.
The MAG system allows the use of the fast FAC integration for these
stations.

TypeCoordFacGrid defines the coordinate system for the spherical grid
used to integrate the contributions from the FAC in the gap region.
This has to be in the corotating MAG system if UseFastFacIntegral is true.
For the slow FAC integral method, the SMG system is allowed too.

Default values are UseSurfaceIntegral=T, UseFastFacIntegral=T,
TypeCoordIndex='MAG' and TypeCoordFacGrid='MAG', which are the
optimal settings for best computational speed.
</command>

<command name="GEOMAGINDICES">
  <parameter name="nSizeKpWindow" type="integer" min="15" default="180"/>
  <parameter name="DtOutput" type="real" min="-1"         default="60"/>
#GEOMAGINDICES
180			nSizeKpWindow [min]
60.0			DtOutput      [sec]

BATS-R-US can create synthetic geomagnetic indices by first simulating
ground based measurements then processing these data into indices.
This allows for an apples-to-apples comparison of indices created by
the simulation against indices created from observations.  It is also
useful in an operational setting, where quick-look activity indices
are paramount.  #GEOMAGINDICES activates the calculation of such
indices.  Results are written at a time cadence of DtOutput to the
file geoindex_TIMESTAMP.log

At present, only a synthetic version of Kp is available.
nSizeKpWindow, set in minutes and defaulting to 180 (3 hours), sets
the size of the time-history window used in the calculation of Kp.
Standard Kp uses a 3-hour window; versions of Kp used as operational
products use a window as short as 15-minutes.  Note that altering this
window requires a re-scaling of the K-index conversion tables inside
of the code.  As Kp is written to file, so are the individual
K-indices used in the calculation.  Offical Kp averages 13 K values
from 13 mid-latitude magnetometer stations around the globe.
Synthetic Kp from BATS-R-US uses 24 stations at fixed local time
positions and 50 degrees magnetic latitude.

Because Kp requires a time history of geomagnetic activity, special restart
files are saved when #GEOMAGINDICES is used.  If nSizeKpWindow changes between
restarts, however, the files will be rendered unusable because the time
history will no longer be valid for the calculation.

By default no indices are calculated.
</command>

<command name="MAGNETOMETER">
  <parameter name="NameMagInputFile" type="string" length="$lLine"/>
  <parameter name="TypeFileOut" type="string" input="select">
    <option name="single" default="T"/>
    <option name="step"/>
  </parameter>
  <parameter name="DnOutput" type="integer" min="-1" default="-1"/>
  <parameter name="DtOutput" type="real"    min="-1" default="-1"/>
  <rule expr="-f $NameMagInputFile">
    Magnetogram position file $NameMagInputFile must exist
  </rule>
#MAGNETOMETER
magin.dat		NameMagInputFile
single                  TypeFileOut
-1			DnOutput
60.0			DtOutput

The #MAGNETOMETER command is used for the calculation of the ground
perturbations caused by the field aligned currents in the 'gap' region
and the magnetopsheric currents in the GM domain.

The NameMagInputFile parameter gives the file name that contains the
locations on the Earth where the user is interested in calculating
the ground magnetic perturbations. The file has the following format:
\begin{verbatim}
#COORD
MAG			The coordinate system for the latitude/longitude below

#START
DST  360.00   360.00    Virtual DST station at the center of the Earth
YKC   68.93   299.36    The name of the station, latitude, longitude
MEA   61.57   306.20
NEW   54.85   304.68
...
\end{verbatim}
The coordinate system can be set to GEO (geographic), MAG
(geomagnetic) or SMG (solar magnetic) coordinates. The station names
can have maximum 3 characters.  The name, latitude, and longitude
columns should be separated with spaces.  If the latitude and
longitude are both set to 360.0, the station is placed to the center
of the Earth, and the perturbation for this "DST" station will be
given in SMG coordinates.

The TypeFileOut parameter specifies the format of the output file.
The value 'single' creates a single output file for all magnetometers
and all output times, while 'step' creates a new file for all
magnetometers for each output time.  The naming convention for the
files is controlled by the #SAVELOGNAME command.

The DnOutput and DtOutput parameters determine the frequency of
writing out the calculated perturbations in number of time steps and
time interval, respectively.

The ground-based magnetic perturbations are written into the output file
\begin{verbatim}
GM/IO2/magnetometers_*.dat,
\end{verbatim}
in which the number of time steps, the date and time, the station index,
the x, y and z coordinates of the station in SM coordinates, the 3 components
(magnetic northward, eastward, and downward) of the total
magnetic perturbations, as well as the contributions due to
magnetospheric currents, field-aligned currents in the gap region,
and Hall and Pedersen currents in the ionosphere are saved.
For the "DST" station at the center of the Earth the magnetic perturbations
are given in the SMG coordinates: north=x, east=y, down=z.
The units of coordinates is meters, while the magnetic perturbations are
given in nT.

Default is no magnetic perturbation calculation.
</command>

<command name="MAGNETOMETERGRID">
  <parameter name="nMagGridFile" type="integer" default="2"/>
  <for from="1" to="$nMagGridFile">
    <parameter name="StrGridFileOut" type="strings" min="2" max="2">
      <part name="NameGrid" type="string" length="10" default="global"/>
      <part name="TypeFile" type="string" input="select">
	<option name="ascii" default="T"/>
	<option name="tec"/>
	<option name="real4"/>
	<option name="real8"/>
      </part>
    </parameter>
    <parameter name="TypeCoordGrid" type="string" input="select">
      <option name="GEO" default="T"/>
      <option name="MAG"/>
      <option name="SMG"/>
      <option name="GSM"/>
    </parameter>
    <parameter name="nGridLon"      type="integer"          default="360"/>
    <parameter name="nGridLat"      type="integer"          default="171"/>
    <parameter name="GridLonMin"    type="real"             default="0"/>
    <parameter name="GridLonMax"    type="real"             default="360"/>
    <parameter name="GridLatMin"    type="real"             default="-85"/>
    <parameter name="GridLatMax"    type="real"             default="85"/>
    <parameter name="DnSaveMagGrid" type="integer" min="-1" default="-1"/>
    <parameter name="DtSaveMagGrid" type="real"    min="-1" default="-1"/>
  </for>

#MAGNETOMETERGRID
2                       nMagGridFile
global ascii		StrGridFileOut (ascii, tec, real4, real8)
GEO			TypeCoordGrid (GEO, MAG, SMG, GSM)
360			nGridLon
171			nGridLat
0.			GridLonMin
360.			GridLonMax
-85.			GridLatMin
85.			GridLatMax
-1			DnSaveMagGrid
60.0			DtSaveMagGrid
us real4		StrGridFileOut (ascii, tec, real4, real8)
GEO			TypeCoordGrid (GEO, MAG, SMG, GSM)
320			nGridLon
171			nGridLat
200.			GridLonMin
360.			GridLonMax
0.			GridLatMin
85.			GridLatMax
-1			DnSaveMagGrid
30.0			DtSaveMagGrid

This command allows calculating and saving magnetic perturbations on multiple
longitude-latitude grids. nMagGridFile specifies the number of magnetometer
grid outputs.

StrGridFileOut specifies the region name (part of the file name) and format.
The region name can be any arbitrary string (e.g., usa, europe, global).
The format can be 'ascii' (text file), 'tec' (Tecplot text file),
'real4' (single precision binary) or 'real8' (double precision binary).

TypeCoordGrid provides The coordinate system of the grid, which is
usually set to GEO (geographic) or MAG (geomagnetic). Both of these
allow for fast calculation (see UseFastFacIntegral parameter of the
#MAGPERTURBINTEGRAL command). The values SMG (solar magnetic) or
GSM (Geographic-Solar-Magnetic) are also allowed, but those do not
work with the fast integration method.

Note that the three components of the dB magnetic perturbations in the
output file are always magnetic north, magnetic east and down (NED),
which is independent of the coordinate system chosen for the grid.

The nGridLon and nGridLat parameters define the number of grid points
in the longitude and latitude directions, respectively. The longitudes
span from from GridLonMin to GridLonMax, while the latitudes span from
GridLatMin to GridLatMax.  If the longitude spans 360 degrees, the
stations will be arranged so that the equivalent longitudes of 0 and
360 are not repeated. However, if -90 or +90 degrees is used for the
maximum/minimum latitude, the polar stations will be repeated
nLonMagGrid times, so choose limits wisely.  The 2D output files are
saved every DnSaveMagGrid steps or DtSaveMagGrid seconds.

No magnetometer grid file is saved by default.
</command>

<command name="SUPERMAGINDICES">
  <parameter name="DoWriteSupermagIndices" type="logical" default="F"/>

#SUPERMAGINDICES
T			DoWriteSupermagIndices

This command calculates and saves synthetic SuperMAG geomagnetic indices
from the magnetometer grid.

The indices SML (AL), SMU (AU), SME (AE), and SMO (AO) are computed
using every grid point defined in the #MAGNETOMETERGRID command, within
the magnetic latitude range +40 to +80. Output is written at the same
cadence as the DnSaveMagGrid or DtSaveMagGrid and saved in the
superindex*.log file.

If the #SUPERMAGINDICES command is used without the #MAGNETOMETERGRID
command, or if the magnetometer grid does not cover the full latitude
range from +40 to +80, then a warning message will be generated and
indices are not calculated.
</command>

<command name="SAVEPLOT">
  <parameter name="nPlotFile" type="integer" min="0" max="25" default="1" />
  <for name="iPlot" from="1" to="$nPlotFile">
    <parameter name="StringPlot" type="strings" min="3" max="3">
      <part name="plotform" type="string" input="select"
	    required="T">
	<option value="tec" name="Node based TECPLOT"/>
	<option value="tcp" name="Cell centered TECPLOT"/>
	<option value="hdf" name="HDF5"/>
	<option value="idl" name="IDL" default="T"/>
	<option value="idl_real4" name="IDL single prec"/>
	<option value="idl_real8" name="IDL double prec"/>
	<option value="idl_ascii" name="IDL ascii"/>
	<option value="idl_tec"   name="IDL to Tecplot"/>
      </part>
      <part name="plotarea" type="string" input="select"
	    required="T">
	<option name="1D" value="1d/1d_"/>
	<option name="2D" value="2d/2d_"/>
	<option name="3D" value="3d/3d_/3D/3D_"/>
	<option name="x=0" />
	<option name="y=0" default="T" />
	<option name="z=0" />
	<option name="shell"        value="shl" />
	<option name="shell ln(r)"  value="sln" />
	<option name="shell lg(r)"  value="slg" />
	<option name="shock"        value="shk" />
	<option name="box" />
	<option name="los" />
	<option name="rfr" />
	<option name="line" value="lin" />
	<option name="eq.rays" value="eqr" />
	<option name="min B surface" value="eqb" />
	<option name="cut" />
	<option name="bx0" />
	<option name="slice" value="slc"
		if="$plotform =~ /\btec\b/"/>
	<option name="dipole" value="dpl"
		if="$plotform =~ /\btec\b/"/>
	<option name="block" value="blk"
		if="$plotform =~ /\btec\b/"/>
	<option name="1D" value="1d/1d_"
		if="$plotform =~ /\btec\b/"/>
	<option name="ieb" />
	<option name="last closed B" value="lcb" />
	<option name="coupling buffer" value="buf" />
	<option name="points" value="pnt"/>
      </part>
      <part name="plotvar" type="string" required="T"
	    input="select">
	<option name="MHD variables"    value="MHD" default="T"/>
	<option name="MHD vars. scaled" value="mhd"/>
	<option name="HD variables"    value="HD"/>
	<option name="HD vars. scaled" value="hd"/>
	<option name="Full set of variables" value="FUL"/>
	<option name="Full set scaled" value="ful"/>
	<option name="All state variables" value="ALL"/>
	<option name="All state variables scaled" value="all"/>
	<option name="Raw variables"    value="RAW"/>
	<option name="Raw vars. scaled" value="raw"/>
	<option name="Ray tracing vars."  value="RAY"/>
	<option name="Ray tracing scaled" value="ray"/>
	<option name="Squash factor vars."  value="LGQ"/>
	<option name="Squash factor scaled" value="lgq"/>
	<option name="Flux variables"    value="FLX"/>
	<option name="Flux vars. scaled" value="flx"/>
	<option name="Solar variables"    value="SOL"/>
	<option name="Solar vars. scaled" value="sol"/>
	<option name="Spectrum/(D)EM variables" value="dem"/>
	<option name="Spectrum/Flux variables" value="fux"/>
	<option name="Spectrum/Photoexcitation flux variables" value="phx"/>
	<option name="Spectrum/Narrowband image variables" value="nbi"/>
	<option name="EUV image variables" value="euv"/>
	<option name="Tabular image variable"      value="tbl"/>
	<option name="Radio wave intensity" value="rwi"/>
	<option name="Instruments for line-of-sight images" value="INS"/>
	<option name="Instruments for line-of-sight images, scaled"
		value="ins"/>
	<option name="Position variables"    value="POS"
		if="$plotarea eq 'lin'" />
	<option name="Position vars. scaled" value="pos"
		if="$plotarea eq 'lin'"/>
	<option name="Equatorial rays" value="eqr"  if="$plotarea eq 'eqr'"/>
	<option name="Minimum B surface" value="eqb" if="$plotarea eq 'eqb'"/>
	<option name="Basic block variables"    value="BBK" />
	<option name="Basic block vars. scaled"	value="bbk" />
	<option name="Set variables"    value="VAR" />
	<option name="Set vars. scaled" value="var"/>
	<option name="Integrated variables"    value="INT" />
	<option name="Integrated vars. scaled" value="int"/>
	<option name="NULL - irrelevant" value="nul"/>
      </part>
    </parameter>
    <parameter name="DnSavePlot" type="integer" min="-1" default="-1"/>
    <parameter name="DtSavePlot" type="real"    min="-1" default="-1.0"/>
    <if expr="$plotarea eq 'cut'">
      <parameter name="Coord1MinCut" type="real" />
      <parameter name="Coord1MaxCut" type="real" min="$Coord1MinCut"/>
      <parameter name="Coord2MinCut" type="real" />
      <parameter name="Coord2MaxCut" type="real" min="$Coord2MinCut"/>
      <parameter name="Coord3MinCut" type="real" />
      <parameter name="Coord3MaxCut" type="real" min="$CoordMinCut"/>
    </if>
    <if expr="$plotarea =~ /\bdpl|bx0|slc\b/">
      <parameter name="xMinCut" type="real" />
      <parameter name="xMaxCut" type="real" min="$xMinCut"/>
      <parameter name="yMinCut" type="real" />
      <parameter name="yMaxCut" type="real" min="$yMinCut"/>
      <parameter name="zMinCut" type="real" />
      <parameter name="zMaxCut" type="real" min="$zMinCut"/>
    </if>
    <if expr="$plotarea =~ /\bslc\b/">
      <parameter name="xPoint"  type="real" />
      <parameter name="yPoint"  type="real" />
      <parameter name="zPoint"  type="real" />
      <parameter name="xNormal" type="real" />
      <parameter name="yNormal" type="real" />
      <parameter name="zNormal" type="real" />
    </if>
    <if expr="$plotarea =~ /\bblk\b/">
      <parameter name="xPoint"  type="real" />
      <parameter name="yPoint"  type="real" />
      <parameter name="zPoint"  type="real" />
    </if>
    <if expr="$plotarea =~ /\blos\b/ and $plotvar =~ /\bins\b/">
      <parameter name="StringsInstrument" type="string" length="$lLine"/>
    </if>
    <if expr="$plotarea =~ /\blos\b/ and $plotvar !~ /\bins\b/ and $plotvar !~ /\b(dem|fux|phx|nbi)\b/">
      <parameter name="ObsPosX" type="real" default="-215"/>
      <parameter name="ObsPosY" type="real" default="0"/>
      <parameter name="ObsPosZ" type="real" default="0"/>
      <parameter name="OffsetAngle" type="real"
		 min="-360" max="360" default="0"/>
      <parameter name="rSizeImage" type="real" min="0" default="32"/>
      <parameter name="xOffset" type="real" default="0"/>
      <parameter name="yOffset" type="real" default="0"/>
      <parameter name="rOccult" type="real" min="0" default="2"/>
      <parameter name="MuLimbDarkening" type="real"
		 min="0" max="1" default="0.5"/>
      <parameter name="nPix" type="integer" min="2" default="200"/>
      <parameter name="NameLosTable" type="string" length="$lLine"
		 if="$plotvar =~ /tbl/i"/>
    </if>
    <if expr="$plotarea =~ /\blos\b/ and $plotvar =~ /\b(dem|fux|phx|nbi)\b/">
      <parameter name="TypeCoord" type="string" length="3" default="HGR"/>
      <parameter name="ObsPosX"     type="real" default="0"/>
      <parameter name="ObsPosY"     type="real" default="0"/>
      <parameter name="ObsPosZ"     type="real" default="0"/>
      <parameter name="x0"  type="real"/>
      <parameter name="y0"     type="real" />
      <parameter name="xLen"  type="real" min="0" />
      <parameter name="dX"     type="real" min="0"/>
      <parameter name="yLen"  type="real" min="0" />
      <parameter name="dY"     type="real" min="0"/>
      <parameter name="TempMin" type="real" default="1e5"/>
      <parameter name="LogTeMinDEM" type="real" default="4" if="$plotvar =~ /dem/i"/>
      <parameter name="LogTeMaxDEM" type="real" default="7" if="$plotvar =~ /dem/i"/>
      <parameter name="DLogTeDEM" type="real" default="0.1" if="$plotvar =~ /dem/i"/>
      <parameter name="NameSpmTable" type="string" default="SPECTRUM_chianti_tbl.dat" if="$plotvar =~ /fux/i"/>
      <parameter name="UseUnobserved" type="logical" default="F" if="$plotvar =~ /fux/i"/>
      <parameter name="LambdaMin" type="real" default="10" if="$plotvar =~ /fux/i"/>
      <parameter name="LambdaMax" type="real" default="1700" if="$plotvar =~ /fux/i"/>
      <parameter name="DLambda" type="real" default="0.001" if="$plotvar =~ /fux/i"/>
      <parameter name="UseAlfven" type="logical" default="F" if="$plotvar =~ /fux/i"/>
      <parameter name="UseDoppler" type="logical" default="F" if="$plotvar =~ /fux/i"/>
      <parameter name="DLambdaIns" type="real" default="0.0" if="$plotvar =~ /fux/i"/>
      <parameter name="UseIonFrac" type="logical" default="F" if="$plotvar =~ /fux/i"/>
      <parameter name="UseIonTemp" type="logical" default="F" if="$plotvar =~ /fux/i"/>
      <parameter name="NameSpmTable" type="string" default="SPECTRUM_chianti_tbl.dat" if="$plotvar =~ /nbi/i"/>
      <parameter name="UseIonFrac" type="logical" default="F" if="$plotvar =~ /nbi/i"/>
      <parameter name="NameResponse" type="string" default="eit195response.dat" if="$plotvar =~ /nbi/i"/>
      <parameter name="NamePhxTable" type="string" default="PHOTOEXC_6376.2900.dat" if="$plotvar =~ /phx/i"/>
      <parameter name="LambdaMin" type="real" default="10" if="$plotvar =~ /phx/i"/>
      <parameter name="LambdaMax" type="real" default="1700" if="$plotvar =~ /phx/i"/>
      <parameter name="DLambda" type="real" default="0.001" if="$plotvar =~ /phx/i"/>
      <parameter name="UseAlfven" type="logical" default="F" if="$plotvar =~ /phx/i"/>
      <parameter name="UseDoppler" type="logical" default="F" if="$plotvar =~ /phx/i"/>
      <parameter name="DLambdaIns" type="real" default="0.0" if="$plotvar =~ /phx/i"/>
      <parameter name="UseIonFrac" type="logical" default="F" if="$plotvar =~ /phx/i"/>
      <parameter name="UseIonTemp" type="logical" default="F" if="$plotvar =~ /phx/i"/>
    </if>
    
    <if expr="$plotarea =~ /\brfr\b/">
      <parameter name="ObsPosX" type="real" default="-215"/>
      <parameter name="ObsPosY" type="real" default="0"/>
      <parameter name="ObsPosZ" type="real" default="0"/>
      <parameter name="StringRadioFrequency" type="string" length="$lLine"/>
      <parameter name="xSizeImage" type="real" min="0" default="32"/>
      <parameter name="ySizeImage" type="real" min="0" default="32"/>
      <parameter name="nPixX" type="integer" min="2"   default="200"/>
      <parameter name="nPixY" type="integer" min="2"   default="200"/>
    </if>
    <if expr="$plotarea =~ /\blin\b/">
      <parameter name="NameLine" type="string" input="select">
	<option name="Advected magnetic field line"  value="A" />
	<option name="Magnetic field line" value="B" default="T"/>
	<option name="Stream line"  value="U"/>
	<option name="Current line" value="J"/>
      </parameter>
      <parameter name="IsSingleLine" type="logical" default="F" />
      <parameter name="nLine" type="integer" min="1" max="20" default="1" />
      <for name="i" from="1" to="$nLine">
	<parameter name="xStartLine" type="real"/>
	<parameter name="yStartLine" type="real"/>
	<parameter name="zStartLine" type="real"/>
	<parameter name="IsParallel" type="logical"/>
      </for>
    </if>
    <if expr="$plotarea =~ /\beqr\b/">
      <parameter name="nRadius" type="real" min="1" default="20"/>
      <parameter name="nLon"    type="real" min="1" default="25"/>
      <parameter name="RadiusMin" type="real" min="1" default="3"/>
      <parameter name="RadiusMax" type="real" min="1" default="10"/>
    </if>
    <if expr="$plotarea =~ /\beqb\b/">
      <parameter name="nRadius" type="real" min="1" default="20"/>
      <parameter name="nLon"    type="real" min="1" default="25"/>
      <parameter name="RadiusMin" type="real" min="1" default="3"/>
      <parameter name="RadiusMax" type="real" min="1" default="10"/>
      <parameter name="LongitudeMin" type="real" min="0" default="0"/>
      <parameter name="LongitudeMax" type="real" max="360" default="360"/>
    </if>
    <if expr="$plotarea =~ /\blcb\b/">
      <parameter name="Radius"  type="real" min="0" default="6"/>
      <parameter name="nLon"    type="real" min="4" default="36"/>
    </if>
    <if expr="$plotarea =~ /\b(shl|sln|slg|shk)\b/">
      <parameter name="DivuDxMin" type="real" max="0" if="$plotarea =~ /shk/"/>
      <parameter name="TypeCoordPlot" type="string" length="3" default="GEO"
		 if="$plotarea !~ /shk/"/>
      <parameter name="rMin"   type="real" min="0"     default="6.6"/>
      <parameter name="rMax"   type="real" min="$rMin" default="6.6"/>
      <parameter name="dR"     type="real" min="0"
		 if="$rMin != $rMax and $plotarea !~ /shk/"/>
      <parameter name="LonMin" type="real" min="0"     default="0"/>
      <parameter name="LonMax" type="real" min="$LonMin" max="360"
		 default="360"/>
      <parameter name="dLon"   type="real" min="0"
		 if="$LonMin != $LonMax"/>
      <parameter name="LatMin" type="real" min="-90" default="-90"/>
      <parameter name="LatMax" type="real" min="$LatMin" max="90"
		 default="90"/>
      <parameter name="dLat"   type="real" min="0"
		 if="$LatMin != $LatMax"/>
    </if>
    <if expr="$plotarea =~ /\bbox\b/">
      <parameter name="TypeCoordPlot" type="string" length="3" default="HGR"/>
      <parameter name="x0"     type="real" default="0"/>
      <parameter name="y0"     type="real" default="0"/>
      <parameter name="z0"     type="real" default="0"/>
      <parameter name="xSize"  type="real" min="0"/>
      <parameter name="dX"     type="real" min="0" if="$xSize != 0" />
      <parameter name="ySize"  type="real" min="0" />
      <parameter name="dY"     type="real" min="0" if="$ySize != 0"/>
      <parameter name="zSize"  type="real" min="0" />
      <parameter name="dZ"     type="real" min="0" if="$zSize != 0"/>
      <parameter name="xAngle" type="real" min="-360" max="360" default="0"/>
      <parameter name="yAngle" type="real" min="-360" max="360" default="0"/>
      <parameter name="zAngle" type="real" min="-360" max="360" default="0"/>
    </if>
    <parameter name="DxSavePlot" type="real" min="-1.0" default="-1.0"
       if="($plotform=~/\bidl/ and $plotarea!~/\b(box|buf|shl|sln|slg|shk|los|rfr|lin|eqr|eqb)\b/)" />
    <if expr="$plotarea !~ /\blos\b/ and $plotvar =~ /\bfux\b/">
      <parameter name="NameSpmTable" type="string" default="SPECTRUM_chianti_tbl.dat"/>
      <parameter name="UseUnobserved" type="logical" default="F"/>
      <parameter name="Lambda" type="real" default="195.119"/>
      <parameter name="UseIonFrac" type="logical" default="F"/>
    </if>
    <if expr="$plotarea !~ /\blos\b/ and $plotvar =~ /\bphx\b/">
      <parameter name="NamePhxTable" type="string" default="PHOTOEXC_6376.2900.dat"/>
      <parameter name="Lambda" type="real" default="6376.2900"/>
      <parameter name="UseIonFrac" type="logical" default="F"/>
    </if>
    <if expr="$plotarea !~ /\blos\b/ and $plotvar =~ /\bnbi\b/">
      <parameter name="NameSpmTable" type="string" default="SPECTRUM_chianti_tbl.dat"/>
      <parameter name="UseIonFrac" type="logical" default="F"/>
      <parameter name="NameNbiTable" type="string" default="eit195response.out"/>
    </if>
    <if expr="$plotvar =~ /\bvar\b/i">
      <parameter name="NameVars" type="string" length="$lLine"/>
      <parameter name="NamePars" type="string" length="$lLine"
		 default="{default}"/>
    </if>
  </for>

#SAVEPLOT
21			nPlotFile
cut MHD tcp		StringPlot ! 3d cell centered Tecplot with MHD data
100			DnSavePlot
-1.			DtSavePlot
-10.			Coord1MinCut
10.			Coord1MaxCut
-10.			Coord2MinCut
10.			Coord2MaxCut
-10.			Coord3MinCut
10.			Coord3MaxCut
2d  FUL hdf		StringPlot ! 2d HDF plot with a lot of data
100			DnSavePlot
-1.			DtSavePlot
1d  HD idl_tec		StringPlot ! 1d plot (with Tecplot header) along X axis
100			DnSavePlot
-1.			DtSavePlot
0.			DxSavePlot ! with smallest grid resolution
y=0 VAR idl		StringPlot ! y=0 plane plot with listed variables
-1			DnSavePlot
100.			DtSavePlot
0.25			DxSavePlot ! resolution (for IDL plots)
{MHD} impl dx		NameVars
{default} c		NamePars
cut ray idl_real8	StringPlot ! 3D cut plot with raytrace info
1			DnSavePlot
-1.			DtSavePlot
-10.			Coord1MinCut
10.			Coord1MaxCut
-10.			Coord2MinCut
10.			Coord2MaxCut
-10.			Coord3MinCut
10.			Coord3MaxCut
-1.			DxSavePlot ! unstructured grid (for IDL plots)
los tbl idl_real4       StringPlot ! line of sight plot using table
-1			DnSavePlot
100.			DtSavePlot
-215.			ObsPosX
0.			ObsPosY
0.			ObsPosZ
5.0                     OffsetAngle ! rotate around with 5 degree resolution
32.			rSizeImage
0.			xOffset
0.			yOffset
3.			rOccult
0.5			MuLimbDarkening
300			nPix
AiaXrt			NameLosTable
lin mhd idl		StringPlot  ! field line plot
-1			DnSavePlot
10.			DtSavePlot
B			NameLine ! B - magnetic field line, U - stream line
F			IsSingleLine
2			nLine
-2.0			xStartLine
0.0			yStartLine
3.5			zStartLine
F			IsParallel
-1.0			xStartLine
1.0			yStartLine
-3.5			zStartLine
T			IsParallel
eqr eqr idl		StringPlot ! Equatorial (magnetic) field line tracing info
1000                    DnSavePlot
-1.                     DtSavePlot
20			nRadius    ! Starting points on the SM equatorial plane
25			nLon
3.0			RadiusMin
10.0			RadiusMax
eqb eqb tec		StringPlot ! Minimum B surface plot
1000                    DnSavePlot
-1.                     DtSavePlot
20			nRadius    ! Starting points on the SM equatorial plane
25			nLon
3.0			RadiusMin
10.0			RadiusMax
60.0			LongitudeMin
300.0			LongitudeMax
dpl MHD tec		StringPlot  ! dipole slice Tecplot (ONLY!) plot
-1			DnSavePlot
10.			DtSavePlot
-10.			xMinCut
 10.			xMaxCut
-10.			yMinCut
 10.			yMaxCut
-10.			zMinCut
 10.			zMaxCut
slc MHD tec		StringPlot  ! general slice Tecplot (ONLY!) plot
-1			DnSavePlot
10.			DtSavePlot
-10.			xMinCut
 10.			xMaxCut
-10.			yMinCut
 10.			yMaxCut
-10.			zMinCut
 10.			zMaxCut
 0.			xPoint
 0.			yPoint
 0.			zPoint
  0.			xNormal
  0.			yNormal
  1.			zNormal
blk MHD tec		StringPlot  ! general block Tecplot (ONLY!) plot
-1			DnSavePlot
10.			DtSavePlot
 5.			xPoint
 1.			yPoint
 1.			zPoint
ieb nul tec             StringPlot  !IE grid field line plots Tecplot (ONLY!)
1000                    DnSavePlot
-1.                     DtSavePlot
lcb int tec             StringPlot  !last closed field line plots with integrals
1000                    DnSavePlot  !Tecplot (ONLY!)
-1.                     DtSavePlot
6.			Radius
36			nLon
shl MHD idl		StringPlot
10  			DnSavePlot
-1.			DtSavePlot
GEO			TypeCoordPlot
5.6			rMin
7.6			rMax
0.5			dRad    ! only read if rMin /= rMax
0.			LonMin
360.			LonMax
10.			dLon    ! only read if LonMin /= LonMax
-90.			LatMin
90.			LatMax
10.			dLat    ! only read if LatMin /= LatMax
shk HD idl		StringPlot
10  			DnSavePlot
-1.			DtSavePlot
-10.0                   DivuDxMin [km/s]
1.2			rMin
25.0			rMax
0.			LonMin
360.			LonMax
1.			dLon
-90.			LatMin
90.			LatMax
1.			dLat
box MHD idl             StringPlot
1                       DnSavePlot
-10.0                   DtSavePlot
SYS                     TypeCoordPlot
0.0                     x0
0.0                     y0
1.5                     z0
2.0                     xSize
.01                     dX       ! only read if xSize /= 0
0.2                     ySize
0.01			dY       ! only read if ySize /= 0
3.0                     zSize
0.01                    dZ       ! only read if zSize /= 0
0.0                     xAngle [deg]
90.0                    yAngle [deg]
0.0                     zAngle [deg]
los dem idl_ascii       StringPlot
4                       DnSavePlot
-1.                     DtSavePlot
HGR                     TypeCoord
216                     ObsPosX
0                       ObsPosY
0                       ObsPosZ
0                       x0
0                       y0
2                       xLen
0.1                     dX
2                       yLen
0.1                     dY
0.0                     TempMin
5                       LogTeMinDEM
8                       LogTeMaxDEM
0.1                     DLogTeDEM
los fux idl_ascii       StringPlot
4                       DnSavePlot
-1.                     DtSavePlot
HGR                     TypeCoord
216                     ObsPosX
0                       ObsPosY
0                       ObsPosZ
0                       x0
0                       y0
2                       xLen
0.1                     dX
2                       yLen
0.1                     dY
0.0                     TempMin
SPECTRUM_chianti_tbl.dat    NameSpmTable
F                       UseUnobserved
400                     LambdaMin
410                     LambdaMax
0.1                     DLambda
T                       UseAlfven
T                       UseDoppler
0.0                     DLambdaIns
F                       UseIonFrac
F                       UseIonTemp
los nbi idl_ascii       StringPlot
4                       DnSavePlot               
-1.                     DtSavePlot
HGR                     TypeCoord
216                     ObsPosX
0                       ObsPosY
0                       ObsPosZ  
0                       x0
0                       y0
2                       xLen
0.1                     dX
2                       yLen
0.1                     dY
0.0                     TempMin
SPECTRUM_chianti_tbl.dat    NameSpmTable
F                       UseIonFrac
eit195response.out      NameResponse
los phx idl_ascii                 StringPlot
4			DnSavePlot
-1.			DtSavePlot
HGR			TypeCoord
216			ObsPosX
0			ObsPosY
0			ObsPosZ
1			x0
1			y0
2			xLen
0.2			dX
2			yLen
0.2			dY
0			TempMin
PHOTOEXC_6376.2900.dat		NamePhxTable
6375			LambdaMin
6378			LambdaMax
0.1			DLambda
T			UseAlfven
T			UseDoppler
0.02			DLambdaInstrument
F			UseIonFrac
F			UseIonTemp
rfr tec rwi             StringPlot
10                      DnSavePlot
-1.0                    DtSavePlot
 -67.92			ObsPosX
 200.40			ObsPosY
 -26.91			ObsPosZ
1.5 GHz 500 MHz 100 MHz    StringRadioFrequency
4.0 	    	    	xSizeImage
4.0			ySizeImage
100			nPixX
100			nPixY
los ins idl_real4       StringPlot ! line of sight plot using table
-1			DnSavePlot
100.			DtSavePlot
soho:c3 sta:euvi stb:cor2	StringsInstrument
buf MHD idl	 	StringPlot
-1  			DnSavePlot
1 hour			DtSavePlot
bx0 MHD idl_ascii	StringPlot ! bx=0(on z) isosurface plot with MHD data
100			DnSavePlot
-1.			DtSavePlot
-10.			xMinCut
10.			xMaxCut
-10.			yMinCut
10.			yMaxCut
-10.			zMinCut
10.			zMaxCut
-1                      DxSavePlot

The #SAVEPLOT command determines the number and type of plot files
saved from BATS-R-US.

The nPlotFile parameter sets the number of plot files to be saved.
For each plot file, the StringPlot parameters defines the format
and the content as detailed below.
The PlotString is always followed by the plotting frequencies
DnSavePlot and DtSavePlot that determine the frequency of saves
in temrs of time steps and simulation time, respectively.
The rest of the parameters read for a given plot file
depends on StringPlot.

StringPlot must contain the following 3 parts in the following order
\begin{verbatim}
PlotForm PlotArea PlotVar
\end{verbatim}
Each of these parts can have different values.
Most (but not all) combinations are valid.
The PlotForm can have one of the following values:
\begin{verbatim}
tec             - Node based Tecplot format
tcp             - Cell centered Tecplot format
hdf             - HDF5 format (for VisIt)
idl/idl_real4   - Single precision binary "IDL" format
idl_real8       - Double precision binary "IDL" format
idl_ascii       - ASCII "IDL" format
idl_tec         - ASCII format with Tecplot header
\end{verbatim}
The node based Tecplot format (for most plot areas) interpolates data
to the grid cell corners (nodes).
The cell centered Tecplot, HDF and IDL formats save the cell center values.
The HDF output works only if the HDF library is installed,
the appropriate parallel HDF module is loaded and BATSRUS/SWMF is
configured with the -hdf flag.
The "IDL" format can be read with the IDL visualization macros
(read\_data and animate\_data)
in BATSRUS/Idl or with the SpacePy python package.
The ASCII "IDL" format can be easily read with any other plotting software.
The "IDL" file format is described
at the beginning of the share/Library/src/ModPlotFile.f90.

The PlotArea string defines a 1, 2, or 3D volume for plotting:
\begin{verbatim}
1d    - 1D cut along the X axis (saves tree file)
2d    - 2D cut (like Z=0)       (saves tree file)
3d    - full 3D volume          (saves tree file)
3D    - full 3D volume including cells outside the "box" (saves tree file)
x=0   - full x=0 plane: average for symmetry plane
y=0   - full y=0 plane: average for symmetry plane
z=0   - full z=0 plane: average for symmetry plane
cut   - 3D, 2D or 1D cut along (curvilinear) coordinates (IDL and TCP)
        or a 2D rectangular cut (node based Tecplot)
bx0   - bx=0 (along z direction) isosurface plot
dpl   - cut at dipole 'equator', uses PLOTRANGE to clip plot
slc   - 2D slice defined with a point and normal, uses PLOTRANGE to clip plot
shl   - spherical shell in given coordinate system (1, 2 or 3D)
sln   - spherical shell with ln(r) radial coordinate
slg   - spherical shell with log10(r) radial coordinate
shk   - shock surface extracted on a lon-lat grid. Limited in radial distance.
box   - cartesian box in given coordinate system (1, 2, or 3D)
los   - line of sight integrated plot
lin   - one dimensional plot along a field or stream or current line
blk   - 3D single block cell centered data, block specified point location
rfr   - radiotelescope pixel image plot
eqr   - field lines traced from the magnetic equatorial plane
eqb   - minimum B surface on a grid defined on the magnetic equatorial plane
ieb   - field lines traced from a subset of the IE coupled grid
lcb   - last closed field lines
buf   - coupling buffer between two components
\end{verbatim}
The 1d, 2d and 3d cuts save the AMR tree information into a .tree file.
This can be used for reconstructing the full grid and use the data
with the READAMR library, for example.

For the PlotArea 'bx0' which is the bx=0 on z direction isosurface plot,
an extra plot variable 'z' will be added as the first plot variable
in addition to the PlotVar string. This extra plot variable 'z'
records the position of the isosurface.

For IDL and cell centered Tecplot (tcp) plots the PlotArea = 'cut'
can be used to create cuts.

The PlotVar string defines the plot variables and the equation parameters.
It also controls whether or not the variables will be plotted in dimensional
values or as non-dimensional values:
\begin{verbatim}
 CAPITALIZED  - dimensional
 lower case   - dimensionless

 'var' - vars: READ FROM PARAMETER FILE
         pars: READ FROM PARAMETER FILE
 'all' - vars: all state variables defined in the equation module
         pars: g
 'hd'  - vars: Primitive_Variables
         pars: g rbody
 'mhd' - vars: Primitive_Variables Jx Jy Jz
         pars: g rbody
 'ful' - vars: Primitive_Variables B1x B1y B1z e Jx Jy Jz
         pars: g rbody
 'raw' - vars: Conservative_Variables P b1x b1y b1z divb
         pars: g rbody
 'ray' - vars: bx by bz lon1 lat1 lon2 lat2 status blk        (if DoMapEquatorRay=F)
         vars: bx by bz req1 phi1 req2 phi2 status blk        (if DoMapEquatorRay=T)
         pars: rbody
 'eqr' - vars: iLine l x y z rho ux uy uz bx by bz p rCurve   (for all rays traced)
         pars: nRadius, nLon, nPoint
 'eqb' - vars: z PrimVarMinB rCurve xZ0 yZ0 zZ0 PrimVarZ0 rCurveZ0  (B is in SM coordinates)
 'flx' - vars: rho mr br p jr pvecr
         pars: g rbody
 'bbk' - vars: dx pe blk blkall
         pars:
 'pos' - vars  x y z                                          (PlotArea='lin' only)
         pars:
 'sol' - vars: wl pb                                          (PlotArea='los' only)
         pars: mu
 'lgq' - vars: squash.03 squash.12 squash.2 squash-15 squash-2 squash-3  (PlotArea='los' only)
	 pars: rbody
 'euv' - vars: euv171 euv195 euv284                           (PlotArea='los' only)
         pars: mu
 'sxr' - vars: sxr                                            (PlotArea='los' only)
         pars: mu
 'tbl' - vars: listed in the LOS table file                   (PlotArea='los' only)
         pars: mu
 'dem' - vars: DEM, EM                                        (PlotArea='los' only)
         pars: rbody
 'fux' - vars: flux
         pars: rbody
 'nbi' - vars: intensity
         pars: rbody
 'phx' - vars: flux
         pars: rbody
 'int' - vars: 1/B n/B p/B                                    (PlotArea='lcb' only)
         pars:
 'nul' - vars:                                                (PlotArea='lcb' only)
         pars:
 'ins' - vars: determined by the corresponding instrument, see line-of-sight below
       - pars: determined by the corresponding instrument, see line-of-sight below
\end{verbatim}
Depending on StringPlot, the following parameters are also read
from the parameter file in this order:
\begin{verbatim}
 xMinCut...zMaxCut	 if PlotArea is 'bx0', 'dpl', or 'slc'
 Coord1MinCut...Coord3MaxCut	 if PlotArea is 'cut'
 nRadius nLon            if PlotArea is 'eqr' or 'eqb'
 TypeCoordPlot           if PlotArea is 'shl', 'sln', 'slg' or 'box'
 DivuDxMin               if PlotArea is 'shk'
 RadiusMin RadiusMax     if PlotArea is 'eqr', 'eqb', 'shl', 'sln', 'slg', 'shk'
 LonMin LonMax           if PlotArea is 'eqb', 'shl', 'sln', 'slg', 'shk'
 LatMin LatMax           if PlotArea is 'shl', 'sln', 'slg', 'shk'
 dRadius, dLon, dLat     if PlotArea is 'sln', 'slg' or 'shl' and range is nonzero.
 dLon, dLat              if PlotArea is 'shk'
 x0, y0, z0              if PlotArea is 'box'
 xSize, ySize, zSize     if PlotArea is 'box'
 dX, dY, dZ              if PlotArea is 'box' and associated range is nonzero.
 xAngle, yAngle, zAngle  if PlotArea is 'box' (given in degrees)
 xPoint yPoint zPoint	 if PlotArea is 'slc', or 'blk'
 xNormal yNormal zNormal if PlotArea is 'slc'
 DxSavePlot		 if PlotForm is 'idl' and PlotArea is not box/shl/sln/slg/shk/los/rfr/lin/eqr/eqb
 NameVars		 if PlotVar  is 'var' or 'VAR'
 NamePars		 if PlotVar  is 'var' or 'VAR'
\end{verbatim}
Plotting range: the six parameters xMinCut ... zMaxCut define a 3D box
in Cartesian coordinates. The Coord1MinCut ... Coord3MaxCut define a
box in Cartesian or curvilinear coordinates.

For IDL plots, if the width in one or two dimensions is
less than the smallest cell size within the plotarea,
then the plot file will be 2 or 1 dimensional, respectively.
This also works for non-Cartesian grids: the cut will be a 1D curve
or a 2D surface aligned with the curvilinear coordinates.
For example, from a spherical grid
one can create a 1D cut along an arbitrary radial direction or along a circle,
a 2D cut with fixed radius, fixed longitude or fixed latitude,
or a spherical-wedge-shaped 3D cut. Note that the limits of the first
coordinate are always given as true radial distance
(even for radially stretched spherical grids),
while the longitude and latitude limits are given in degrees.
The output file will contain 1, 2 or 3 of the radial, the longitude and
latitude (in degrees) coordinates instead of the X, Y, Z coordinates.
If possible, the data will be averaged to the 2D cut surface during
the postprocessing.

For cell centered Tecplot files the cuts work the same way as for IDL,
but 0 width cuts will produce two cells across instead of interpolating
to the central plane. On the other hand, the cell centered Tecplot
output retains the original AMR grid structure.

For Tecplot plots (PlotForm='tec') and PlotArea='dpl' or 'slc' the plot range
clips the cut plane.
For node based Tecplot files with PlotArea 'cut',
the xMin .. zMax parameters are read
but interpreted differently from IDL.
Cuts are entire x, y, or z equal constant planes (1D or 3D cuts are not
implemented).  For x constant, for example, the y and z ranges
do not matter as long as they are wider than the x range.  The slice will be
located at the average of xMinCut and xMaxCut.
So, for example to save a plot in
a x=-5 constant plane cut, the following can be used:
\begin{verbatim}
 -5.01			xMinCut
 -4.99			xMaxCut
 -10.			yMinCut
  10.			yMaxCut
 -10.			zMinCut
  10.			zMaxCut
\end{verbatim}
The xPoint, yPoint, zPoint parameters give the coordinate of a point
inside a grid block for PlotArea 'blk'.
For PlotArea 'slc' they mean the coordinates of a point on the slice plane,
and xNormal, yNormal, zNormal define a normal vector to the slice plane.
If the normal in any given coordinate direction is less than 0.01,
then no cuts are computed for cell edges parallel to that coordinate direction.
For example, the following would result in only computing cuts on cell
edges parallel to the Z axis.
\begin{verbatim}
  0.0			xNormal
  0.0			yNormal
  1.0			zNormal
\end{verbatim}
The DxSavePlot parameter determines the grid resolution for IDL files:
\begin{verbatim}
  positive value - uniform grid with cell size DxSavePlot in first coordinate
  0.	         - uniform grid with smallest cell in the plotting area
 -1.	         - unstructured grid with original AMR cells
\end{verbatim}

The line-of-sight (PlotArea 'los') plots calculate integrals along the
lines of sight of some quantity and create a 2D Cartesian square
shaped grid of the integrated values. Only the circle enclosed in the
square is actually calculated and the corners are filled in with
zeros.  The image plane always contains the origin of the
computational domain (usually the center of the Sun).  By default the
image plane is orthogonal to the observers position relative to the
origin. The image plane can be rotated around the Z axis with an
offset angle. If OffsetAngle is positive, a series of images are
created covering the full circle with the OffsetAngle resolution.
If OffsetAngle is negative, only one rotated image is created.
By default the center of the image is the observer projected onto
the image plane, but the center of the image can be offset.
Since the central object (the Sun) contains extremely large
values, an occultational disk is used to block the lines of sight
going through the Sun.  The variables which control the direction of
the lines of sight and the grid position and resolution are the
following:
\begin{verbatim}
 ObsPosX,ObsPosY,ObsPosZ - the position of the observer in (rotated)
                           HGI coordinates (SC,IH and OH) or the GM coordinates
 rSizeImage             - the radius of the LOS image
 xOffset, yOffset       - offset relative to the observer projected onto
                          the image plane
 rOccult                - the radius of the occulting disk
 MuLimbDarkening        - the limb darkening parameter for the 'wl'
                          (white light) and 'pb' (polarization brightness)
                          plot variables.
 nPix                   - the number of pixels in each direction
\end{verbatim}
For line-of-sight Extreme Ultraviolet (EUV) and Soft X-Ray (SXR) plots,
the same parametes are read as for the wl and pb plots (above) but now
the integration is carried out to the surface of the sun so rOccult should
be set to zero. MuLimbDarkening has no effect but needs to be included.
Also, for line-of-sight (los) EUV images from STEREO-A/B and SDO/AIA using
the response function table both 'ins' and 'INS' give the same dimensional
output.
Additionally, because EUV and SXR plots are configured to read in a response
table specific to the EUV or SXR instument (e.g. SOHO EIT, STEREO EUVI,
Yohkoh SXT) the tables for the response need to be read in by additional
lines in the PARAM.in file. This follows the #LOOKUPTABLE command
syntax e.g:
\begin{verbatim}
#LOOKUPTABLE
euv                     NameTable
load                    NameCommand
SC/Param/los_Eit.dat    NameFile
ascii                   TypeFile

#LOOKUPTABLE
sxr                     NameTable
load                    NameCommand
SC/Param/los_Sxt.dat    NameFile
ascii                   TypeFile
\end{verbatim}
The possible values for NameVars with PlotArea 'los'
are listed in subroutine set_plotvar_los in write_plot_los.f90.

The line-of-site (PlotArea 'los') plots have an option to use 'ins'/'INS',
which will fill the ObsPosX, ObsPosY, ObsPosZ, rSizeImage, xOffset, yOffset,
rOccult, MuLimbDarkening, nPix for SOME supported instruemts. An example is:

\begin{verbatim}
los ins idl_real4       StringPlot ! line of sight plot using table
-1			DnSavePlot
100.			DtSavePlot
soho:c3 sta:euvi stb:cor2	StringsInstrument
\end{verbatim}

which is treated as ONE plot file in #SAVEPLOT, and the code would count
how many instruments and expand the number of plot files after reading 
StringsInstrument. The StringsInstrument can contain multiple strings 
(maximum 200 characters). The supported combinations are:

\begin{verbatim}
Stereo A:    sta:euvi, sta:cor1, sta:cor2
Stereo B:    stb:euvi, stb:cor1, stb:cor2
SDO:   	     sdo:aia
Hinode:	     hinode:xrt
SOHO:	     SOHO:c2, SOHO:c3
\end{verbatim}
The possible values for NameVars for other plot areas
are listed in subroutine set_plotvar in write_plot_common.f90.
For convenience and to avoid exceeding the line length limit
of the PARAM.in file, the {MHD} and {HD} strings can be
used in NameVars. These are replaced with the appropriate
primitive variables (and jx jy jz for MHD), so one can add
a few extra variables easily.

The possible values for NamePars are listed in subroutine
set_scalar_param in write_plot_common.f90. The {default} string
will be replaced with the default list of parameters, which
include molecular masses (m1..m9) and charges (q1..q9) for each fluid,
the length and time units (xSI and tSI) if different from 1,
the adiabatic index (g) or indexes (g1..g9 if they are not equal,
and the radius of the inner boundary (r) if present. The electron
mass (me) is saved if there is an electron fluid,
and the adiabatic index of electrons (ge) if it is different from gamma.\\

The refracting rays based plots (PlotArea 'rfr') plots calculate integrals
along the curved rays (distorted by refraction) of the (radio) emissivity
in the solar (stellar) corona  and create a 2D Cartesian square
shaped grid of the integrated intensity. Only the circle enclosed in the
square is actually calculated and the corners are filled in with
zeros.  The image plane always contains the origin of the
computational domain (usually the center of the Sun).  The
image plane is orthogonal to the line coonecting the  observers position
to the center of the Sun. The variables which control the direction of
the lines of sight and the grid position and resolution are the
following:
\begin{verbatim}
 ObsPosX,ObsPosY,ObsPosZ - the position of the observer in the
                           coordinate system of the component
 StringRadioFrequency    - the frequency or list of frequencies
 xSizeImage, ySizeImage  - the size of the radio image
 nPixX, nPixY            - the number of pixels in each direction
\end{verbatim}

Most plot files are written in parallel: each processor
writes out part of the data. These intermediate files are
typically ASCII for the 'tec' and 'tcp' formats
(see the #SAVETECBINARY command, which is useful for conversion to vtk format)
and can be either binary or ASCII in 'idl' format
as chosen with the #SAVEBINARY command (default is binary).
The name of the files are
\begin{verbatim}
 IO2/PlotArea_PlotVar_PlotNumber_TIMESTAMP_PEnumber.extension
\end{verbatim}
where extension is 'tec' for the TEC/TCP and 'idl' for the IDL file formats.
The PlotNumber goes from 1 to nPlotFilr in the order of the files in PARAM.in.
The TIMESTAMP contains time step, simulation time or date-time information
depending on the settings in the #SAVEPLOTNAME command.

After all processors wrote their plot files, processor 0 writes a small
ASCII header file named as
\begin{verbatim}
 IO2/PlotArea_PlotVar_PlotNumber_TIMESTAMP.headextension
\end{verbatim}
where headextension is:
\begin{verbatim}
           'T' for TEC/TCP file format
           'h' for IDL file format
\end{verbatim}
The line of sight integration produces TecPlot and IDL files directly:
\begin{verbatim}
 IO2/los_PlotVar_PlotNumber_TIMESTAMP.extension
\end{verbatim}
where extension is 'dat' for TecPlot and 'out' for IDL file formats.

The shell plot area ('shl', 'sln', 'slg') can be used to extract a spherical
shell defined by radius, longitude and latitude ranges in the coordinate
system given by TypeCoordPlot. Setting TypeCoordPlot="SYS" means that the
coordsystem is the same as used by the model. If the range has extent zero in
one or two coordinates, the shell becomes a 2D or 1D slice
(for example 2D Lon-Lat, r-Lon, r-Lat surfaces, or 1D circle at fixed latitude,
or a radial line with fixed longitude and latitude).
The 'sln' and 'slg' are uniform in the logarithm of the radius, the former
saves ln(r) into the file, the latter the 10-based lg(r). The meaning of
the radial resolution dR becomes the size of the first cell at the minimum
radius. The minimum and maximum radii are read as normal radii (not logarithm).
The output is a single file in IDL or Tecplot format.

The shock surface ('shk') is extracted along radial lines started from a
longitude-latitude grid. The surface is defined by the smallest value of
div u*dx along each radial line. If the minimum div u*dx is larger than DivuDxMin
(a negative value in velocity units), there is no shock surface. The output
always contains DivuDx and the radial distance of the surface as additional
plot variables.

The box plot area ('box') can be used to extract a Cartesian box
defined by the center position and the size (length of the edges)
and angles by which it is rotated around the axes of the coordinate
system given by TypeCoordPlot. If the range has extent zero in
one or two coordinates, the box becomes a 2D or 1D slice
(for example 2D X-Y, X-Z, Y-Z surfaces, or 1D line along the X, Y or Z axis).
The output is a single file in IDL or Tecplot format.

Default is nPlotFile=0, so no plot files are saved.
</command>

<command name="RADIOEMISSION">
  <parameter name="TypeRadioEmission" type="string" input="select">
    <option name="simplistic" default="T" />
    <option name="bremsstrahlung" />
  </parameter>
#RADIOEMISSION
simplistic               TypeRadioEmission

This command is used for 'rfr' plots (see #SAVEPLOT).
It allows the selection of mechanisms for radio emission ('bremsstrahlung' or
'simplistic' mechanism, which interpolates between Bremsstrahlung and
contributions from non-thermal emission at critical and quarter-of-critical
densities, the different contributions being weighted quite arbitrarily.
Default is 'simplistic'.
</command>

<command name="NOREFRACTION">
  <parameter name="UseNoRefraction" type="logical" default="F"/>
#NOREFRACTION
T               UseNoRefraction

This command allows switching off the radio wave referaction to evaluate
how the refraction affects the images obtained with 'rfr' plots
(see #SAVEPLOT). Default is switched on (UseNoRefraction=F).
</command>

<command name="SAVETECPLOT">
  <parameter name="DoSaveOneTecFile" type="logical" default="F" />
#SAVETECPLOT
T			DoSaveOneTecFile

This command only works with 3D tecplot file (see #SAVEPLOT). It allows
saving a single direct access formatted tecplot data/connectivity file.
Post processing is still needed because the tecplot file is separated into
3 different files: the header file, the data file and the connectivity file.

If DoSaveOneTecFile is false, save separate tecplot data/connectivity for each
processor. On some systems, saving the data/connectivity into a single file
might not work.

The default value is false.
</command>

<command name="INSTRUMENT">
  <parameter name="StringInstrument" type="string" length="$lLine"/>
  <parameter name="OffsetAngle" type="real"
	min="-360" max="360" default="0"/>
  <parameter name="rSizeImage" type="real" min="0" default="32"/>
  <parameter name="xOffset" type="real" default="0"/>
  <parameter name="yOffset" type="real" default="0"/>
  <parameter name="rOccult" type="real" min="0" default="2"/>
  <parameter name="MuLimbDarkening" type="real"
	min="0" max="1" default="0.5"/>
  <parameter name="nPix" type="integer" min="2" default="200"/>

#INSTRUMENT
sdo:aia			StringInstrument
0			OffsetAngle
1.25			rSizeImage
0			xOffset
0			yOffset
0			rOccult
0			MuLimbDarkening
512                     nPix

This command overwrites the default parameters of instrument StringInstrument
that were set by a previous #SAVEPLOT command.
In the above example the size of the synthetic AIA image is set to 1.25
instead of default value 1.98.
</command>

<command name="SAVEPLOTNAME">
  <parameter name="UsePlotNameStep" type="logical" default="T" />
  <parameter name="UsePlotNameTime" type="logical" default="T" />
  <parameter name="UsePlotNameDateTime" type="logical" default="F" />
#SAVEPLOTNAME
T			UsePlotNameStep
T			UsePlotNameTime
F			UsePlotNameDateTime

The TIMESTAMP of plot files (see #SAVEPLOT) can contain the time step
in the _nSTEP format, the simulation time in the _tSIMTIME format and
the date and time in the _eYYYYMMDD-HHMMSS-MSC format.
Any combination of these logicals are allowed

The default values are UsePlotNameStep and UsePlotNameTime true and
UsePlotNameDateTime false.
</command>

<command name="SAVELOGNAME">
  <parameter name="UseLogNameStep"     type="logical" default="T" />
  <parameter name="UseLogNameDateTime" type="logical" default="F" />
#SAVELOGNAME
T			UseLogNameStep
F			UseLogNameDateTime

The TIMESTAMP part of the names of logfiles (see #LOGFILE),
satellite files (see #SATELLITE)
and magnetometer files (see #MAGNETOMETER) can be controlled
with the logicals UseLogNameStep and UseLogNameDateTime.
If UseLogNameStep is true, the TIMESTAMP will contain the time step
in the form _nTIMESTEP (see #NSTEP command).
If UseLogNameDateTime is true, the TIMESTAMP will contain the date and time
in the form _eYYYYMMDD-HHMMSS. If both logicals are true, both the
step and the date-time will be in the TIMESTAMP. If both are false,
the TIMESTAMP will be empty.

The default is UseLogNameStep true and UseLogNameDateTime false.
</command>

<command name="SAVEBINARY">
  <parameter name="DoSaveBinary" type="logical" default="T" />
#SAVEBINARY
T			DoSaveBinary   used only for 'idl' plot file

Default is .true. Saves unformatted IO2/*.idl files if true.
This is the recommended method, because it is fast and accurate.
The only advantage of saving IO2/*.idl in formatted text files is
that it can be processed on another machine or with a different
(lower) precision. For example PostIDL.exe may be compiled with
single precision to make IO2/*.out files smaller, while BATSRUS.exe is
compiled in double precision to make results more accurate.
</command>

<command name="SAVETECBINARY">
  <parameter name="DoSaveTecBinary" type="logical" default="T" />
#SAVETECBINARY
F			DoSaveTecBinary

If true, save Tecplot data and connectivity information in binary format. 
Currently this only works for 3D tec and tcp files. Note that the resulting
files are not directly readable by Tecplot, but can be converted to other
formats.

Default is false. 

</command>

<command name="PLOTFILENAME" multiple="T">
  <parameter name="NameMaxTimeUnit" type="string" input="select">
    <option name="date"/>
    <option name="year"/>
    <option name="yr"/>
    <option name="month"/>
    <option name="day"/>
    <option name="hour" default="T"/>
    <option name="hr"/>
    <option name="minute"/>
    <option name="second"/>
    <option name="millisecond"/>
    <option name="microsecond"/>
    <option name="nanosecond"/>
    <option name="timestep"/>
  </parameter>
#PLOTFILENAME
hour			NameMaxTimeUnit

For time accurate runs the plot filenames contain an 8-charcter timestamp
string. The NameMaxTimeUnit string determines the content of this string.

If the longest time unit is hours or shorter, the string contains the
simulation time. If the time unit is days or longer the string contains
the physical date (set by the #STARTTIME command) and time information.

For NameMaxTimeUnit='hour' the string contains the simulation time
described by a 4-character string for hours, and two 2-character strings
for minutes and seconds, respectively.
For NameMaxTimeUnit='hr' the string contains the simulation time
described by a 2-character strings for hours, minutes, and seconds
with a decimal point and one decimal digit. For NameMaxTimeUnit='minute'
the first 2 characters describe the minutes, and the rest is seconds
including 3 decimal digits. NameMaxTimeUnit='second' gives
the simulation time up to 100 seconds with 5 decimal digits.
NameMaxTimeUnit='millisecond' ('microsecond', 'nanosecond') give
the simulation time up to 1000 milliseconds (microseconds, nanoseconds)
with 4 decimal digits.

For time unit 'date' the full 14-character date-time string
(YYYYMMDDHHMMSS) is used.
For time units 'day', 'month', 'yr' and 'year' an 8-character-long substring
of the date-time string is used.
For NameMaxTimeUnit='year' the time stamp will contain the four digit year,
and the two-digit month and day.
For NameMaxTimeUnit='yr' the last two digits of the year,
and the month, day and hour are used.
For NameMaxTimeUnit='month' the month, day, hour, and minute are used.
For NameMaxTimeUnit='day' the day, hour, minute and seconds are used.
For NameMaxTimeUnit='timestep' only the timestep is used.

The #PLOTFILENAME command and the NameMaxTimeUnit parameter are
saved into the restart header file so that the #PLOTFILENAME command does
not have to be repeated in restarted runs (unless the unit is changed).

The default value is NameMaxTimeUnit='hour'.
</command>

<command name="SAVEONEFILE">
  <parameter name="DoSaveOneIdlFile" type="logical" default="T" />
#SAVEONEFILE
T			DoSaveOneIdlFile

Save IDL files using MPI-IO. All processors write to one 
*.idl file to reduce file numbers. 
</command>

<command name="SAVEINITIAL">
  <parameter name="DoSaveInitial" type="logical" default="F" />
#SAVEINITIAL
T			DoSaveIntial

Save plots and log/satellite files at the beggining of the session.
Default is DoSaveInitial=.false. except for the first time accurate
session (when simulation time is zero) when the initial state
is always saved.
</command>

<command name="SAVEPLOTSAMR">
  <parameter name="DoSavePlotsAmr" type="logical" default="F" />
#SAVEPLOTSAMR
F			DoSavePlotsAmr

Save plots before each AMR. Default is DoSavePlotsAMR=.false.
</command>

<command name="FLUSH">
  <parameter name="DoFlush" type="logical" default="T"/>

#FLUSH
F			DoFlush

If the DoFlush variable is true, the output is flushed when
subroutine ModUtility::flush_unit is called. This is used in the
log and satellite files. The flush is useful to see the output immediately,
and to avoid truncated files when the code crashes,
but on some systems the flush may be very slow.

The default is to flush the output, i.e. DoFlush=T.
</command>
</commandgroup>

<commandgroup name="ERUPTIVE EVENT GENERATOR">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!  ERUPTIVE EVENT GENERATOR  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  <command name="CME">
    <parameter name="UseCme" type="logical" default="F" />
    <if expr="$UseCme">
      <parameter name="DoAddFluxRope" type="logical" default="F" />
      <parameter name="tDecayCme" type="real" min="-1" default="-1" />
      <parameter name="LongitudeCme" type="real"
		 min="-180" max="359" default="0" />
      <parameter name="LatitudeCme" type="real"
		 min="-90" max="90" default="0" />
      <parameter name="OrientationCme" type="real" 
		 min="0" max="359" default="0" />
      <parameter name="TypeCme" type="string" case="upper" input="select"
		 required="T">
	<option name="GIBSON-LOW"          value="GL" default="T" />
	<option name="TITOV-DEMOULIN 1999" value="TD"             />
	<option name="TITOV-DEMOULIN 2014" value="TD14"	          />
	<option name="TITOV-DEMOULIN 2022" value="TD22"	          />
	<option name="SPHEROMAK"	                          />
	<option name="BREAKOUT"                                   />
      </parameter>
      <if expr="$TypeCme eq 'BREAKOUT'">
	<parameter name="FlowAmplitude"     type="real"/>     
	<parameter name="FlowWidthAngle"    type="real"/>
	<parameter name="MaxBrActiveRegion" type="real"/>
	<parameter name="StartTime"         type="real"/>
	<parameter name="StopTime"          type="real"/>
	<parameter name="RampUpTime"        type="real"/>
	<parameter name="RampDownTime"      type="real"/>
      </if>
      <if expr="$TypeCme eq 'GL'">
	<parameter name="BStrength" type="real" default="0" min="0"/>
	<parameter name="iHelicity" type="integer" input="select">
	  <option name="+1" default="T" />
	  <option name="-1" />
	</parameter>
	<parameter name="Radius" type="real" min="0" default="0" />
	<parameter name="Stretch" type="real" min="0" default="0" />
	<parameter name="ApexHeight" type="real" min="0" default="0" />
      </if>
      <if expr="$TypeCme eq 'SPHEROMAK'">
	<parameter name="BStrength" type="real" default="0" />
	<parameter name="iHelicity" type="integer" input="select">
	  <option name="+1" default="T" />
	  <option name="-1" />
	</parameter>
	<parameter name="Radius" type="real" min="0" default="0" />
	<parameter name="Stretch" type="real" min="0" default="0" />
	<parameter name="ApexHeight" type="real" min="0" default="0" />
	<parameter name="uCme" type="real" min="0" default="0" />
      </if>
      <if expr="$TypeCme =~ /^TD/">
	<parameter name="iHelicity" type="integer" input="select">
	  <option name="+1" default="T" />
	  <option name="-1" />
	</parameter>
	<parameter name="RadiusMajor" type="real" min="0" default="0" />
	<parameter name="RadiusMinor" type="real" min="0" default="0" />
	<parameter name="Depth" type="real" min="0" default="0" />
	<if expr="$TypeCme eq 'TD'">
	  <parameter name="UsePlasmaBeta" type="logical" default="F"/>
	  <parameter name="PlasmaBeta" type="real" min="0" default="0"
		     if="$UsePlasmaBeta"/>
	  <parameter name="EjectaTemperature" type="real" min="1e4" default="5e4"
		     if="$UsePlasmaBeta"/>
	  <parameter name="Mass" type="real" min="0" default="0"
		     if="not $UsePlasmaBeta"/>
	</if>
	<if expr="$TypeCme eq 'TD22'">
	  <parameter name="PlasmaBeta" type="real" min="1e-8" default="1e-2"/>
	  <parameter name="EjectaTemperature" type="real" min="1e4" default="5e4"/>
	</if>
	<parameter name="TypeBStrap" type="string" case="lower" input="select">
	  <option name="none"	  />
	  <option name="readbstrap" />
	  <option name="getbstrap"  />
	  <option name="steady" />
	  <option name="moving" />
	  <option name="cancelflux" />
	</parameter>
	<parameter name="BcTubeDim" type="real" default="0" min="0"
		   if="$TypeBStrap eq 'none'"/>
	<if expr="$TypeBStrap =~ /readbstrap|getbstrap/">
	  <parameter name="bStrappingDim" type="real" min="0" default="0"
		     if="$TypeBStrap eq 'readbstrap'"/>
	  <parameter name="TypeCharge" type="string" case="lower" input="select">
	    <option name="none"	  />
	    <option name="steady" />
	    <option name="moving" />
	    <option name="cancelflux" />
	  </parameter>
	  <parameter name="bQStrapFraction" type="real" min="0" default="0"
		     if="$TypeCharge ne 'none'"/>
	  <parameter name="qDistance" type="real" min="0" default="0"
		     if="$TypeCharge ne 'none'"/>
	  <parameter name="UChargeX" type="real" min="0" default="0"
		     if="$TypeCharge =~ /moving|cancelflux/"/>
	</if>
	<if expr="$TypeBStrap =~ /steady|moving|cancelflux/">
	  <parameter name="BcTubeDim" type="real" default="0" min="0"/>
	  <parameter name="bQStrapFraction" type="real" min="0" default="0" />
	  <parameter name="qDistance" type="real" min="0" default="0" />
	  <parameter name="UChargeX" type="real" min="0" default="0"
		     if="$TypeBStrap =~ /moving|cancelflux/"/>
	</if>
      </if>
    </if>

#CME
T			UseCme ! Rest is read if UseCme is true
T			DoAddFluxRope
2 h			tDecayCme
0			LongitudeCme   [deg]
0			LatitudeCme    [deg]
0			OrientationCme [deg]
GL			TypeCme    GL/TD/TD14/TD22/SPHEROMAK
5.0			BStrength      [Gs]
1                       iHelicity
1.03			Radius         [Rs]
0.3			Stretch        [Rs]
1.8			ApexHeight     [Rs]

#CME
T			UseCme ! Rest is read if UseCme is true
T			DoAddFluxRope
-1.0			tDecayCme
0			LongitudeCme   [deg]
0			LatitudeCme    [deg]
0			OrientationCme [deg]
SPHEROMAK		TypeCme    
5.0			BStrength      [Gs]
-1                      iHelicity
1.03			Radius         [Rs]
0.3			Stretch        [Rs]
1.8			ApexHeight     [Rs]
600                     uCme           [km/s]

If UseCme is false, no CME gnerator is applied.
If UseCme is true, the CME generator is applied via the boundary condition.
If, in addition to this, DoAddFluxRope is true, then the flux rope
is added as a "user perturbation" at the beginning of the session.
The tDecayCme determines how long it takes for the CME related boundary
conditions to decay toward zero. If tDecayCme is -1, there boundary conditions
do not decay. If tDecayCme is positive, the boundary conditions linearly
decay from the original values to zero in tDecayCme time.

The LongitudeCme and LatitudeCme parameters characterize location of
the superimposed configuration. They provide the longitude and latitude in
degrees, of the configuration center. Third parameter, OrientationCme,
chaaracterizes the CME orientation. The recommended value of OrientationCme
is the counterclockwise angle, in degrees, between the local parallel
(the horizontal axis of solar magnetogram), and the ``major direction of the
horizontal solar magnetic field'' in the active region from which the eruption
ooccurs. For different types of the eruptive event generator this major field
direction may be quantified in somewhat different way. For example, for GL
soluution this is the direction from the center of positive magnetic spot to
that of the negative magnetic spot, which can be determined from the observed
magnetogram for a simple bi-polar region. For the modified TD generator
(TD14) this is the direction of the magnetic field acting on the
super-imposed current filament, which may be found based on 3D
reconstruction of the solar magnetic field. Depending on this input parameter,
the simulated CME configuration will be properly orriented to better fit
the observed solar magnetic field.

The latest implementation for the Gibson-Low eruptive event generator
(TypeCme=GL) follows the paper Borovikov, D., I. V.  Sokolov,
W. B. Manchester, M. Jin, and T. I. Gombosi (2017), Eruptive event
generator based on the Gibson-Low magnetic configuration,
J. Geophys. Res.  Space Physics, 122, 7979,
doi:10.1002/2017JA024304.

BStrength (denoted as B0 in the cited paper) is the characteristic
magnetic field, in Gauss, such that the magnetic field at the center
of configuration (prior to stretching) equals about 0.7 B0.

The integer iHelicity defines positive (+1) or negative (-1) helicity
by setting the sign of the poloidal field. The sign of the toroidal field
is fixed, as it points from the positive to the negative spot of the active region.

The Radius parameter sets of the radius of the last
magnetic (spherical) surface confining all currents (before stretching).

The Stretch parameter ("a" in the paper) is the scale of stretching
transformation (see details in the paper).
ApexHeight is the altitude of top of configuration from the solar surface.
It is expected that Radius &lt; ApexHeight &lt; 2*Radius.

NOTE1: Before 08.15.2022 the sign of BStrength was used to set helicity.
The negative sign corresponded to the positive helicity (which was essentially
a bug).

NOTE2:
If you have an outdated parameter file you can convert it to the new
format as follows:
1. Move line for BStrength to have it just below "GL      TypeCme" line
   and add the line setting iHelicity.
2. Move  line for reading Radius just below the line for BStrength.
3. RESCALE the OLD data for BStrength as follows:
   BStrengthNew = 13.1687517342067082*BStrengthOld*Radius**2
4. The old line for reading Distance should be converted to the line for
   reading ApexHeight = Distance + Radius - Stretch - 1
5. Line for reading pBackground should be removed

In addition to the above parameters uCme is read, controlling the speed
of the CME self-similar expansion

!!!!!!!!!!!!!!!!!!!!!!!!TITOV-DEMOULIN!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#CME
T			UseCme
T			DoAddFluxRope
180.0                   LongitudeCme  [deg]
15.0                    LatitudeCme   [deg]
30.0                    OrientationCme[deg]
TD			TypeCme    TD/TITOV-DEMOULIN
+1			iHelicty
0.5			RadiusMajor  [R_s]
0.2			RadiusMinor  [R_s]
0.2			Depth        [R_s]
F			UsePlasmaBeta
1.000E+16               Mass         [g]
readbstrap		TypeBStrap readbstrap/getbstrap/none
5			bStrapping  [Gs]
steady			TypeCharge  none/steady/moving/cancelflux
1.0			BqFraction  [ ]
0.4			qDistance   [R_s]

Version with UsePlasmaBeta=.true.:
...
T			UsePlasmaBeta
PlasmaBeta              0.1               [ ]
5.0e4			EjectaTemperature [K]	
...
steady			TypeCharge  none/steady/moving/cancelflux
5			BStrapping        [Gs]
0.4			qDistance         [R_s]	

version with the flux cancelation
...
cancelflux		TypeCharge  none/steady/moving/cancelflux
5			BqStrapping       [Gs]
0.4			qDistance         [R_s]	
5.0			ChargeUx          [km/s]
!!!!!!!!!!!!!!!!!!!!!!!!TITOV-DEMOULIN!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#CME
T			UseCme
T			DoAddFluxRope
180.0                   LongitudeCme  [deg]
15.0                    LatitudeCme   [deg]
30.0                    OrientationCme[deg]
TD			TypeCme    TD/TITOV-DEMOULIN
10.0			BcTubeDim    [Gs]
0.5			RadiusMajor  [R_s]
0.2			RadiusMinor  [R_s]
0.2			Depth        [R_s]
F			UsePlasmaBeta
1.000E+16               Mass         [g]
readbstrap		TypeBStrap readbstrap/getbstrap/none
5			bStrapping  [Gs]
steady			TypeCharge  none/steady/moving/cancelflux
1.0			BqFraction  [ ]
0.4			qDistance   [R_s]

Version with UsePlasmaBeta=.true.:
...
T			UsePlasmaBeta
PlasmaBeta              0.1               [ ]
5.0e4			EjectaTemperature [K]	
...
steady			TypeCharge  none/steady/moving/cancelflux
5			BStrapping        [Gs]
0.4			qDistance         [R_s]	

BcTubeDim, in Gauss, is a magnetic field at the center of totoid, which field 
is created by the current inside the toroidal filament. RadiusMajor and 
RadiusMinor are characteristics of the toroid shape. Depth characterizes 
the toroid center location below the photosphere level. Mass in kilograms 
is an approximate integral of density over the volume of current filament.

To convert an outdated parameter file, with the Current in [A] and spatial 
scales in [m], one can convert it to the standard format as follows:

1. RESCALE the data for Current[A] as follows:
   BcTubeDim[Gs] = 2.0E-03*cPi*Current[A]/RadiusMajor[m]

2. Convert all spatial scales (RadiusMajor, RadiusMinor, Depth) in meters 
   into those is R_S:
   Scale[R_s] = Scale[m]/6.96E+08
   Or, if the scales are in megameters, the formulae are:
   Scale[R_s] = Scale[Mm]/6.96E+02

For TD configuration,  magnetic field at the center of configuration is 
always parallel, while the starpping field is anti-parallel, to the x-axis. 
Phi-conponent of the toroidal current is positive. However, the sign of 
the field toroidal component may be both positive and negative, corresponding 
to the positive and negative helicity. To set the negative helicity, the 
input parameter, BcTube, should be negative. This choice affects only the 
sign of helicity, but not the direction of the poloidal magnetic field 
components, including the nagnetic field at the center of configuration.

!!!!!!!!!!! TITOV-DEMOULIN version 2022 (Grad-Shafranov solution) !!!!!!!!!!!!
#CME
T			UseCme
T			DoAddFluxRope
180.0                   LongitudeCme  [deg]
15.0                    LatitudeCme   [deg]
30.0                    OrientationCme[deg]
TD			TypeCme    TD/TITOV-DEMOULIN
10.0			BcTubeDim    [Gs]
0.5			RadiusMajor  [R_s]
0.2			RadiusMinor  [R_s]
0.2			Depth        [R_s]
PlasmaBeta              0.1           [ ]
5.0e4			EjectaTemperature [K]
readbstrap		TypeBStrap readbstrap/getbstrap/none
5			bStrapping  [Gs]
steady			TypeCharge  none/steady/moving/cancelflux
1.0			BqFraction  [ ]
0.4			qDistance   [R_s]

TypeCME=BREAKOUT should be described by Bart van der Holst. Please ask
him for a description.

TypeCME=SPHEROMAK should be described by Igor Sokolov. Please ask
him for a description.

There is no CME by default.
</command>

<command name="CMETIME">
  <parameter name="tStartCme" type="real" min="-1.0" default="-1.0" />

#CMETIME
0.0			tStartCme [sec]

The tStartCme variable contains the time in seconds when the flux-rope
is added via the #CME command and is relative to the initial start time.
It is saved into the restart header file, so if the CME run is restarted
with DoAddFluxRope set to F and the tDecayCme is positive the CME related
boundary conditions continue to decay to zero in tDecayCme time.
</command>
</commandgroup>

<commandgroup name="AMR PARAMETERS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!  AMR PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="AMRINITPHYSICS" if="$_IsFirstSession">
  <parameter name="nRefineLevelIC" type="integer" min="0" default="0" />
#AMRINITPHYSICS
3			nRefineLevelIC

Defines number of physics (initial condition) based AMR-s AFTER the
geometry based grid refinement was finished.
Only useful if the initial condition has a non-trivial analytic form.
</command>

<command name="REGION" alias="AMRREGION" multiple="T">
  <set name="RotateArea" value="0"/>
  <set name="StretchArea" value="0"/>
  <set name="TaperArea" value="0"/>
  <parameter name="NameRegion" type="string"/>
  <parameter name="StringShape" type="strings" case="lower" min="1" max="4">
    <part name="NameShape" type="string" input="select" required="T">
      <option name="box"			/>
      <option name="box_gen"			/>
      <option name="brick"			/>
      <option name="brick_gen"			/>
      <option name="brick0"			/>
      <option name="brick_gen0"			/>
      <option name="conex"			/>
      <option name="conex0"			/>
      <option name="coney"			/>
      <option name="coney0"			/>
      <option name="conez"			/>
      <option name="conez0"			/>
      <option name="cylinderx"			/>
      <option name="cylinderx0"			/>
      <option name="cylindery"			/>
      <option name="cylindery0"			/>
      <option name="cylinderz"			/>
      <option name="cylinderz0"			/>
      <option name="doubleconex"		/>
      <option name="doubleconex0"		/>
      <option name="doubleconey"		/>
      <option name="doubleconey0"		/>
      <option name="doubleconez"		/>
      <option name="doubleconez0"		/>
      <option name="funnelx"			/>
      <option name="funnelx0"			/>
      <option name="funnely"			/>
      <option name="funnely0"			/>
      <option name="funnelz"			/>
      <option name="funnelz0"			/>
      <option name="paraboloidx"		/>
      <option name="paraboloidx0"		/>
      <option name="paraboloidy"		/>
      <option name="paraboloidy0"		/>
      <option name="paraboloidz"		/>
      <option name="paraboloidz0"		/>
      <option name="ringx"			/>
      <option name="ringx0"			/>
      <option name="ringy"			/>
      <option name="ringy0"			/>
      <option name="ringz"			/>
      <option name="ringz0"			/>
      <option name="shell"			/>
      <option name="shell0"			/>
      <option name="sphere"			/>
      <option name="sphere0"			/>
      <option name="user"			/>
    </part>
    <part name="StretchArea" type="string" input="select"
	  required="F"
	  if="$NameShape !~ /box|brick|user/ and $nJ!=1">
      <option name="stretched" />
    </part>
    <part name="RotateArea" type="string" input="select"
	  required="F"
	  if="$NameShape !~ /user/ and $nJ!=1">
      <option name="rotated" />
    </part>
    <part name="TaperArea" type="string" input="select"
	  required="F"
	  if="$NameShape !~ /user/ and $_command =~ /REGION/">
      <option name="tapered" />
    </part>
    <part name="TypeCoord" type="string" input="select"
	  required="F">
      <option name="hgr" />
      <option name="hgi" />
      <option name="gse" />
    </part>
    <part name="NameSat" type="string" input="select"
	  required="F">
      <option name="sat:earth" />
      <option name="sat:mars" />
      <option name="sat:sta" />
      <option name="sat:stb" />
    </part>
  </parameter>
  <if expr="$NameShape !~ /box|user|0/">
    <parameter name="xPosition" type="real" default="0"/>
    <parameter name="yPosition" type="real" default="0"
	       if="$nJ!=1"/>
    <parameter name="zPosition" type="real" default="0"
	       if="$nK!=1"/>
  </if>
  <if expr="$NameShape =~ /box\b/">
    <parameter name="xMinBox" type="real" />
    <parameter name="yMinBox" type="real" if="$nJ != 1"/>
    <parameter name="zMinBox" type="real" if="$nK != 1"/>
    <parameter name="xMaxBox" type="real" />
    <parameter name="yMaxBox" type="real" if="$nJ != 1"/>
    <parameter name="zMaxBox" type="real" if="$nK != 1"/>
  </if>
  <if expr="$NameShape =~ /box_gen/">
    <parameter name="Coord1MinBox" type="real" />
    <parameter name="Coord2MinBox" type="real" if="$nJ != 1"/>
    <parameter name="Coord3MinBox" type="real" if="$nK != 1"/>
    <parameter name="Coord1MaxBox" type="real" />
    <parameter name="Coord2MaxBox" type="real" if="$nJ != 1"/>
    <parameter name="Coord3MaxBox" type="real" if="$nK != 1"/>
  </if>
  <if expr="$NameShape =~ /brick/">
    <parameter name="xSizeBrick" type="real" min="0" />
    <parameter name="ySizeBrick" type="real" min="0" if="$nJ!=1"/>
    <parameter name="zSizeBrick" type="real" min="0" if="$nK!=1"/>
  </if>
  <if expr="$NameShape =~ /sphere|shell/">
    <parameter name="RadiusInner" type="real" min="0"
	       if="$NameShape =~ /shell/"/>
    <parameter name="Radius"  type="real" min="0+$RadiusInner"/>
    <parameter name="RadiusY" type="real" min="0"
	       if="$StretchArea=~/stretched/ and $nJ!=1"/>
    <parameter name="RadiusZ" type="real" min="0"
	       if="$StretchArea=~/stretched/ and $nK!=1"/>
  </if>
  <if expr="$NameShape =~ /cone|cylinder|ring|funnel|paraboloid/">
    <parameter name="Height"     type="real" />
    <parameter name="RadiusInner" type="real" min="0"
	       if="$NameShape =~ /ring/"/>
    <parameter name="RadiusStart" type="real" min="0"
	       if="$NameShape =~ /funnel/"/>
    <parameter name="Radius"     type="real" min="0+$RadiusInner"/>
    <parameter name="RadiusPerp" type="real" min="0"
	       if="$StretchArea=~/stretched/ and $nK!=1"/>
  </if>
  <if expr="$TaperArea =~ /tapered/">
    <parameter name="Taper" type="real" min="0" default="0"/>
  </if>
  <if expr="$RotateArea =~ /rotated/">
    <parameter name="xRotate" type="real" min="-360" max="360"
	       default="0" if="$nK!=1"/>
    <parameter name="yRotate" type="real" min="-360" max="360"
	       default="0" if="$nK!=1"/>
    <parameter name="zRotate" type="real" min="-360" max="360"
	       default="0" if="$nJ!=1"/>
  </if>

#REGION
region1			NameRegion
box			StringShape
-64.0			xMinBox
-16.0			yMinBox
-16.0			zMinBox
-32.0			xMaxBox
 16.0			yMaxBox
  0.0			zMaxBox

#REGION
region2			NameRegion
brick			StringShape
-48.0			xPosition
  0.0			yPosition
 -8.0			zPosition
 32.0			xSizeBrick
 32.0			ySizeBrick
 16.0			zSizeBrick

#REGION
ellipsoid		NameRegion
sphere stretched	StringShape
-10.0			xPosition
 10.0			yPosition
  0.0			zPosition
 20.0			Radius
 30.0			RadiusY  (only read if stretched)
 20.0			RadiusZ  (only read if stretched)

#REGION
region3			NameRegion
shell0			StringShape
3.5			Radius1
4.5			Radius2

#REGION
region5			NameRegion
cylinderx stretched tapered
-30.0			xPosition
  0.0			yPosition
  0.0			zPosition
 60.0			Length
 20.0			Radius
 25.0			RadiusPerp (only read if stretched)
  5.0			Taper      (only read if tapered)

#REGION
region6			NameRegion
ringz0 rotated		StringShape
  5.0			Height
 20.0			Radius1
 25.0			Radius2
 10.0			xRotate   (only read if rotated)
 10.0			yRotate   (only read if rotated in 3D)
  0.0			zRotate   (only read if rotated in 3D)

#REGION
region7			NameRegion
conex stretched		StringShape
-30.0			xPosition
  0.0			yPosition
  0.0			zPosition
 -5.0			Height (base is at xPosition-5)
 20.0			Radius
 30.0			RadiusPerp (only read if stretched)

#REGION
region8			NameRegion
funnelx stretched	StringShape
 10.0			xPosition
 20.0			yPosition
 30.0			zPosition
 45.0			Height
 10.0			RadiusStart
 20.0			Radius
 25.0			RadiusPerp (only read if stretched)

#REGION
region9			NameRegion
doubleconez0 tapered	StringShape
100.0			Height
 20.0			Radius
  2.0			Taper

#REGION
region10		NameRegion
box weight tapered	StringShape
-30.0			xMinBox
-30.0			yMinBox
-2.0			xMaxBox
30.0			yMaxBox
2.0			Taper
2.0			Weight


#REGION
magnetosphere		NameRegion
paraboloidx stretched	StringShape
 10.0			xPosition
  0.0			yPosition
  0.0			zPosition
-100.0			Height
  30.0			Radius
  20.0			RadiusPerp

#REGION
conemars                NameRegion
conex0 sat:mars          StringShape
350                     Height
100                     Radius

#REGION
myregion		NameRegion
user			StringShape

The #REGION comand allows making a library of areas in the simulation
domain identified by a unique NameRegion to be used in other commands
(e.g. #AMRCRITERIALEVEL, #AMRCRITERIARESOLUTION, #HALLREGION) to
define where some action (e.g. grid refinement) should be performed.
In those commands the regions can be combined with + and - signs to
form more complex shapes. For example

+dayside +tail -nearearth -nearaxis

The + sign means that a region is "added" (more formally, take the
union of the regions).  The - sign means that the region is excluded.
The best way to list multiple regions is to start with the + signs
and finish with the - signs. If all regions have - signs, for example

-nearearth -nearaxis

then the interpretation is that they are excluded from the whole domain.

The StringShape parameter defines the shape of the region with the possible
options. The basic shape names are the following:
'box', 'box_gen', 'brick', 'brick_gen', 'conex', 'cylinderx',
'doubleconex', 'funnelx', 'paraboloidx', 'ringx', 'shell', 'sphere',
and 'user'. The names that end with an 'x' indicate the orientation
of the symmetry axis. These have alternative versions ending with 'y' and 'z',
for example 'coney' and 'conez'.
Most of these names can be followed by the optional '0', 'stretched',
'tapered' and 'rotated' strings as discussed below.

The area 'box' is a box aligned with the X, Y and Z axes,
and it is given with the coordinates
of two diagonally opposite corners. The area 'brick' has the same shape
as 'box', but it is defined with the center of the brick and the
size of the brick. The 'box_gen' and 'brick_gen' areas can be used
for non-Cartesian grids to define a box in the generalized coordinates.
For example a sphere around the origin can be described as a box in
generalized coordinates with radius going from 0 to R,
phi going from 0 to 360 degrees and latitude going from -90 to +90 degrees.
Note that angles are given in degrees, and radius is given even if the
generalized coordinates use its logarithm.

The area 'sphere' is a sphere around an arbitrary point,
which is defined with the center point and the radius of the sphere.
The area 'shell' consists of the volume between two concentric spherical
surfaces, which is given with the center point and the two radii.
The area 'cylinderx' is a cylinder with an axis parallel with the X axis,
and it is given with the center, the length of the axis and the radius,
The areas 'cylindery' and 'cylinderz' are cylinders parallel with the
Y and Z axes, respectively, and are defined analogously as 'cylinderx'.
The area 'ringx', 'ringy' and 'ringz' are the volumes between
two cylindrical surfaces parallel with the X, Y and Z axes, respectively.
The ring area is given with the center, the height and the two radii.
The 'conex', 'doubleconex' and 'paraboloidx' are all aligned with the X axis
and are described by the position of the tip, the height and the radius.
The 'funnelx' is a cone with its tip chopped off. It is described by
the position of the center of the starting circle, its height, the starting
radius and the ending radius. The sign of the height specifies
the orientation of the shape along its symmetry axis.
Note that all these round shapes can be made elliptical with the
"stretched" option (see below).

If the area name contains the number '0', the center/tip is taken to be at the
origin and the Position coordinates are not read. Note that the areas 'box'
and 'box_gen' are defined with the corners so the '0' cannot be used for these.

If the word 'stretched' is added after the area name, the shape can be
stretched in all directions. This allows making
an ellipsoid from a sphere, or an elliptical slab from a cylinder.

It the word 'tapered' is used in StringShape, the Taper parameter
is read and the shape is surrounded by a tapering region of this
width. This is useful when the region is used as a switch with
a continuous transition between the inside and outside, see for example
the #HALLREGION command.

If the word 'rotated' is added after the area name, the area can be
rotated around the Z axis in 2D simulation, and by 3 angles around
the X, Y and Z axes (in this order) in 3D simulations. These are the
Tait-Bryan angles (yaw, pitch and roll) corresponding the X-Y-Z
extrinsic rotations in a fixed coordinate system or Z-Y-X
intrinsic rotations in a rotating coordinate system.

If the word 'weight' is used in StringShape, the parameter Weight 
is read. The weight is the Hall factor when this region 
is used by the #HALLREGION command. 

If NameShape starts with 'user', the shape is defined by the subroutine
user_specify_region. Any parameters for the user region should be read
in the user section of the PARAM.in file.

By default there are no "regions" defined.
</command>

<command name="GRIDRESOLUTION" alias="GRIDLEVEL" multiple="T">
  <set name="RotateArea" value="0"/>
  <set name="StretchArea" value="0"/>
  <parameter name="Resolution" type="real" min="0"
	     if="$_command =~ /RESOLUTION/" />
  <parameter name="nLevel" type="integer" min="0" max="30"
	     if="$_command =~ /LEVEL/" />
  <parameter name="StringShape" type="strings" case="lower"
	     min="1" max="3">
    <part name="NameShape" type="string" input="select"
	  required="T">
      <option name="initial"			/>
      <option name="all"			/>
      <option name="box"			/>
      <option name="box_gen"			/>
      <option name="brick"			/>
      <option name="brick_gen"			/>
      <option name="brick0"			/>
      <option name="brick_gen0"			/>
      <option name="conex"			/>
      <option name="conex0"			/>
      <option name="coney"			/>
      <option name="coney0"			/>
      <option name="conez"			/>
      <option name="conez0"			/>
      <option name="cylinderx"			/>
      <option name="cylinderx0"			/>
      <option name="cylindery"			/>
      <option name="cylindery0"			/>
      <option name="cylinderz"			/>
      <option name="cylinderz0"			/>
      <option name="doubleconex"		/>
      <option name="doubleconex0"		/>
      <option name="doubleconey"		/>
      <option name="doubleconey0"		/>
      <option name="doubleconez"		/>
      <option name="doubleconez0"		/>
      <option name="funnelx"			/>
      <option name="funnelx0"			/>
      <option name="funnely"			/>
      <option name="funnely0"			/>
      <option name="funnelz"			/>
      <option name="funnelz0"			/>
      <option name="paraboloidx"		/>
      <option name="paraboloidx0"		/>
      <option name="paraboloidy"		/>
      <option name="paraboloidy0"		/>
      <option name="paraboloidz"		/>
      <option name="paraboloidz0"		/>
      <option name="ringx"			/>
      <option name="ringx0"			/>
      <option name="ringy"			/>
      <option name="ringy0"			/>
      <option name="ringz"			/>
      <option name="ringz0"			/>
      <option name="shell"			/>
      <option name="shell0"			/>
      <option name="sphere"			/>
      <option name="sphere0"			/>
      <option name="user"			/>
    </part>
    <part name="StretchArea" type="string" input="select" required="F"
	  if="$NameShape !~ /box|brick|user|init/ and $nJ!=1">
      <option name="stretched" />
    </part>
    <part name="RotateArea" type="string" input="select" required="F"
	  if="$NameShape !~ /user|init/ and $nJ!=1">
      <option name="rotated" />
    </part>
  </parameter>
  <if expr="$NameShape !~ /box|user|all|init|0/">
    <parameter name="xPosition" type="real" default="0"/>
    <parameter name="yPosition" type="real" default="0"
	       if="$nJ!=1"/>
    <parameter name="zPosition" type="real" default="0"
	       if="$nK!=1"/>
  </if>
  <if expr="$NameShape =~ /box\b/">
    <parameter name="xMinBox" type="real" />
    <parameter name="yMinBox" type="real" if="$nJ != 1"/>
    <parameter name="zMinBox" type="real" if="$nK != 1"/>
    <parameter name="xMaxBox" type="real" />
    <parameter name="yMaxBox" type="real" if="$nJ != 1"/>
    <parameter name="zMaxBox" type="real" if="$nK != 1"/>
  </if>
  <if expr="$NameShape =~ /box_gen/">
    <parameter name="Coord1MinBox" type="real" />
    <parameter name="Coord2MinBox" type="real" if="$nJ != 1"/>
    <parameter name="Coord3MinBox" type="real" if="$nK != 1"/>
    <parameter name="Coord1MaxBox" type="real" />
    <parameter name="Coord2MaxBox" type="real" if="$nJ != 1"/>
    <parameter name="Coord3MaxBox" type="real" if="$nK != 1"/>
  </if>
  <if expr="$NameShape =~ /brick/">
    <parameter name="xSizeBrick" type="real" min="0" />
    <parameter name="ySizeBrick" type="real" min="0" if="$nJ!=1"/>
    <parameter name="zSizeBrick" type="real" min="0" if="$nK!=1"/>
  </if>
  <if expr="$NameShape =~ /sphere|shell/">
    <parameter name="RadiusInner" type="real" min="0"
	       if="$NameShape =~ /shell/"/>
    <parameter name="Radius"  type="real" min="0"/>
    <parameter name="RadiusY" type="real" min="0"
	       if="$StretchArea=~/stretched/ and $nJ!=1"/>
    <parameter name="RadiusZ" type="real" min="0"
	       if="$StretchArea=~/stretched/ and $nK!=1"/>
  </if>
  <if expr="$NameShape =~ /cone|cylinder|ring|funnel|paraboloid/">
    <parameter name="Height"     type="real" min="0" />
    <parameter name="RadiusInner" type="real" min="0"
	       if="$NameShape =~ /ring/"/>
    <parameter name="RadiusStart" type="real" min="0"
	       if="$NameShape =~ /funnel/"/>
    <parameter name="Radius"     type="real" min="0" />
    <parameter name="RadiusPerp" type="real" min="0"
	       if="$StretchArea=~/stretched/ and $nK!=1"/>
  </if>
  <if expr="$RotateArea =~ /rotated/">
    <parameter name="xRotate" type="real" min="-360" max="360" default="0"/>
    <parameter name="yRotate" type="real" min="-360" max="360" default="0"
	       if="$nK!=1"/>
    <parameter name="zRotate" type="real" min="-360" max="360" default="0"
	       if="$nK!=1"/>
  </if>

#GRIDRESOLUTION
2.0			Resolution
initial			StringShape

#GRIDLEVEL
3			nLevel
all			StringShape

#GRIDLEVEL
4			nLevel
box			StringShape
-64.0			xMinBox
-16.0			yMinBox
-16.0			zMinBox
-32.0			xMaxBox
 16.0			yMaxBox
  0.0			zMaxBox

#GRIDLEVEL
4			nLevel
brick			StringShape
-48.0			xPosition
  0.0			yPosition
 -8.0			zPosition
 32.0			xSizeBrick
 32.0			ySizeBrick
 16.0			zSizeBrick

#GRIDRESOLUTION
1/8			Resolution
shell0			StringShape
3.5			RadiusInner
4.5			Radius

#GRIDRESOLUTION
0.5			Resolution
sphere			StringShape
-10.0			xPosition
 10.0			yPosition
  0.0			zPosition
 20.0			Radius

#GRIDRESOLUTION
1/8			Resolution
cylinderx		StringShape
-30.0			xPosition
  0.0			yPosition
  0.0			zPosition
 60.0			Height
 20.0			Radius

#GRIDRESOLUTION
1/8			Resolution
ringz0 rotated		StringShape
  5.0			Height
 20.0			RadiusInner
 25.0			Radius
 10.0			xRotate
 10.0			yRotate
  0.0			zRotate

#GRIDRESOLUTION
1/4			Resolution
paraboloidx0 stretched	StringShape
30.0			Height
10.0			Radius
12.0			RadiusPerp

#GRIDRESOLUTION
1/8			Resolution
user			StringShape

The #GRIDRESOLUTION and #GRIDLEVEL commands allow to set the desired (!)
grid resolution or refinement level, respectively, in a given area.
This grid resolution is only realized if either the
StringShape='initial' resolution is set to an equal or finer
refinement than the desired resolution, for example

#GRIDRESOLUTION
1/8			Resolution
initial			StringShape

or by applying adaptive mesh refinement during the run (see the #DOAMR
command).

The Resolution parameter of the #GRIRDESOLUTION command
usually refers to the size of the cell in the first direction (Dx or Dr),
but for logarithmic/stretched radial coordinate (see #GRIDGEOMETRY),
it refers to the resolution in the Phi coordinate in degrees.
Note that this definition of resolution is different from that used in the
#AMRCRITERIARESOLUTION command for non-Cartesian grids.

Normally it is best to use the #GRIDRESOLUTION command to define the desired
grid as it describes the resolution in physical units, so it is independent
of the number of the size of the domain and the number of root blocks.
The alternative #GRIDLEVEL command can be useful for simple numerical
tests, where an algorithm is tested on anon-uniform grid. For this command
the nLevel parameter is an integer with level 0 meaning no refinement relative
to the root block, while level N is a refinement by 2 to the power N.

Note that the #REGION commands in combination with the #AMRCRITERIALEVEL
and #AMRCRITERIARESOLUTION commands allow even more flexibility in controlling
the grid adaptation, but the initial resolution/level still has to be set
by this command. However, if #AMRCRITERIALEVEL/AMRCRITERIARESOLUTION is 
specified, the user should not use #GRIDLEVEL/#GRIDRESOLUTION to specify
any StringShape except 'initial', otherwise the code will just crash.

If StringShape is set to 'initial', it determines the number of grid
adaptations used to initialize the grid. The grid adaptations are done
according to the other #GRIDLEVEL, #GRIDESOLUTION commands.  {\bf The
default is no refinement initially, which means that the grid is
uniform at the beginning, and it is refined during the run according
to the #AMR or #DOAMR commands. This means that one has to set the
initial refinement level to get a non-uniform grid from the
beginning.}

The StringShape 'all' refers to the whole computational domain, and it can be
used to set the overall minimum resolution.

For other values of StringShape, the command specifies the shape of the area.
where the blocks are to be refined. See the #REGION command for a description
of these parameters. Note that "tapering" can only be used with the
#REGION command.

If the desired grid resolution is finer than the initial resolution,
then initially the grid will be refined to the initial resolution
only, but the area will be further refined in subsequent pre-specified
adaptive mesh refinements (AMRs) during the run (see the #AMR
command). Once the resolution reaches the desired level, the AMR-s
will not do further refinement. If a grid block is covered by more
than one areas, the area with the finest resolution determines the
desired grid resolution.

All computational blocks that intersect the area and have a coarser
resolution than the resolution set for the area are selected for refinement.

The default is a uniform grid.
</command>

<command name="AMRLEVELS">
  <parameter name="MinBlockLevel" type="integer" min="-1" default="0" />
  <parameter name="MaxBlockLevel" type="integer" min="-1" default="99" />

#AMRLEVELS
0			MinBlockLevel
99			MaxBlockLevel

Set the minimum/maximum levels that can be affected by AMR.  The usage is as
follows:
\begin{verbatim}
MinBlockLevel .ge.0 Cells can be coarsened up to the listed level but not
                      further.
MinBlockLevel .lt.0 The current grid is ``frozen'' for coarsening such that
                      blocks are not allowed to be coarsened to a size
                      larger than their current one.
MaxBlockLevel .ge.0 Any cell at a level greater than or equal to
                      MaxBlockLevel is unaffected by AMR (cannot be coarsened
                      or refined).
MaxBlockLevel .lt.0 The current grid is ``frozen'' for refinement such that
                      blocks are not allowed to be refined to a size
                      smaller than their current one.
\end{verbatim}
This command has no effect when DoAutoRefine is .false. in the #AMR command.

Note that the user can set either #AMRLEVELS or #AMRRESOLUTION but not
both.  If both are set, the final one in the session will set the values
for AMR.
</command>

<command name="AMRRESOLUTION">
  <parameter name="DxCellMin" type="real" min="-1" default="0"     />
  <parameter name="DxCellMax" type="real" min="-1" default="99999" />

#AMRRESOLUTION
0.			DxCellMin
99999.			DxCellMax

Serves the same function as AMRLEVELS. The DxCellMin and DxCellMmax
parameters are converted into MinBlockLevel and MaxBlockLevel
when they are read.
Note that MinBlockLevel corresponds to DxCellMax and MaxBlockLevel
corresponds to DxCellMin.  See details above.

This command has no effect when DoAutoRefine is .false. in the #AMR command.

Note that the user can set either #AMRLEVELS or #AMRRESOLUTION but not
both.  If both are set, the final one in the session will set the values
for AMR.
</command>

<command name="DOAMR">
  <parameter name="DoAmr" type="logical" default="F"/>
  <if expr="$DoAmr">
    <parameter name="DnAmr" type="integer" min="-1" default="-1" />
    <parameter name="DtAmr" type="real" min="-1.0" default="-1.0" />
    <parameter name="IsStrictAmr" type="logical" default="T" />
  </if>
#DOAMR
T                       DoAmr (the rest is only read if true)
1                       DnAmr
-1.0                    DtAmr
T                       IsStrictAmr

DoAmr is telling if you do adaptive mesh refinement (AMR) during the
simulation every DnAmr step or DtAmr intervals.  For both DtAmr and
DnAmr negative values mean that no AMR is performed based on that
condition. If both values are positive then DnAmr is used in steady
state mode and DtAmr is used in time accurate mode. If DtAmr is
negative then DnAmr (has to be positive) is used always.  If
IsStrictAmr is true, we demand that the AMR is fully performed. If the
AMR would require too many grid blocks, the code stops with an error
message.  If IsStrictAmr is false, the code will do a partial AMR
allowed by the maximum of available blocks and continue running.  For
pure geometry based AMR the IsStrictAmr=F will cause the code to skip
the complete AMR if there are not enough blocks.

Defaults are DoAmr false and IsStrictAmr true.
</command>

<command name="AMRLIMIT">
  <parameter name="PercentCoarsen" type="real" min="0"    default="0" />
  <parameter name="PercentRefine" type="real" min="0"     default="0" />
  <parameter name="MaxBlockAll" type="integer" min="1" />
  <parameter name="DiffCriteriaLevel" type="real" min="0" default="1e-8" />
#AMRLIMIT
40.                     PercentCoarsen
30.                     PercentRefine
999999                  MaxBlockAll
1e-8                    DiffCriteriaLevel

This is the obsolete way of doing AMR. All users are advised to use
AMR where the grid depends on geometry and solution only, but not
on the number of blocks. The #AMRCRITERIALEVEL and #AMRCRITERIARESOLUTION
and #REGION commands provide all the needed functionality.

This command sets a desired percentage of blocks to be coarsened
(PercentCoarsen) and refined (PercentRefine). In addition, the
total number of grid blocks can be limited with MaxBlockAll.
The criteria will be given by #AMRCRITERIA or #AMRCRITERIALEVEL.
To maintain symmetry of the solution, it is useful to treat blocks
with similar criteria value to be coarsened and refined together.
The DiffCriteriaLevel gives the tolerance so that blocks with
criteria values closer than DiffCriteriaLevel
will be refined or coarsened together.

The default is to refine and coarsen blocks based on the criteria
without any percentage limits.
</command>

<command name="AMR">
  <parameter name="DnRefine" type="integer" min="-1" default="-1" />
  <if expr="$DnRefine &gt; 0">
    <parameter name="DoAutoRefine" type="logical" default="F" />
    <if expr="$DoAutoRefine">
      <parameter name="PercentCoarsen" type="real"
		 min="0" max="100" default="20" />
      <parameter name="PercentRefine" type="real"
		 min="0" max="100" default="20" />
      <parameter name="MaxTotalBlocks" type="integer"
		 min="1" default="99999" />
    </if>
  </if>
#AMR
2001			DnRefine
T			DoAutoRefine   ! read if DnRefine is positive
0.			PercentCoarsen ! read if DoAutoRefine is true
0.			PercentRefine  ! read if DoAutoRefine is true
99999			MaxTotalBlocks ! read if DoAutoRefine is true

This command is kept for backwards compatibility. The #DOAMR and #AMRLIMIT
commands offer more control.

The DnRefine parameter determines the frequency of adaptive mesh refinements
in terms of total steps nStep.

When DoAutoRefine is false, the grid is refined by one more level
based on the areas and resolutions defined by the
#GRIDLEVEL and #GRIDRESOLUTION commands.
If the number of blocks is not sufficient for this pre-specified refinement,
the code stops with an error.

When DoAutoRefine is true, the grid is refined or coarsened
based on the criteria given in the #AMRCRITERIA command.
The number of blocks to be refined or coarsened are determined by
the PercentRefine and PercentCoarsen parameters. These percentages
are approximate only, because the constraints of the block adaptive
grid may result in more or fewer blocks than prescribed.
The total number of blocks will not exceed the smaller of the
MaxTotalBlocks parameter and the total number of blocks available on all
the PE-s (which is determined by the number of PE-s and
the MaxBlocks parameter in ModSize.f90).

Default for DnRefine is -1, i.e. no run time refinement.
</command>

<command name="AMRCRITERIA">
  <parameter name="nRefineCrit" type="integer" min="0" max="3" default="0" />
  <for from="1" to="$nRefineCrit">
    <parameter name="TypeRefine" type="string" case="lower" input="select">
      <option name="grad P"		value="gradp"        />
      <option name="grad log(Rho)"	value="gradlogrho"   />
      <option name="grad log(p)" 	value="gradlogp"     />
      <option name="p jump ratio"       value="pjumpratio"   />
      <option name="current"            value="j"            />
      <option name="current squared"    value="j2"           />
      <option name="current sheet"      value="currentsheet" />
      <option name="-div U"		value="-divu"	     />
      <option name="-div U*dx"		value="-divudx"	     />
      <option name="Transient"          value="transient"    />
      <option name="User defined"       value="user"         />
    </parameter>
    <parameter name="CoarsenLimit" type="real" />
    <parameter name="RefineLimit" type="real" min="$CoarsenLimit"/>
    <if expr="$TypeRefine=~/transient/">
      <parameter name="TypeTransient" type="string" case="lower"
		 input="select">
	<option name="Rho_dot"   value="rho_dot" default="T"/>
	<option name="P_dot"     value="p_dot"/>
	<option name="T_dot"     value="t_dot"/>
	<option name="RhoU_dot"  value="rhou_dot"/>
	<option name="Rho_2nd_1" value="rho_2nd_1"/>
	<option name="Rho_2nd_2" value="rho_2nd_2"/>
      </parameter>
    </if>
  </for>
#AMRCRITERIA
3			nRefineCrit (1 to3)
gradP			TypeRefine
0.2			CoarsenLimit
0.8			RefineLimit
user			TypeRefine
0.5			CoarsenLimit
0.5			RefineLimit
Transient		TypeRefine
Rho_dot			TypeTransient ! Only if 'Transient' or 'transient'

Note: "#AMRCRITERIALEVEL" gives even more control.

This command defines the criteria to select blocks for refinement or
coarsening when the #AMR command is used with DoAutoRefine=T parameter.
Up to 3 criteria can be used. Refinement is done if ANY
of the criteria demand it, and the block can be refined
(a block cannot be refined if the refinement level would exceed
the maximum level or too many blocks would be created.

Coarsening is done if ALL the criteria allow it and the block
can be coarsened (a block cannot be coarsened if the block level
is already at the minimum level, or a neighboring block is finer).

The CoarsenLimit and RefineLimit parameters set the coarsening and
refinement thresholds for the criteria that are given in I/O units.

If nRefineCrit is set to zero, the blocks are not ordered.
This can be used to refine or coarsen
all the blocks limited by the minimum and maximum levels only
(see commands #AMRLEVELS and #AMRRESOLUTION). If nRefineCrit is 1, 2, or 3
then the criteria can be chosen from the following list
(all criteria are based on the maximum over the cells in the grid block):
\begin{verbatim}
  'gradP'		- gradient of pressure
  'gradlogP'		- gradient of log10(P)
  'pjumpratio'          - pmax/pmin in neighboring cells
  'gradlogrho'		- gradient of log10(rho)
  'J'		        - magnitude of current
  'J2'                  - current squared
  'currentsheet'        - current sheet (radial B changes sign)
  '-divU'	        - divergence of velocity times -1
  '-divUdX'	        - divergence of velocity times cell size times -1
  'user'                - criteria defined in the user module
  'transient'           - criteria is defined by the TypeTransient parameter.
\end{verbatim}
The possible choices for TypeTransient:
\begin{verbatim}
  'P_dot'	- relative change of pressure       (dP/dt)/P
  'T_dot'	- relative change of temperature    (dT/dt)/T
  'Rho_dot'	- relative change of density        (drho/dt)/rho
  'RhoU_dot'	- relative change of momentum       (d|rhoU|/dt)/|rhoU|
  'B_dot'	- relative change of magnetic field (d|B|/dt)/|B|
  'meanUB'      - max[(d|rhoU|/dt)/|rhoU|] * max[(d|B|/dt)/|B|]
  'Rho_2nd_1'   - (|d2Rho/dx2| + |d2Rho/dy2| + |d2Rho/dz2|)/rho
  'Rho_2nd_2'   - (|d2Rho/dx2  +  d2Rho/dy2  +  d2Rho/dz2|)/rho
\end{verbatim}

By default there are no criteria, so all blocks are refined or coarsened
together.
</command>

<command name="AMRCRITERIALEVEL"
	 alias="AMRCRITERIARESOLUTION,AMRCRITERIACELLSIZE">
  <parameter name="nRefineCrit" type="integer" min="0" default="0" />
  <for from="1" to="$nRefineCrit">
    <parameter name="StringRefine" type="string" length="$lLine" case="lower"/>
    <if expr="$StringRefine=~/^level/">
      <parameter name="RefineTo"    type="integer" min="0" />
      <parameter name="CoarsenFrom" type="integer" min="$RefineTo" />
    </if>
    <if expr="$StringRefine=~/^(dx|dr|dphi)/">
      <parameter name="RefineTo"      type="real"  min="0" />
      <parameter name="CoarsenFrom"   type="real"  min="0" max="$RefineTo"/>
    </if>
    <if expr="$StringRefine!~/^(level|dx|dr|dphi)/">
      <parameter name="CoarsenLimit" type="real" />
      <parameter name="RefineLimit"  type="real" min="$CoarsenLimit" />
      <parameter name="MaxLevel" type="integer" min="0"
		 if="$_command=~/LEVEL/" />
      <parameter name="MaxResolution" type="real" min="0"
		 if="$_command=~/RESOLUTION|CELLSIZE/" />
    </if>
  </for>

#AMRCRITERIALEVEL
5                       nCriteria
J2 +tail -nearbody      TypeCriteria
0.1                     CoarsenLimit
0.75                    RefineLimit
1                       MaxLevel
J2 +tail -nearbody      TypeCriteria
1.0			CoarsenLimit
2.0			RefineLimit
2			MaxLevel
level                   TypeCriteria
2                       RefineTo
3                       CoarsenFrom
dx +nearbody            TypeCriteria
0.5                     RefineTo
0.25                    CoarsenFrom
transient P_dot		TypeCriteria
1.0	  		CoarsenLimit
2.0			RefineLimit
1			MaxLevel
T                       UseSunEarth   ! Only if there are any 'transient' crit
0.00E+00                xEarth        ! Only if UseSunEarth is true
2.56E+02                yEarth        ! Only if UseSunEarth is true
0.00E+00                zEarth        ! Only if UseSunEarth is true
5.00E-01                InvD2Ray      ! Only if UseSunEarth is true

#AMRCRITERIARESOLUTION
3                       nCriteria
dphi                    TypeCriteria
3.0                     RefineTo
1.5                     CoarsenFrom
dphi Innershell         TypeCriteria
1.5                     RefineTo
0.75                    CoarsenFrom
currentsheet            TypeCriteria
0.5                     CoarsenLimit
0.5                     RefineLimit
1.5                     MaxResolution

#AMRCRITERIACELLSIZE
3                       nCriteria
J2 +tail -nearbody      TypeCriteria
0.1                     CoarsenLimit
0.75                    RefineLimit
0.25                    MaxResolution
J2 +tail -nearbody      TypeCriteria
1.0			CoarsenLimit
2.0			RefineLimit
0.125			MaxResolution
error Bx -nearbody	TypeCriteria
0.025			CoarsenLimit
0.1			RefineLimit
0.5			MaxResolution
1.0e-2                  SmallError    ! Only if there are any 'error' crit

The #AMRCRITERIALEVEL, #AMRCRITERIARESOLUTION or #AMRCRITERIACELLSIZE
command defines the criteria to select blocks for refinement or
coarsening when the #DOAMR command is used with DoAmr=T parameter. In
one session you can only have one #AMRCRITERIALEVEL,
#AMRCRITERIARESOLUTION or #AMRCRITERIACELLSIZE command.
#AMRCRITERIARESOLUTION or #AMRCRITERIACELLSIZE is equvilent with
#AMRCRITERIALEVEL but works with cell size (MaxResolution) instead of
grid level (MaxLevel).

The #AMRCRITERIARESOLUTION command defines the criteria to refine /
coarsen based on the physical cell size in the first dimension (dx/dr)
except for logarithmic or generalized radial coordinate when the size
in the phi direction is used in degrees. Typecriteria ="dx/dr/dphi"
can be used.

The #AMRCRITERIACELLSIZE command defines the criteria to refine /
coarsen based on the maximum length of the cell edges inside a block.
For non-cartesian grid this results in varying AMR level but roughly
uniform cell sizes for a given resolution.  Note that this is
different from the definition used in the #GRIDRESOLUTION command.

The number of criteria is given by the nCriteria parameter.
For each criteria the first parameter TypeCriteria determines its type.
TypeCriteria="level" and "dx/dr/dphi" are geometric criteria,
while any other values (that depend on the solution) are non-geometric.
Up to 3 different types of non-geometric criteria can be used,
but there can be multiple criteria (with different criteria levels
and/or geometric restrictions) for the same non-geometric TypeCriteria.

For the geometric criteria there are two additional
parameters read: RefineTo and CoarsenFrom.
These are given either as grid level (for TypeCriteria="level") or as
grid resolution (for TypeCriteria="dx/dr/dphi"). In the above example the "level"
criteria tries to refine the grid to level 2 (and coarsen from level 3 down
to level 2) everywhere in the computational domain.
The "dx" criteria above tries to refine to a grid resolution 0.5
(and coarsen from 0.25 to 0.5) inside the region
named "nearbody" that has to be defined by the #REGION command.

For non-geometric criteria there are three additional parameters read:
CoarsenLimit, RefineLimit and MaxLevel (for #AMRCRITERIALEVEL)
or MaxResolution (for #AMRCRITERIARESOLUTION, #AMRCRITERIACELLSIZE).
The TypeCriteria determines how the criterion value (a positive real
number in "I/O" units) is calculated. In the above example TypeCriteria="J2"
is the largest value of the current density squared inside the grid block.
The CoarsenLimit and RefineLimit are positive real numbers that
are compared to the criterion value, for every grid block.
If the criterion value is above the RefineLimit then the block will be refined
if it has not yet reached the grid level or grid resolution defined by
the MaxLevel (for #AMRCRITERIALEVEL) or MaxResolution
(for #AMRCRITERIARESOLUTION, #AMRCRITERIACELLSIZE) parameter.
If the criterion value is below the CoarsenLimit then the block is
allowed to get coarsened according to this criterion.

Refinement is done if ANY of the criteria demand it, and the block
can be refined. A block cannot be refined if the refinement level would exceed
the maximum grid level or too many blocks would be created.

Coarsening is done if ALL the criteria allow it and the block
can be coarsened. A block cannot be coarsened if the block level
is already at the minimum level or it has a neighbor block that is
and remains finer.

By default the AMR criteria are applied in the whole simulation domain.
This can be limited to a certain area by adding +REGIONNAME and -REGIONNAME
modifiers to the end of the TypeCriteria string. The unique REGIONNAME names
have to be defined in the #REGION command(s), where the definition
of the region is given (for example a sphere, or a box).
See the #REGION command for a description of how to combine multiple regions.

TypeCriteria can be chosen from the following list:
\begin{verbatim}
  'dx'                  - refinment based on (max) cell size in a block
  'level'               - refinment based on the grid level of a block
  'gradT'		- gradient of temperature
  'gradP'		- gradient of pressure
  'gradlogrho'		- gradient of log(rho)
  'gradlogP'		- gradient of log(P)
  'gradE'		- gradient of electric field magnitude
  'curlV','curlU' 	- magnitude of curl of velocity
  'curlB'		- magnitude of current density
  'J2'                  - square of current density
  'currentsheet'        - current sheet (radial B changes sign)
  'divU', 'divV'	- divergence of velocity
  'user'                - criteria defined in the user module
\end{verbatim}
For TypeRefine="transient TypeTransient" there are the following possibiities:
\begin{verbatim}
  'transient P_dot'	- relative change of pressure       (dP/dt)/P
  'transient T_dot'	- relative change of temperature    (dT/dt)/T
  'transient Rho_dot'	- relative change of density        (drho/dt)/rho
  'transient RhoU_dot'	- relative change of momentum       (d|rhoU|/dt)/|rhoU|
  'transient B_dot'	- relative change of magnetic field (d|B|/dt)/|B|
  'transient meanUB'    - max[(d|rhoU|/dt)/|rhoU|] * max[(d|B|/dt)/|B|]
  'transient Rho_2nd_1' - (|d2Rho/dx2| + |d2Rho/dy2| + |d2Rho/dz2|)/rho
  'transient Rho_2nd_2' - (|d2Rho/dx2  +  d2Rho/dy2  +  d2Rho/dz2|)/rho
\end{verbatim}
For TypeRefine="error StateVarName" the criteria is a numerical error
estimate for the state variable StateVarName.
The error estimation is based on the second and first derivatives:
\begin{verbatim}
                          d^2 U
                         -------
                          dx^2
    E  =  ----------------------------------------
           1     dU      SmallError
          ---  ------  + ---------- *U  + Epsilon
          DX     dx         DX^2
\end{verbatim}
The SmallError parameter gives a relative error with respect to the mean value
of the state variable. This parameter is read as the last parameter of the
command if there are any "error" type criteria.

A useful tool to see the values of the various criteria is to plot the
'crit1'..'crit9' plot variables with the #SAVEPLOT command just before
the AMR(s).

The default setting is nCriteria = 0.
This can be used to refine or coarsen all the blocks
limited by the minimum and maximum levels only
(see commands #AMRLEVELS and #AMRRESOLUTION).

</command>

</commandgroup>
<commandgroup name="SCHEME PARAMETERS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!  SCHEME PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="UPDATE">
  <parameter name="TypeUpdate" type="string" input="select" case="lower">
    <option name="orig"  default="T"/>
    <option name="slow"  />
    <option name="fast"  />
  </parameter>

#UPDATE
slow			TypeUpdate (orig/slow/fast)

The TypeUpdate parameter determines which implementation of the update is used.
The value "orig" is the original implementation that works on CPU only.
The value "slow" is the original implementation but parameters are forced
to match the fast implementation for sake of debugging. Works on CPU only.
The value "fast" is the implementation for the GPU, but it can also be run on
the CPU. 

The default value is "orig" if the code is compiled for CPU,
and "fast" when compiled for the GPU.
</command>

<command name="UPDATEVAR">
  <parameter name="StringVarUpdate" type="string" length="$lLine"/>

#UPDATEVAR
rho mx my               StringVarUpdate

#UPDATEVAR
all                     StringVarUpdate


Update only a subset of the state variables. The variables should be
listed with a single space separator in the StringVarUpdate.
If StringVarUpdate is set to 'all' then all the variables are updated.

If density is updated but some components of the momentum are not,
then the velocity is preserved (not the momentum). In the first example
above, the Z component of the velocity is fixed. In the current
implementation this only works with classical momentum
(not with semi-relativistic momentum, see #BORIS command) and only
for the first fluid.

The default is to update all the variables.
</command>
  
<command name="SCHEME">
  <parameter name="nOrder" type="integer" input="select">
    <option name="1st order"  value="1"/>
    <option name="TVD2"       value="2" default="T"/>
    <option name="MP5/CWENO5" value="5"/>
  </parameter>
  <parameter name="TypeFlux" type="string" input="select" case="upper">
    <option name="Rusanov" value="RUSANOV" default="T"/>
    <option name="Linde"   value="LINDE"  />
    <option name="Sokolov" value="SOKOLOV"/>
    <option name="LFDW"                   />
    <option name="HLLDW"                  />
    <option name="HLLD"                   />
    <option name="Roe"     value="ROE"    />
    <option name="RoeOld"  value="ROEOLD" />
    <option name="Godunov" value="GODUNOV"/>
    <option name="Simple"  value="SIMPLE" />
  </parameter>
  <if expr="$nOrder != 1 and $TypeFlux ne 'SIMPLE'">
    <parameter name="TypeLimiter" type="string" input="select">
      <option name="minmod"  		 	/>
      <option name="mc"	default="T"	/>
      <option name="mc3"			/>
      <option name="beta"			/>
    </parameter>
    <parameter name="LimiterBeta" type="real" min="1" max="2"
	       default="1.2" if="$TypeLimiter ne 'minmod'"/>
  </if>

#SCHEME
5			nOrder (1, 2 or 5)
Rusanov			TypeFlux
mc3			TypeLimiter ! Only read for Order>1 and flux not Simple
1.2			LimiterBeta ! Only read if TypeLimiter is NOT 'minmod'

The nOrder parameter determines the spatial and temporal accuracy of
the scheme.
The spatially first order scheme uses a one-stage time integration.
The spatially second order MUSCL scheme either uses
an explicit two-stage Runge-Kutta or an implicit three-level BDF2
time discretization.
The spatially 5th order schemes uses the 3rd order Runge-Kutta scheme.

NOTE 1: The 5th order scheme requires 3 ghost cells and at least 6x6x6
grid blocks (to be set with Config.pl -g=... -ng=...). The 1st and 2nd
order schemes work with 2 ghost cells and can have 4x4x4 blocks.

NOTE 2: the time discretization scheme can be modified with the
#TIMESTEPPING, #RUNGEKUTTA or #RK commands after the #SCHEME command.

Possible values for TypeFlux:
\begin{verbatim}
 'Rusanov'     - Rusanov or Lax-Friedrichs flux
 'Linde'       - Linde's HLLEL flux
 'Sokolov'     - Sokolov's Local Artificial Wind flux
 'LFDW'	       - Lax-Friedrichs + Dominant-Wave (Andrea Mignone)
 'HLLDW'       - HLLE + Dominant-Wave           (Andrea Mignone)
 'HLLD'        - Miyoshi and Kusano's HLLD flux
 'Roe'         - Roe's approximate Riemann flux (new)
 'RoeOld'      - Roe's approximate Riemann flux (old)
 'Godunov'     - Godunov flux with exact Riemann solver
 'Simple'      - Physical fluxes are applied without any Riemann solver.
\end{verbatim}
The Rusanov, Linde, Sokolov, LFDW and HLLDW schemes are general for any
equation set. The Rusanov scheme is the most diffusive (and robust),
the HLLDW scheme is the least diffusive.
The Godunov flux is only implemented for (multi-material) hydrodynamics.
The Roe and HLLD schemes are implemented for ideal MHD only
(single fluid, non-relativistic, no Hall term).
The new and old Roe schemes differ in some details of the algorithm,
the new Roe scheme is somewhat more robust in magnetospheric applications.
The Simple solver is for testing purposes only at this point.

No limiter is used by the 1st order scheme. The second order TVD scheme
uses a TVD limiter everywhere. The 5th order schemes has its own
5th order accurate limiter (see #SCHEME5 command).
The TypeLimiter is still used inside the region specified by
the #LOWORDERREGION command and where the stencil is not
large enough for the high order scheme but sufficient
for the second order scheme, which happens near face boundaries
(see the #BOXBOUNDARY and #INNERBOUNDARY command).
Possible values for TypeLimiter:
\begin{verbatim}
 'minmod'      - minmod limiter is the most robust and diffusive limiter
 'mc'          - monotonized central limiter with a beta parameter
 'mc3'         - Koren's third order limiter with a beta parameter
 'beta'        - beta limiter is less robust than the mc limiter for
                 the same beta value
\end{verbatim}
Possible values for LimiterBeta (for limiters othen than minmod)
are between 1.0 and 2.0:
\begin{verbatim}
  LimiterBeta = 1.0 is the same as the minmod limiter
  LimiterBeta = 1.5 is a typical value for the mc/mc3 limiters
  LimiterBeta = 1.2 is the recommended value for the beta limiter
  LimiterBeta = 2.0 for the beta limiter is the same as the superbee limiter
\end{verbatim}

The default is the second order Rusanov scheme with the minmod limiter.
</command>

<command name="LOWORDERREGION">
	 <parameter name="StringLowOrderRegion" type="string" length="$lLine"
	 	    case="lower" default="none"/>

#LOWORDERREGION
+nearbody +faraway		StringLowOrderRegion

This command is only useful if the nOrder is larger than 2 in the #SCHEME
command. In this case the StringLowOrderRegion string can specify a region
where the low (second) order scheme is used. The regions must be described
with the #REGION command. A linear combination of a low order and high
order face value is used in the tapering region.

The default is to apply the high order scheme everywhere.
</command>


<command name="ADAPTIVELOWORDER">
  <parameter name="UseAdaptiveLowOrder" type="logical" default="F"/>
  <if expr="$UseAdaptiveLowOrder">
    <parameter name="nLowOrder" type="integer" min="1" max="2" />
    <parameter name="pCritLow"  type="real" min="1" />
    <parameter name="pCritHigh" type="real" min="1" />
    <parameter name="VelCrit"   type="real" min="0" />
  </if>

#ADAPTIVELOWORDER
T                      UseAdaptiveLowOrder
2                      nLowOrder
2.0                    PCritLow
1.5                    PCritHigh
2.0                    VelCrit

The role of this command is similar to #LOWORDERREGION. #LOWORDERREGION
selects the faces use 1st/2nd order face values based on the geometry,
while this comamd selectes low order faces based on local physical conditions,
which are total pressure jump and normal velocity difference in the current
implementation. The low order value could be 1st or 2nd, which is set by
nLowOrder.

For each face, its 6 neighbor cells (3 cells on each side) are used as
criteria.  Among these 6 cells, let's denote the ratio between maximum
and minimum pressure as pRatio, and the difference between the lagest
and smallest march number as dVel. When dVel is smaller than VelCrit,
then the high order schemes are used.  When dVel is larger than
VelCrit, further check the value of pRatio. If pRatio is
larger/smaller that pCritLow/pCritHigh, then a low/high order face
value will be used, otherwise, use a linear combination of the low and
high order value.
</command>

<command name="SCHEME5">
  <parameter name="UseFDFaceFlux" type="logical" default="T"/>
  <parameter name="TypeLimiter" type="string" input="select" case="lower">
    <option name="mp5" default="T"/>
    <option name="cweno"          />
  </parameter>
  <parameter name="UseHighResChange" type="logical" default="T"/>
  <parameter name="UseHighOrderAMR"  type="logical" default="T"/>
  <parameter name="DoCorrectFace"  type="logical" default="T"/>

#SCHEME5
T			UseFDFaceFlux
MP5			TyperLimiter5
T			UseHighResChange
T			UseHighOrderAMR
T                       DoCorrectFace

UseFDFaceFlux is meaningful only when nOrder is 5 (see #SCHEME). If it is true,
a finite difference space discretization, which is 5th order accurate for
nonlinear equations, is used. Otherwise, the finite volume based
discretization, which is 2nd order accurate except for 1D linear equations,
is applied.

TypeLimiter5 can be MP5 or CWENO, which is used to limit 5th order space
interpolation. The MP5 scheme is recommended.

If UseHighResChange is true the ghost cells are filled in
with 5th order accurate values at the grid resolution changes
so the scheme becomes 5th order accurate even at the resolution
changes. If it is set to false, we switch to the second order
prolongation algorithm (see #PROLONGATION) and also switch on
the DoConserveFlux parameter of the #CONSERVEFLUX command.

If UseHighOrderAMR is true, 5th order interpolation is used for
grid refinement and coarsening, so the scheme is 5th order accurate
even with dynamic AMR. If false, the second order refinement and
coarsening algorithms are used.

DoCorrectFace is true by default when 5th order FD scheme is used. The
face values are corrected so that the 1st order derivatives df/dx are 5th
order accurate when DoCorrectFace is true.

NOTE 1: This command has no effect unless nOrder is set to 5 in
the #SCHEME command.

NOTE 2: this command has to be used after the #SCHEME command, because the
#SCHEME command sets the default values.

NOTE 3: The DoConserveFlux parameter of the #CONSERVEFLUX can be
overwritten with the #CONSERVEFLUX command AFTER the #SCHEME5 command.

The default values are shown above (assuming nOrder=5 is set in #SCHEME).
</command>

<command name="CONSERVEFLUX">
  <parameter name="DoConserveFlux" type="logical" default="T"/>

#CONSERVEFLUX
T		DoConserveFlux

Correct face flux near resolution change to keep conservation.

The default is true in general. The only exception is when the 5th order
finite difference scheme is used with UseFDFaceFlux set to true (see #SCHEME5).
The default may be overwritten with this command after the #SCHEME and #SCHEME5
commands.
</command>

<command name="NONCONSERVATIVE">
  <parameter name="UseNonConservative" type="logical" default="F"/>
#NONCONSERVATIVE
T		UseNonConservative

If UseNonConservative is false, the total energy density equation is solved
everywhere, and the pressure is derived from the total energy density.
If UseNonConservative is true, then the pressure equation is solved, and
the total energy density is calculated from the pressure and the kinetic
and magnetic energy densities either everywhere (if nConservCrit=0),
or in the regions defined in the #CONSERVATIVECRITERIA command.
For further control of neutral fluids see the #NEUTRALFLUID command.

The default is using the conservative equations.
</command>

<command name="CONSERVATIVECRITERIA">
  <parameter name="nConservCrit" type="integer" min="0" max="3" default="0"/>
  <for from="1" to="$nConservCrit">
    <parameter name="TypeConservCrit" type="string" case="lower"
	       input="select">
      <option name="radius"	value="r/radius" default="T"/>
      <option name="parabola"	value="parabola/paraboloid" />
      <option name="p"				            />
      <option name="grad P"	value="gradp"		    />
    </parameter>
    <parameter name="rConserv" type="real" min="$rBody"
	       default="6"  if="$TypeConservCrit =~ /^r|radius$/i"/>
    <parameter name="xParabolaConserv" type="real" min="0"
	       default="6"  if="$TypeConservCrit =~ /^parabol/i"/>
    <parameter name="yParabolaConserv" type="real" min="0"
	       default="36" if="$TypeConservCrit =~ /^parabol/i"/>
    <parameter name="pCoeffConserv" type="real" min="0"
	       default = "0.05" if="$TypeConservCrit =~ /^p$/i"/>
    <parameter name="GradPCoeffConserv" type="real" min="0"
	       default = "0.1" if="$TypeConservCrit =~ /gradp/i"/>
  </for>

#CONSERVATIVECRITERIA
3		nConservCrit
r		TypeConservCrit
6.		rConserv             ! read if TypeConservCrit is 'r'
parabola        TypeConservCrit
6.		xParabolaConserv     ! read if TypeConservCrit is 'parabola'
36.		yParabolaConserv     ! read if TypeConservCrit is 'parabola'
p		TypeConservCrit
0.05		pCoeffConserv	     ! read if TypeConservCrit is 'p'
GradP		TypeConservCrit
0.1		GradPCoeffConserv    ! read if TypeConservCrit is 'GradP'

Select the parts of the grid where the conservative vs. non-conservative
schemes are applied. The number of criteria is arbitrary, although
there is no point applying the same criterion more than once.

If no criteria is used, the whole domain will use conservative energy
density or non-conservative pressure equations depending on
UseNonConservative set in command #NONCONSERVATIVE.

The physics based conservative criteria ('p' and 'GradP')
select cells which use the non-conservative scheme if ALL of them are true:
\begin{verbatim}
 'p'      - the pressure is smaller than fraction pCoeffConserv of the energy
 'GradP'  - the relative gradient of pressure is less than GradPCoeffConserv
\end{verbatim}
 The geometry based criteria are applied after the physics based criteria
 (if any) and they select the non-conservative scheme if ANY of them is true:
\begin{verbatim}
 'r'        - radial distance of the cell is less than rConserv
 'parabola' - x less than xParabolaConserv - (y**2+z**2)/yParabolaConserv
\end{verbatim}

The default is to have no conservative criteria: nConservCrit = 0.
</command>

<command name="UPDATECHECK">
  <parameter name="UseUpdateCheck" type="logical" default="F" />
  <if expr="$UseUpdateCheck">
    <parameter name="RhoMinPercent" type="real" min="0" max="100"
	       default="40" />
    <parameter name="RhoMaxPercent" type="real" min="0"
	       default="400" />
    <parameter name="pMinPercent" type="real" min="0" max="100"
	       default="40" />
    <parameter name="pMaxPercent" type="real" min="0"
	       default="400" />
  </if>
#UPDATECHECK
T			UseUpdateCheck
40.			RhoMinPercent
400.			RhoMaxPercent
40.			pMinPercent
400.			pMaxPercent

Note that the "update-check" algorithm controlled by this command does
not work together with high order Runge-Kutta schemes (see the #RK
command) because the RK method combines the intermediate stages for
the final update. Use the time step control method (see
#TIMESTEPCONTROL and related commands) in combination with RK time
stepping.  In general, for time accurate simulations the time step
control method has more flexibility and it is likely to be more
effective and efficient than this update-check method.

If UseUpdateCheck is true, the local or global time step will be
adjusted so that the density and pressure does not decrease or
increase by more than the given percentages in a single timestep. For
example with the default settings, if density is 1.0 initially and it
would change below 0.6 or above 5.0, the (local) time step will be
reduced so that the final density remains inside the prescribed
bounds.

Default is UseUpdateCheck false. 
For Runge-Kutta schemes UseUpdateCheck is forced to be false.
</command>

<command name="CHECKTIMESTEP">
  <parameter name="DoCheckTimeStep" type="logical"         default="F"/>
  <parameter name="DnCheckTimeStep" type="integer" min="1" default="2"/>
  <parameter name="TimeStepMin" type="real" min="0"        default="1e-12"/>
#CHECKTIMESTEP
T		DoCheckTimeStep
2		DnCheckTimeStep
1e-6		TimeStepMin

This command is only effective in time accurate mode.

If DoCheckTimeStep is true, then check if average time step is smaller than
TimeStepMin every nCheckTimeStep time steps. 
If it is, save the output files (but not restart) and stop the code.

Default is DoCheckTimeStep false.
</command>

<command name="CONTROLTIMESTEP" alias="TIMESTEPCONTROL">
  <parameter name="UseTimeStepControl" type="logical" default="F"/>
#CONTROLTIMESTEP
T			UseTimeStepControl

#TIMESTEPCONTROL
T			UseTimeStepControl

Setting UseTimeStepControl=T switches on the new time step control scheme
that controls the time step based on the relative change in selected set
of variables. The variables can be selected with the #CONTROLVAR command.
The various thresholds in the relative increase and decrease of these
variables can be set by the #CONTROLINCREASE and #CONTROLDECREASE commands.
The #CONTROLFACTOR command determines how much the time step changes
when the various thresholds are reached.

Currently this scheme only works in time accurate mode.

The default is UseTimeStepControl false.
</command>

<command name="CONTROLINIT">
  <parameter name="TimeStepControlInit" type="real" min="0" max="1"
		   default="1"/>
#CONTROLINIT
0.01			TimeStepControlInit

Set the initial reduction factor applied to the time step or Cfl number.
The factor should be positive and it should typically not more than 1.

The default value is 1, i.e. there is no initial reduction applied.
</command>

<command name="CONTROLVAR">
  <parameter name="NameVarControl"  type="string" length="$lLine"
	     case="lower" default="rho p"/>
#CONTROLVAR
rho p			NameVarControl

The NameVarControl string contains the list of variables that are monitored
to control the time step. The variable names, separated by spaces,
should be chosen from the NameVar_V(1:nVar) array in the equation module.
The names are not case sensitive. Typically only the positive variables,
like density and pressure, should be monitored.

Note that this command is only effective if the time step control is switched
on by th #CONTROLTIMESTEP command.

The default is the control density and pressure as shown by the example.
</command>

<command name="CONTROLDECREASE">
  <parameter name="RejectStepLevel" type="real" min="0" max="1"
	     default="0.3"/>
  <parameter name="ReduceStepLevel" type="real" min="0" max="1"
	     default="0.6"/>
  <parameter name="IncreaseStepLevel" type="real" min="0" max="1"
	     default="0.8"/>
#CONTROLDECREASE
0.3			RejectStepLevel
0.6			ReduceStepLevel
0.8			IncreaseStepLevel

This command sets thresholds for the relative decrease in the control
variables in the time step control scheme. The relative decrease is
defined as D = min(VarNew/VarOld) where the minimum is taken over all cells
in the computational domain and all the control variables.

If D is below the RejectStepLevel threshold, the time step is rejected,
and it will be redone with a smaller time step/CFL number.

If D is above RejectStepLevel but below the ReduceStepLevel then the
time step is accepted, but the next time step/CFL number will be reduced.

If D is above RejectStepLevel but below IncreaseStepLevel, the time
step is accepted and there is no change in the time step/CFL number.

If is above the IncreaseStepLevel threshold, then the time step/CFL number
is increased, but it will never exceed the original value.

This command is only effective if the time step control is switched on with
the #CONTROLTIMESTEP command. The control variables are selected by the
#CONTROLVAR command, the factors that change the time step or the CFL number
are set by the #CONTROLFACTOR command.

Default values are shown.
</command>

<command name="CONTROLINCREASE">
  <parameter name="RejectStepLevel"   type="real" min="1" default="3.0"/>
  <parameter name="ReduceStepLevel"   type="real" min="1" default="1.5"/>
  <parameter name="IncreaseStepLevel" type="real" min="1" default="1.2"/>
#CONTROLINCREASE
3.0			RejectStepLevel
1.5			ReduceStepLevel
1.2			IncreaseStepLevel

This command sets thresholds for the relative increase in the control
variables in the time step control scheme. The relative increase is
defined as I = max(VarNew/VarOld) where the maximum is taken over all cells
in the computational domain and all the control variables.

If I is above the RejectStepLevel threshold, the time step is rejected,
and it will be redone with a smaller time step/CFL number.

If I is below RejectStepLevel but above the ReduceStepLevel then the
time step is accepted, but the next time step/CFL number will be reduced.

If I is below ReduceStepLevel but above IncreaseStepLevel, the time
step is accepted and there is no change in the time step/CFL number.

If I is below the IncreaseStepLevel threshold, then the time step/CFL number
is increased, but it will never exceed the original value.

This command is only effective if the time step control is switched on with
the #CONTROLTIMESTEP command. The control variables are selected by the
#CONTROLVAR command, and the factors that change the time step or the
CFL number are set by the #CONTROLFACTOR command.

Default values are shown.
</command>

<command name="CONTROLFACTOR">
  <parameter name="RejectStepFactor" type="real" min="0" max="1"
	     default="0.5"/>
  <parameter name="ReduceStepFactor" type="real" min="0" max="1"
	     default="0.95"/>
  <parameter name="IncreaseStepFactor" type="real" min="1"
	     default="1.05"/>
#CONTROLFACTOR
0.5			RejectStepFactor
0.95			ReduceStepFactor
1.05			IncreaseStepFactor

This command sets how much the time step/CFL number is changed by the
time step control scheme.

If the update is rejected then the next time step/CFL factor is
multiplied by RejectStepFactor.

If the update is accepted but the time step needs to be reduced,
then the next time step/CFL factor is multiplied by ReduceStepFactor.

If the update is accepted and the relative changes in the control variables
are within the range determined by the IncreaseStepLevel parameters of the
#CONTROLDECREASE and #CONTROLINCREASE commands, then the time step/CFL number
is multiplied by IncreaseStepFactor, but the original values cannot be
exceeded.

This command is only effective if the time step control is switched on with
the #CONTROLTIMESTEP command. The control variables are selected by the
#CONTROLVAR command.

Default values are shown.
</command>

<command name="ENFORCECFL">
  <parameter name="DoEnforceCfl" type="logical" default="F"/>

#ENFORCECFL
T                       DoEnforceCfl

Ensures that the local temperature maximum which can be produced by the
semi-implicit heat conduction solver, does not break the CFL condition
</command>

<command name="MULTISPECIES">
  <parameter name="DoReplaceDensity" type="logical" default="T"/>
  <parameter name="SpeciesPercentCheck" type="real" min="0" max="100"
	     default="1.0" />
#MULTISPECIES
T			DoReplaceDensity
1.0			SpeciesPercentCheck

This command is only useful for multispecies equations.
If the DoReplaceDensity is true, the total density is replaced with
the sum of the species densities. The SpeciesPercentCheck parameter
determines if a certain species density should or should not be
checked for large changes. If SpeciesPercentCheck is 0, all species
are checked, if it is 1, then only species with densities reaching
or exceeding 1 per cent are checked for large changes (see the
#UPDATECHECK command).

Default values are shown.
</command>

<command name="NEUTRALFLUID">
  <parameter name="DoConserveNeutrals" type="logical" default="T"/>
  <parameter name="TypeFluxNeutral" type="string" input="select">
    <option name="default"  default="T"/>
    <option name="Rusanov"/>
    <option name="Linde"  />
  </parameter>
#NEUTRALFLUID
F		DoConserveNeutrals
Linde		TypeFluxNeutral (default, Rusanov or Linde)

If DoConserveNeutrals is false, the pressure equation is used
for neutrals even when the energy equation is used for the ions.
If DoConserveNeutrals is true, the neutrals do the same as ions.
The neutral fluid uses the flux function set by TypeFluxNeutral.
The default is to use the same as the ion fluid if possible.
Currently only the Rusanov and Linde (HLLE) schemes are available for
the neutrals. If the ion fluid uses any other flux function,
the neutrals will use the Linde scheme.

Default values are DoConserveNeutrals=T and TypeFluxNeutral=default.
</command>

<command name="MULTIION">
  <parameter name="LowDensityRatio" type="real" min="0" max="1"
	     default="0.0001" />
  <parameter name="LowPressureRatio" type="real" min="0" max="1"
	     default="1e-10" />
  <parameter name="DoRestrictMultiIon" type="logical" default="F" />
  <if expr="$DoRestrictMultiIon">
    <parameter name="MachNumberMultiIon" type="real" min="1"    default="9" />
    <parameter name="ParabolaWidthMultiIon" type="real" min="0" default="30" />
  </if>
#MULTIION
0.0001			LowDensityRatio
1e-10			LowPressureRatio
T			DoRestrictMultiIon
3.0			MachNumberMultiIon (read if DoRestrictMultiIon)
30.0			ParabolaWidthMultiIon (read if DoRestrictMultiIon)

This command is useful for multiion simulations. Since the numerical schemes
cannot handle zero densities or temperatures, it is necessary to have all the
ions present in the whole computational domain. The parameters of this
command determine how the code behaves in regions where one of the ions
is dominant.

The LowDensityRatio parameter determines the relative density of the minor
ion fluids in regions where essentially only one ion fluid is present.

The LowPressureRatio parameter is used to keep the pressures of the minor
fluids above a fraction of the total pressure.

If DoRestrictMultiIon is true, the first ion fluid is set to be dominant
in the region determined by the MachNumberMultiIon and ParabolaWidthMultiIon
parameters. The current parametrization tries to find the region occupied
by the solar wind outside the bow shock. The region is identified as
the velocity being negative and the hydrodynamic Mach number in the X
direction is being larger than MachNumberMultiIon and the point being
outside the paraboloid determined by the
$y^2 + z^2 + x*ParabolaWidthMultiIon = 0$ equation.

The defaults are LowDensityRatio=0.0001, LowPressureRatio=1e-10, and
DoRestrictMultiIon=false.
</command>

<command name="MULTIIONSTATE">
	<parameter name="UseSingleIonVelocity"    type="logical" default="F"/>
	<parameter name="UseSingleIonTemperature" type="logical" default="F"/>
#MULTIIONSTATE
T			UseSingleIonVelocity
F			UseSingleIonTemperature

This command allows to enforce uniform ion velocities and/or temperatures
in multi-ion simulations. When both logicals are true, the multi-ion
simulation should become equivalient with a singlefluid multi-species
simulation. This is useful for testing.

When UseSingleIonVelocity is true, the ion velocities are set to the
average fluid velocity $u=\sum_s(\rho_s u_s)/\sum_s\rho_s$
as if there was an infinitely strong friction force between the ion fluids.

When UseSingleIonTemperature is true, the ion temperatures are set to the
average temperature $k_B T = \sum_s p_s/\sum_s(\rho_s/M_s)$
as if there was an infinitely fast energy exchange between the ion fluids.

Default values are false for both parameters.
</command>

<command name="COLLISION">
  <parameter name="CollisionCoefDim" type="real" min="-1" />
  <parameter name="TauCutOffDim" type="real" min="-1"          default="1000"/>
  <if expr="$TauCutOffDim&gt;0">
    <parameter name="uCutOffDim" type="real" min="-2"           default="100"/>
    <parameter name="nPowerCutOff" type="integer" min="1" max="3" default="2"/>
  </if>
#COLLISION
-1.0                            CollisionCoefDim
1.0e3                           TauCutOffDim [s]
100.0                           uCutOffDim [km/s] read if TauCutOffDim positive
2                               nPowerCutOff read if TauCutOffDim positive

This command is only useful for multiion simulations. It determines the
parameters for physical collisions and artificial friction.

If the CollisionCoefDim parameter is negative the ion-ion collisions are
neglected. This is typically a very good approximation in the low density
plasma of space physics. The collisions may be important in the ionosphere
of unmagnetized planets. For positive value the collision rate is taken
to be CollisionCoefDim$*n/T^{1.5}$ where $T$ is the temperature measured in
Kelvin, $n$ is the number density measured in $/cm^{-3}$ and the
resulting rate is in units of $1/s$.
Note that this feature is implemented but it has not been tested yet.

The TauCutOffDim parameter determines if the relative velocity between
ion fluids should be limited and at what rate.
If TauCutOffDim is positive, it gives the time rate of the friction.
If the TauCutOffDim parameter is negative the relative velocity of the
ion fluids (especially parallel to the magnetic field) can become very
large. In reality the streaming instability limits the relative speed.
Instead of trying to model the streaming instability directly,
in the current implementation we apply a simple friction term.

The uCutOffDim determines the speed difference (in input units,
typically km/s), at which the friction term becomes large.
Setting uCutoffDim = -1.0 switches to a physics based cut-off
velocity which is defined as B/sqrt[rho1*rho2/(rho1+rho2)]
where B is the magnetic field magnitude, and rho1 and rho2 are
the densities of the two ion fluids in normalized units.
Setting uCutoffDim = -2.0 applies a cut-off velocity based on the
total Alfven speed B/sqrt(rho1+rho2).

The nPowerCutOff is the exponent applied
to the square of the velocity difference. The friction force is
applied between all pairs of ion fluids, and it is

$(1/TauCutOffDim)\min(\rho_i, \rho_j)(u_j-u_i)
     [(u_i-u_j)^2/uCutOffDim^2]^{nPowerCutOff}$.

where i and j are the indexes of two different ion fluids and u is
the velocity vector.
Note that the friction force is proportional to the smaller of the
two densities so that the acceleration of the minor ion fluid is independent
of the density of the major ion fluid.

The default values are CollisionCoefDim=-1 and TauCutOffDim=-1, ie.
neither collision, nor friction are applied.
</command>

<command name="MESSAGEPASS" alias="OPTIMIZE">
  <parameter name="TypeMessagePass" type="string" input="select">
    <option value="opt"  name="opt: FACES ONLY"/>
    <option value="all"  name="all: ALL GHOST CELLS" default="T"/>
  </parameter>
#MESSAGEPASS
all			TypeMessagePass

Possible values for TypeMessagePass:
\begin{verbatim}
'all'	   - fill in all ghost cells (corners, edges and faces)
'opt'      - fill in face ghost cells only
\end{verbatim}
The default value is 'all', because there are many schemes that require
the ghost cells at the edges and corners (viscosity, resistivity, Hall MHD,
radiative diffusion, accurate resolution change algorithm, etc.).
These will automatically change to the 'all' option even if the user sets
"opt", which is only recommended for advanced users.
</command>

<command name="OPTIMIZEMPI">
  <parameter name="UseOptimizeMpi" type="logical" default="F"/>

#OPTIMIZEMPI
F			UseOptimizeMpi

If UseOptimizeMpi is true, then the two explicit MPI barriers are switched
off, which may help with MPI performance. This feature is not fully tested.
The default is false.

</command>

<command name="RESOLUTIONCHANGE">
  <parameter name="UseAccurateReschange"  type="logical" default="F" />
  <parameter name="UseTvdReschange"       type="logical" default="T" />
  <parameter name="BetaLimiterResChange"  type="real" min="1" max="2"
	     default="2" />
  <parameter name="nFaceLimiterResChange" type="integer" min="0"
	     default="2" />
  <rule expr="not($UseAccurateReschange and $UseTvdReschange)">
    Cannot have both UseAccurateReschange and UseTvdReschange true.
  </rule>
#RESOLUTIONCHANGE
F		UseAccurateResChange
T		UseTvdResChange
2.0		BetaLimiterResChange
2		nFaceLimiterResChange

If UseAccurateResChange is true, then a second order accurate, upwind and
oscillation free scheme is used at the resolution changes.
It requires message passing edge ghost cells (this is switched on
automatically) which may effect the performance slightly.

If UseTvdResChange is true, then an almost second order and partially
downwinded TVD limited scheme is used at the resolution changes.
This scheme does not require message passing of the edge ghost cells.
Only one of UseAccurateResChange and UseTvdResChange can be true.

If BetaLimiterResChange is set to a value smaller than the BetaLimiter
parameter in the #SCHEME command, then the limiter will use this
BetaLimiterResChange parameter at and near grid resolution changes.
The smallest value is 1.0 that corresponds to the minmod limiter,
the maximum value is 2.0 that means that the same limiter is applied
at the resolution change as anywhere else. Recommended values are 1.0 to 1.2
combined with BetaLimiter=1.5 in the #SCHEME command.

The nFaceLimiterResChange determines how many faces around the resolution
change itself are affected. If nFaceLimiterResChange is 0, the limiter using
BetaLimiterResChange is applied at the face at the resolution change itself.
If nFaceLimiterResChange is 1 or 2, the limiter is applied at 3 or 5 faces
altogether. The recommended value is 2.

Default values are shown, ie. the TVD reschange algorithm is used, and
the limiter applied at the resolution changes is the same as everywhere else,
because BetaLimiterResChange is set to 2.
</command>

<command name="RESCHANGE">
  <parameter name="UseAccurateReschange" type="logical" default="F" />
#RESCHANGE
T		UseAccurateResChange

This command is kept for backwards compatibility.
See description at the #RESOLUTIONCHANGE command.
</command>

<command name="TVDRESCHANGE">
  <parameter name="UseTvdReschange" type="logical" default="T" />
#TVDRESCHANGE
T		UseTvdResChange

This command is kept for backwards compatibility.
See description at the #RESOLUTIONCHANGE command.
</command>

<command name="PROLONGATION">
  <parameter name="nOrderProlong" type="integer" min="1" max="2" default="2"/>

#PROLONGATION
2		nOrderProlong  (1 or 2)

The nOrderProlong parameter determines if the fine ghost cells are filled
in with first order or second order accurate values at the resolution change.
The first order value is simply a copy of the coarse cell that covers the
fine ghost cell. The second order value is obtained from linear interpolation
of coarse cells covering and surrounding the fine ghost cell. This command
sets the "UseAccurateResChange" and "UseTvdResChange" parameters to false
(see #RESOLUTIONCHANGE command). Since the subcylcing algorithm
(see #SUBCYCLING) is not quite compatible with the "accurate res. change"
and "TVD res. change" algorithms, this command provides an alternative
approach that is compatible.

Note that the 5th order scheme (see #SCHEME command) uses a 5th order
accurate prolongation procedure unless the "UseHighResChange" parameter
is set to false in the #SCHEME5 command.

The default is using 1st order prolongation for the first order scheme
(nOrder=1 in the #SCHEME command) the "TVD reschange" algorithm for the
2nd order scheme, and the 5th order prolongation for the 5th order scheme.
</command>

<command name="LIMITER">
  <parameter name="UseLogRhoLimiter" type="logical" default="F" />
  <parameter name="UseLogPLimiter" type="logical" default="F" />
  <parameter name="UseRhoRatioLimiter" type="logical" default="F" />
  <parameter name="NameVarLimitRatio" type="string" length="$lLine"
	     if="$UseRhoRatioLimiter" />

#LIMITER
F		UseLogRhoLimiter
F		UseLogPLimiter
T		UseRhoRatioLimiter
Xe Be Pl	NameVarLimitRatio (read if UseRhoRatioLimiter)

The spatially second order scheme uses a limited reconstruction to obtain
face values from the cell center values. The order of the scheme and the
type of the limiter can be set in the #SCHEME command. This command
provides additional options to the limiting procedure.

If UseLogRhoLimiter is true, the logarithm of the density is limited instead
of the density itself. This can reduce numerical diffusion in regions where
the density changes exponentially with distance (e.g. in the solar corona).

If UseLogPLimiter is true, the logarithm of pressure is limited instead of
the pressure itself.

If UseRhoRatioLimiter is true, then parameter NameVarLimitRatio is
read and the variables listed in NameVarLimitRatio (the variable
names are defined in ModEquation) are divided by the total density before
the limiter is applied and then multiplied back by the density at the
face after the limiting is completed. This modification is useful for the
high energy density simulations of the CRASH project for the level set
functions or for the internal energy associated with ionization.

Default values are false for all variables, which results in the limited
reconstruction procedure directly applied to the original primitive variables
(velocity and pressure).
</command>

<command name="LIMITMOMENTUM" if="$_IsFirstSession">
  <parameter name="DoLimitMomentum" type="logical" default="F"/> 

#LIMITMOMENTUM
F                 DoLimitMomentum

If DoLimitMomentum is set to true then the limiter of the 2nd order scheme
is applied to the momentum, if it is set to false, the limiter is applied
to the velocity. This command should be used in the first session only.

The default value is false except when the Boris scheme is used for single
ion fluid (see #BORIS command) and either nOrder is 1 (see #SCHEME command)
or UseTvdResChange is true or UseAccurateResChange is true (see #RESCHANGE,
#RESOLUTIONCHANGE and #PROLONGATION commands). 
</command>

<command name="LIMITPTOTAL">
  <parameter name="DoLimitPTotal" type="logical" default="F"/> 

#LIMITPTOTAL
T			DoLimitPtotal
  
If DoLimitPtotal is true and nOrder is larger than 1 (see #SCHEME command)
and a single ion fluid is solved for then apply the limiter to the total
pressure that is the sum of ion, electron and Alfven wave turbulence pressures.
Otherwise the limiter is applied to the individual pressures.

Default is DoLimitPtotal false.
</command>
  
<command name="CLIMIT">
  <parameter name="UseClimit" type="logical"        default="F"/>
  <if expr="$UseClimit">
    <parameter name="ClimitDim" type="real" min="0" default="3000"/>
    <parameter name="rClimit" type="real"           default="6"/>
  </if>
#CLIMIT
T			UseClimit (rest of parameters are read if true)
3000.0			ClimitDim [km/s]
6.0			rClimit

If UseClimit is true, the wave speeds used in the numerical diffusive fluxes
are limited by the value of ClimitDim (in I/O units, typically km/s)
within the sphere of radius rClimit (typically in units of planetery radii).
This scheme cannot be used with a fully explicit time integration, because
it will not be stable! One should use the fully or part implicit scheme
(see the #IMPLICIT command). In contrast with the Boris correction (see
the #BORIS command), this scheme is fully consistent with the governing
equations in time accurate mode as well. It can be combined with
the Roe scheme too unlike the Boris correction. The limiting scheme
cannot be combined with the HLLD scheme (neither can be the Boris correction
at this point).

A reasonable set of values are shown above. Much smaller velocity limit
will result in slow convergence for the implicit solver. The radial limit is
not very crucial, but it should be set large enough to cover the whole region
where the wave speed may exceed it and the reduced diffusion is important.

Default is UseClimit false.
</command>

<command name="BORIS">
  <parameter name="UseBorisCorrection" type="logical"             default="F"/>
  <parameter name="BorisClightFactor" type="real" min="0" max="1" default="1"
	     if="$UseBorisCorrection" />
#BORIS
T			UseBorisCorrection
1.0			BorisClightFactor !Only if UseBorisCorrection is true

If UseBorisCorrection is set to true and there is only a single
ion fluid, then the semi-relativistic MHD equations are solved.
If there are multiple ion fluids, the code automatically switches to the
"simple Boris correction" described at the #SIMPLEBORIS command.

The semi-relativistic MHD equations limit the Alfven speed to
the speed of light. The speed of light can be artificially reduced by
the BorisClightFactor. Set BorisClightFactor=1.0 for true semi-relativistic
MHD. BorisClightFactor less than 1 can be used to allow larger explicit
time steps and to reduce the numerical diffusion.
Typical values are 0.01 to 0.02, which set the speed of light to 3,000km/s
and 6,000km/s, respectively. Note that semi-relativistic MHD gives the
same steady state solution as normal MHD analytically, but there can be
differences due to discretization errors, in particular the Boris
correction reduces the numerical diffusion.
See Toth et al. 2011 (Journal of Geophysical Research, 116, A07211,
doi:10.1029/2010JA016370) for an in-depth discussion.

See also the #BORISSIMPLE command as an alternative. Note that you cannot set
both UseBorisCorrection and UseBorisSimple to true.

Default is UseBorisCorrection=.false.
</command>

<command name="BORISSIMPLE">
  <parameter name="UseBorisSimple" type="logical"                 default="F"/>
  <parameter name="BorisClightFactor" type="real" min="0" max="1" default="1"
	     if="$UseBorisSimple" />
#BORISSIMPLE
T			UseBorisSimple
0.05			BorisClightFactor !Only if UseBorisSimple is true

Use simplified semi-relativistic MHD. For single fluid MHD this means
that the time derivative of the momentum density is multiplied with a
factor $(1+vA^2/c^2)$, which reduces the change of velocity.
For the multi-ion MHD the JxB - grad(Pe) forces acting on the fluids are
reduced by the same factor (which has a similar effect).

The speed of light can be reduced by the BorisClightFactor.
This scheme is only useful with BorisClightFactor less than 1.
The single fluid case should give the same steady state as normal MHD,
but there can be a difference due to discretization errors.
The multi-ion MHD case will not even give the same steady state
analytically as the unmodified multi-ion MHD.
You can use either Boris or BorisSimple but not both.
For multi-ion MHD only the simple Boris scheme is available.

Default is UseBorisSimple=.false.
</command>

<command name="BORISREGION">
  <parameter name="NameBorisRegion" type="string" length="$lLine"
	     case="lower" default="none"/>

#BORISREGION
+nearbody       NameBorisRegion

This command can be used to limit the effect of the (simple)
Boris correction (see #BORIS and #SIMPLEBORIS) to a region
defined by one or more #REGION commands. Outside this region
the semi-relativistic equations are solved with the true speed
of light, while inside the Boris region the speed of light
is reduced. It is probably a good idea to use tapering (see
the #REGION command) so that the speed of light changes gradually
at the edges of the region.

The default is to use the reduced speed of light everywhere.
</command>

<command name="B0">
  <parameter name="UseB0" type="logical" default="F"/>
#B0
F		UseB0

If UseB0 is true, the magnetic field is split into an analytic B0 and
a numerical B1 field. The B0 field may be a (rotating) dipole of a planet,
or the potentialf field solution for the corona. B1 is not small relative
to B0 in general. The default value depends on the application.
</command>

<command name="CURLB0">
  <parameter name="UseCurlB0" type="logical" default="F"/>
  <parameter name="rCurrentFreeB0" type="real" min="0" default="2.5"
	     if="$UseCurlB0" />
  <parameter name="UseB0MomentumFlux" type="logical" default="F"
	     if="$UseCurlB0" />

#CURLB0
T		UseCurlB0
2.5		rCurrentFreeB0    (read if UseCurlB0 is true)
T		UseB0MomentumFlux (read if UseCurlB0 is true)

If UseCurlB0 is true, then the B0 field has non-zero curl.
The B0 field of planets has zero curl, but the potential field source surface
model (PFSS) for the corona has a finite curl beyond the source surface,
where the field is forced to become radial.

The rCurrentFreeB0 parameter is set to the radius within which the B0 field
has no curl (i.e. it is current free).

If UseB0MomentumFlux is true, the contribution from B0 field to momentum
source is calculated as $div (B0 B0) - grad B0^2/2 - B0 div B0$
otherwise as $curl B0 \times B0$. Although mathematically identical, 
these expressions are numerically different.

If this command is not used, then the defaults are the following.
The default is UseCurlB0 false in general, but it is set to true
if the radius of the B0 grid generated by #HARMONICSGRID command or by
FDIPS is less than the radius of the solar corona domain.
In this case rCurrentFreeB0 is set to the radius of the B0 grid.
If the local B0 lookup table is used, it is assumed to be non-potential,
so the default becomes UseCurlB0 true and rCurrentFreeB0=0.

The default for UseB0MomentumFlux is false.
</command>

<command name="LIGHTSPEED">
  <parameter name="cLightDim"  type="real" min="0" default="3e5"/>
  
#LIGHTSPEED
10.0			cLightDim

Set speed of light used in the Maxwell equations. Reducing the speed of light
artificially will allow larger explicit time steps. The speed of light
should be larger than the typical wave speeds present in the problem.

Default is the true speed of light.
</command>

<command name="FORCEFREEB0">
  <parameter name="UseForceFreeB0" type="logical" default="F"/>
  <parameter name="rMaxForceFreeB0" type="real" min="0" if="$UseForceFreeB0"/>

#FORCEFREEB0
T			UseForceFreeB0
1.5                     rMaxForceFreeB0 (read if UseForceFreeB0 is true)

If UseForceFreeB0 is true then define the B0 field to be force-free
but with non-zero J0=curl B0 below radius rMaxForceFreeB0.
The force-free property means that J0 x B0 = 0 in the momentum and
energy equations.

The default is UseForceFreeB0 false.
</command>

<command name="HYPERBOLICDIVE">
  <parameter name="HypEDecay" type="real" min="-1" max="0.5"
						default="0.1"/>
#HYPERBOLICDIVE
0.1			HypEDecay

This command sets the decay rate for the hyperbolic/parabolic constraint
for the div E = charge density condition when we solve for the electric
field. The hyperbolic cleaning is always applied with the speed of light.
In addition the scalar HypE decays as  HypE=HypE*(1-HypEDecay) if HypEDecay
is set to a positive value. If HypEDecay is less than zero,
no parabolic decay is applied.

Default is HypEDecay=0.1.
</command>

<command name="DIVB">
  <parameter name="UseDivbSource"    type="logical" default="T"/>
  <parameter name="UseDivbDiffusion" type="logical" default="F"/>
  <parameter name="UseProjection"    type="logical" default="F"/>
  <parameter name="UseConstrainB"    type="logical" default="F"/>
  <rule
      expr="not($UseProjection and ($UseDivbSource or $UseDivbDiffusion or $UseConstrainB))">
    If UseProjection is true, all others should be false.
  </rule>
  <rule
      expr="not($UseConstrainB and ($UseDivbSource or $UseDivbDiffusion or $UseProjection))">
    If UseConstrainB is true, all others should be false.
  </rule>
#DIVB
T			UseDivbSource
F			UseDivbDiffusion
F			UseProjection
F			UseConstrainB

Default values are shown above.
If UseProjection is true, all others should be false.
If UseConstrainB is true, all others should be false.
At least one of the options should be true unless the hyperbolic cleaning
is used. The hyperbolic cleaning can be combined with UseDivbSource only.
</command>



<command name="B0SOURCE">
  <parameter name="UseB0Source" type="logical" default="T"/>
  <parameter name="UseDivFullBSource" type="logical" default="F"
	     if="$UseB0Source"/>

#B0SOURCE
T			UseB0Source
F			UseDivFullBSource (read if UseB0Source is true)

If UseB0Source is true, add extra source terms related to the non-zero
divergence and curl of B0 in the momentum equation to cancel out
numerical errors in the divergence of the Maxwell tensor.

If UseDivFullBSource is also true, use div(B1+B0) in the induction
and energy equations instead of div(B1) in the 8-wave scheme.

Default values are shown. 
</command>

<command name="DBTRICK">
  <parameter name="UseDbTrick" type="logical" default="T"/>

#DBTRICK
F			UseDbTrick
  
This "trick" tries to maintain positivity when the conservative
MHD energy equation is used by adding $dB^2/2$ to the
energy density where dB is the change of the magnetic field relative to the
previous time step. This trick is done either at the half step of
the time accurate 2-stage scheme or in the (1 or 2-stage) local time
stepping scheme. In steady state the correction is zero becasuse dB=0.
For the time-accurate 2-stage scheme, the correction done at the
half step is $O(dt^2)$ because dB is proportional to the time step,
so the trick is consistent and still second order accurate.

Default is true if the trick is compatible with other settings. In particular,
the trick is switched off for Runge-Kutta schemes.
</command>

<command name="LORENTZFORCE">
  <parameter name="UseJCrossBForce" type="logical" default="T"/>

#LORENTZFORCE
F                     UseJCrossBForce

By default the single ion MHD equations use the divergence of the
Maxwell tensor to calculate the momentum fluxes (UseJCrossBForce is false),
while in the multiion equations the force acting on each fluid is
calculated as (qi/qe)*(J x B), where qi and qe are the charge densities
of the ion fluid and the electrons, respectively. An alternative approach
is to use (qi/qe)*Ec, where Ec is the electric field in the comoving
(moving with the ions) frame, and Ec is obtained from the divergence of
the Maxwell tensor.
The advantage of the latter approach is that the equation for the total
momentum will be in conservation form, since sum(qi) = qe.

In the future, we may switch the default value of UseJCrossBForce=F
for multiion MHD too. For now, it can be set with this command.
</command>

<command name="HYPERBOLICDIVB">
  <parameter name="UseHyperbolicDivb" type="logical" default="T"/>
  <if expr="$UseHyperbolicDivb">
    <parameter name="SpeedHypDim" type="real" min="0" default="1"/>
    <parameter name="HypDecay" type="real" min="-1" max="0.5"
	       default="0.1"/>
  </if>
#HYPERBOLICDIVB
T			UseHyperbolicDivb
400.0			SpeedHypDim
0.1			HypDecay

This command sets the parameters for hyperbolic/parabolic cleaning. The command
(and the hyperbolic cleaning method) can only be used if there is a hyperbolic
scalar named Hyp in the equation module. The SpeedHypDim parameter sets the
propagation speed for div B errors in dimensional units. Do not use a speed
that limits the time step (ie. exceeds the fastest wave speed). The HypDecay
parameter is for the parabolic cleaning. If HypDecay is less than zero, no
parabolic cleaning is applied. If it is positive, the scalar field is
modified as Hyp=Hyp*(1-HypDecay) after every update. This corresponds to
a point implicit evaluation of a parabolic diffusion of the Hyp scalar.

Default is UseHyperbolicDivb false.
</command>

<command name="PROJECTION">
  <parameter name="TypeProjectIter" type="string" input="select">
    <option name="Conjugate Gradients" value="cg" default="T"/>
    <option name="BiCGSTAB" value="bicgstab" 		/>
  </parameter>
  <parameter name="TypeProjectStop" type="string" input="select">
    <option name="Relative norm" value="rel" default="T"	/>
    <option name="Maximum error" value="max"		/>
  </parameter>
  <parameter name="RelativeLimit" type="real" min="0" max="1"
	     default="0.1" />
  <parameter name="AbsoluteLimit" type="real" min="0"
	     default="0.0" />
  <parameter name="MaxMatvec" type="integer" min="1" default="50" />
#PROJECTION
cg			TypeProjectIter:'cg' or 'bicgstab' for iterative scheme
rel			TypeProjectStop:'rel' or 'max' error for stop condition
0.1			RelativeLimit
0.0			AbsoluteLimit
50			MaxMatvec (upper limit on matrix.vector multipl.)

Default values are shown above.

For symmetric Laplacian matrix TypeProjectIter='cg' (Conjugate Gradients)
should be used, as it is faster than BiCGSTAB. In current applications
the Laplacian matrix is always symmetric.

The iterative scheme stops when the stopping condition is fulfilled:
\begin{verbatim}
  TypeProjectStop = 'rel':
       stop if ||div B||    &lt; RelativeLimit*||div B0||
  TypeProjectStop = 'max' and RelativeLimit is positive:
       stop if max(|div B|) &lt; RelativeLimit*max(|div B0|)
  TypeProjectStop = 'max' and RelativeLimit is negative:
       stop if max(|div B|) &lt; AbsoluteLimit
\end{verbatim}
  where {\tt ||.||} is the second norm, and B0 is the magnetic
  field before projection. In words 'rel' means that the norm of the error
  should be decreased by a factor of RelativeLimit, while
  'max' means that the maximum error should be less than either
  a fraction of the maximum error in div B0, or less than the constant
  AbsoluteLimit.

  Finally the iterations stop if the number of matrix vector
  multiplications exceed MaxMatvec. For the CG iterative scheme
  there is 1 matvec per iteration, while for BiCGSTAB there are 2/iteration.

 In practice reducing the norm of the error by a factor of 10 to 100 in
 every iteration works well.

 Projection is also used when the scheme switches to constrained transport.
 It is probably a good idea to allow many iterations and require an
 accurate projection, because it is only done once, and the constrained
 transport will carry along the remaining errors in div B. An example is

#PROJECTION
cg			TypeProjIter
rel			TypeProjStop
0.0001			RelativeLimit
0.0			AbsoluteLimit
500			MaxMatvec

</command>

</commandgroup>

<commandgroup name="COUPLING PARAMATERS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!! COUPLING PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

<command name="TRACE" alias="RAYTRACE">
  <parameter name="UseTrace" type="logical" default="T"/>
  <if expr="$UseTrace">
    <parameter name="UseAccurateTrace" type="logical" default="F"/>
    <parameter name="DtExchangeTrace" type="real"
	       min="0.01" max="60" default="0.1" />
    <parameter name="DnTrace" type="integer"
	       min="1" default="1" />
  </if>

#TRACE
T			UseTrace (rest is read if true)
T			UseAccurateTrace
0.1			DtExchangeTrace [sec]
1			DnTrace

Tracing (field-line tracing) is needed to couple the GM with the IM or RB
components. It can also be used to create plot files with open-closed
field line information. There are two algorithms implemented for integrating
field lines and for tracing field lines.

By default UseTrace parameter is true if there is magnetic field in the
equation module. The parameter can be set to false to save memory allocation.

If UseAccurateTrace is false (default), the block-wise algorithm is used,
which interpolates at block faces. This algorithm is fast, but less
accurate than the other algorithm. If UseAccurateTrace is true,
the field lines are followed all the way. It is more accurate but
potentially slower than the other algorithm.

In the accurate tracing algorithms, when the line exits the domain that belongs
to the PE, its information is sent to the other PE where the line continues.
The information is buffered for sake of efficiency and to synchronize
communication. The frequency of the information exchanges
(in terms of CPU seconds) is given by the DtExchangeTrace parameter.
This is an optimization parameter for speed. Very small values of DtExchangeTrace
result in many exchanges with few lines, while very large values result
in infrequent exchanges thus some PE-s may become idle (no more work to do).
The optimal value is problem dependent. A typically acceptable value is
DtExchangeTrace = 0.1 seconds (default).

The DnTrace parameter contains the minimum number of iterations between
two tracings. The default value 1 means that every new step requires
a new trace (since the magnetic field is changing). A larger value implies
that the field does not change significantly in that many time steps.
The tracing is always redone if the grid changes due to an AMR.

Default values are UseAccurateIntegral = .true. (if there is magnetic field),
UseAccurateTrace = .false., DtExchangeTrace = 0.1 and DnTrace=1.
</command>

<command name="TRACERADIUS">
  <parameter name="rTrace" type="real" min="-1" default="0"/>
  <parameter name="rIonosphere" type="real" min="-1" default="0"/>

#TRACERADIUS
2.5           rTrace
-1.0          rIonosphere

This command sets the inner boundary of field tracing.  If rTrace is
negative, there is no inner boundary for the tracing.  If rTrace is
positive then the field/stream lines are traced to rTrace. If
rIonosphere is also positive, then the magnetic field lines are
further traced along the dipole field down to rIonosphere. If
rIonosphere is negative then this is not done.

For the GM component the default is rIonosphere=1 if there is
a central dipole field. For other cases the default is rIonosphere=-1.
For rTrace the default is the larger of the ionosphere and body radii.
If there is no ionosphere and no body then the default is rTrace=-1.
</command>

<command name="TRACELIMIT" alias="RAYTRACELIMIT">
  <parameter name="TraceLengthMax" type="real" default="200"/>

#TRACELIMIT
50			TraceLengthMax

TraceLengthMax provides the maximum length for tracing a field/stream line.
Setting a small limit can avoid tracing extremely long field lines that are
not used later. The default is 200 units.
</command>

<command name="TRACEACCURACY">
  <parameter name="AccuracyFactor" type="real" min="1" default="1"/>

#TRACEACCURACY
5.0                      AccuracyFactor

Set the accuracy of the tracing algorithm. The default accuracy is optimized
for speed. Setting AccuracyFactor to a larger value reduces the step size
proportionally. Factor 5 may avoid failed tracing. Factor 20 is close to fully
converged accuracy. The higher accuracy means that more time is spent on the
field line tracing.

Default is AccuracyFactor=1.
</command>

<command name="SQUASHFACTOR">
  <parameter name="nLonSquash" type="integer" min="1" default="360"/>
  <parameter name="nLatSquash" type="integer" min="1" default="180"/>
  <parameter name="AccuracyFactorSquash" type="real" min="1" default="20"/>

#SQUASHFACTOR
360                     nLonSquash
180                     nLatSquash
20.0                    AccuracyFactorSquash

Set the resolution of the spherical grid at the inner boundary
on which the squash factor is calculated. Also set the accuracy
of the tracing used for the squash factor calculation.

Default values are shown above.
</command>

<command name="TRACETEST">
  <parameter name="iLonTest" type="integer" min="1" default="1"/>
  <parameter name="iLatTest" type="integer" min="1" default="1"/>

#TRACETEST
35                      iLonTest  
10                      iLatTest

Set the longitude and latitude indexes of the tested trace.
This is useful to test an individual trace line starting from
a spherical or cylindrical grid. The subroutine to be tested
still needs to be set with the #TEST command.

Default values are 1 for both indexes.
</command>

<command name="TRACEIE" alias="IE">
  <parameter name="DoTraceIE" type="logical" default="F"/>

#TRACEIE
T                       DoTraceIE

DoTraceIE will activate accurate ray tracing on closed field lines for
coupling with the IE module.  If not set, then only Jr is sent.  If set, then
Jr as well as 1/B, average rho, and average p on closed field lines are passed.
This command is required (!) for the MAGNIT conductance model in IE/RIM.

Default is DoTraceIE false.
</command>

<command name="IECOUPLING">
  <parameter name="UseIonoVelocity" type="logical" default="F"/>
  <if expr="$UseIonoVelocity">
    <parameter name="rCoupleUiono" type="real" min="1"
	       default="4"/>
    <parameter name="TauCoupleUiono" type="real" min="0"
	       default="10"/>
  </if>

#IECOUPLING
T			UseIonoVelocity (rest of parameters read if true)
4.0			rCoupleUiono
10.0			TauCoupleUiono

This command sets parameters for a new experimental coupling of
the velocity from IE to GM.

The rCoupleUiono paramter determines the radius within which the GM
velocity is effected.
The TauCoupleUiono parameter determine how fast the GM velocity
should be nudged towards the E x B drift plus corotation.

The IE potential and the resulting velocity are updated every time IE->GM
coupling occurs, but the nudging towards the velocity is done in every GM
time step. When GM is not run in time accurate mode, the orthogonal (to B)
velocity is set as

uOrth' = uOrth + (uIonoOrth - uOrth)/(TauCoupleUiono+1)

Therefore the larger TauCoupleUiono is the slower the adjustment will be.
It takes approximately 2*TauCoupleUiono time steps to get the orthogonal
velocity close to what the ionosphere would prescribe.
In time accurate mode, the nudging is based on physical time:

uOrth' = uOrth + min(1.0, dt/TauCoupleUiono)*(uIonoOrth - uOrth)

where dt is the time step. It takes about 2*TauCoupleUiono seconds
to get uOrth close to uIonoOrth. If the time step dt exceeds TauCoupleIm,
uOrth is set in a single step.

By default the coupling is switched off.
</command>

<command name="IM">
	<parameter name="TauCoupleIm" type="real" min="1"/>
	<parameter name="DoImSatTrace" type="logical" default="F" />

#IM
20.0			TauCoupleIm
F			DoImSatTracing

Same as command IMCOUPLING, except it only reads the first and second
parameters of #IMCOUPLING.

The default value is TauCoupleIm=20.0, which corresponds to typical nudging
and DoImSatTrace false.
</command>

<command name="IMCOUPLING">
  <parameter name="TauCoupleIm" type="real" min="1"/>
  <parameter name="DoImSatTrace" type="logical" default="F" />
  <parameter name="DoCoupleImPressure" type="logical" default="T"/>
  <parameter name="DoCoupleImDensity"  type="logical" default="F"/>
  <parameter name="DensityCoupleFloor" type="real" min="0" default="0"
	     if="$DoCoupleImPressure"/>
  <parameter name="DoFixPolarRegion"   type="logical" default="F"/>
  <if expr="$DoFixPolarRegion">
    <parameter name="rFixPolarRegion" type="real" min="1"
	       default="5"/>
    <for from="1" to="$nFluid">
      <parameter name="PolarNDim" type="real" min="0" default="20"/>
      <parameter name="PolarTDim" type="real" min="0" default="1e5"/>
    </for>
  </if>

#IMCOUPLING
20.0			TauCoupleIm
F			DoImSatTrace
T			DoCoupleImPressure
F			DoCoupleImDensity
0.01                    DensityCoupleFloor (read if DoCoupleImDensity is true)
T			DoFixPolarRegion (rest read if true)
5.0			rFixPolarRegion
20.0            	PolarNDim [amu/cc] for fluid 1
100000.0        	PolarTDim [K]      for fluid 1
2.0        		PolarNDim [amu/cc] for fluid 2
20000.0        		PolarTDim [K]      for fluid 2

This command sets various parameters for the GM-IM coupling.

The TauCoupleIm parameter determines how fast the GM pressure p
(and possibly density rho)
should be relaxed towards the IM pressure pIm (and density dIM).
The IM pressure and denstiy are updated every time IM->GM coupling occurs,
but the relaxation towards these values is done in every GM time step.
When GM is not run in time accurate mode, the pressure is set as
\begin{verbatim}
p' = (p*TauCoupleIm + pIm)/(TauCoupleIm+1)
\end{verbatim}
Therefore the larger TauCoupleIm is the slower the adjustment will be.
It takes approximately 2*TauCoupleIm time steps to get p close to pIm.
In time accurate mode, the relaxation is based on physical time:
\begin{verbatim}
p' = p + min(1.0, dt/TauCoupleIm)*(pIm - p)
\end{verbatim}
where dt is the time step. It takes about 2*TauCoupleIm seconds
to get p close to pIm. If the time step dt exceeds TauCoupleIm,
p' = pIm is set in a single step.
The default value is TauCoupleIm=20.0, which corresponds to typical
relaxation rate.

The DoImSatTrace logical sets whether the IM component receives the locations
of the satellites in GM mapped down along the magnetic field lines. The IM
component then can produce satellite output files with IM data.

The DoCoupleImPressure logical sets whether GM pressure is driven by IM
pressure. Default is true, and it should always be true (except for testing),
because pressure is the dominant variable in the IM to GM coupling.

The DoCoupleImDensity logical sets whether the GM density is relaxed
towards the IM density.

The DensityCoupleFloor parameter is read if DoCoupleImDensity is true.
If DensityCoupleFloor is positive, it sets a minimum density floor for every
fluid coupled between GM and IM. This avoids situations where
very low densities in the ring current model would push the
BATS-R-US densities to very low values, which can cause numerical problems.
If a floor value is necessary, the recommended value is 0.01 amu/cc.

The DoFixPolarRegion logical decides if we try to fix the pressure
(and density) values in the open field line region. The pressure/density
tends to diffuse
numerically from the closed field line region (controlled by IM) into the
polar region that should not be affected by IM. This can cause unphysically
fast outflow from the polar region. If DoFixPolarRegion is set to true,
the pressure (and density) are relaxed toward the values given
in the #POLARBOUNDARY command in the open field line region within
radius defined by rFixPolarRegion and where the flow points outward.

If DoFixPolarRegion is true then the following parameters are also read:

The rFixPolarRegion radius (given in planetary radii) sets the outer
limit for relaxing the pressure (density) in the open field line region
towards the PolarNDim and PolarTDim values. For multi-fluid MHD,
the PolarNDim and PolarTDim parameters are read for each fluid.

The default is to couple the IM pressure only and no fix is applied
in the polar region.
</command>

<command name="IMCOUPLINGSMOOTH">
  <parameter name="dLatSmoothIm" type="real" min="-1" default="-1"/>

#IMCOUPLINGSMOOTH
10.0			dLatSmoothIm [deg]

Smooth out the pressure and density nudging at the edge of the IM boundary.
The nudging is ramped up linearly within dLatSmootIm degrees along the magnetic
latitude direction. Default is -1.0, which means no smoothing.
</command>

<command name="MULTIFLUIDIM" if="$_IsFirstSession">
  <parameter name ="DoMultiFluidIMCoupling" type="logical" default="F"/>

#MULTIFLUIDIM
F			DoMultiFluidIMCoupling

If DoMultiFluidIMCoupling is true, the information exchanged between GM and IM
is in multi-fluid mode: GM gives IM four more variables (density_Hp,
density_Op, pressure_Hp, pressure_Op) in addition to one-fluid MHD paramters,
and IM passes GM the same four more variables.

The default value is DoMultiFluidIMCoupling = false, MHD variables are
exchanged between GM and IM.
</command>

<command name="ANISOPRESSUREIM" if="$_IsFirstSession">
  <parameter name ="DoAnisoPressureIMCoupling" type="logical" default="F"/>

#ANISOPRESSUREIM
F			DoAnisoPressureIMCoupling

If DoAnisoPressureIMCoupling is true, the information exchanged between GM and IM
allows for pressure anisotropy. This only makes sense if BATSRUS is configured
with anisotropic pressure equations and the IM model allows for non-isotropic
pressure (which is all models except RCM).

The default value is DoAnisoPressureIMCoupling = false, which means that
isotropy is assumed in the coupling (even if both GM and IM allow for
anisotropy).
</command>

<command name="PSCOUPLING">
  <parameter name="TauCouplePs" type="real" min="1"/>
  <parameter name="DoCouplePsPressure" type="logical" default="T"/>
  <parameter name="DoCouplePsDensity"  type="logical" default="T"/>
  <parameter name="DensityCoupleFloor" type="real" min="0" default="0"
	     if="$DoCoupleImPressure"/>

#PSCOUPLING
20.0			TauCouplePs
T			DoCouplePsPressure
T			DoCouplePsDensity
.1			DensityCoupleFloor

This command controls density and pressure coupling from the
plasmasphere (PS) component into BATS-R-US.  TauCouplePs sets the rate
at which MHD fluids are "nudged" towards the PS solution in the exact
fashion as #IMCOUPLING.  DoCouplePsPressure and DoCouplePsDensity
select which values are nudged.  DensityCoupleFloor controls the
minimum density that results from this coupling.  Setting this to a
reasonable value helps prevent near-zero time steps.

The default action is to not couple density or pressure from PS.

</command>

<command name="PWCOUPLING">
  <parameter name="DoLimitRhoPw" type="logical" default="F"/>

#PWCOUPLING
F			DoLimitRhoPw

If DoLimitRhoPw is true, limit the PW supplied densities by the body densities
from below.

Default is false.
</command>
</commandgroup>

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!! PIC COUPLING SPECIFIC COMMANDS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<commandgroup name="PIC COUPLING">

<command name="PICUNIT">
  <parameter name="xUnitPicSi" type="real" min="0" default="1"/>
  <parameter name="uUnitPicSi" type="real" min="0" default="1"/>

#PICUNIT
1.0		xUnitPicSi [m]
3000e3		uUnitPicSi [m/s] Speed of light for PIC

Define the length and velocity units for the PIC model. The length unit
is arbitrary (can be defined to be the same as for the MHD model, or
any other convenient length). The velocity unit, however, determines
the speed of light for the PIC model, since c=1 is defined.
Using the true speed of light makes the convergence
slow in the implicit solver of PIC. Therefore uUnitPicSi should be
set to a velocity that is larger than the typical velocities
(including the electron thermal velocity), but not orders of magnitude
larger. For typical magnetosphere applications a few 1000 km/s can work.

Default is 1 for both parameters, which is only meaningful if the velocities
are much smaller than 1 (e.g. in shock tube test problems).
</command>


<command name="PICGRIDUNIT">
  <parameter name="nPicGrid" type="integer" min="1"/>
  <for from="1" to="$nPicGrid">
    <parameter name="xUnitPicSi" type="real" min="0" default="1"/>
    <parameter name="uUnitPicSi" type="real" min="0" default="1"/>
    <parameter name="ScalingFactor" type="real" min="0" default="1"/>
  </for>

#PICGRIDUNIT
2               nPicGrid
1.0		xUnitPicSi [m]
3000e3		uUnitPicSi [m/s] Speed of light for the first PIC region
8               ScalingFactor
6400e3		xUnitPicSi [m]
1000e3		uUnitPicSi [m/s] Speed of light for the second PIC region
16              ScalingFactor

Similar to command #PICUNIT, but this command allows setting different
normalization units for different PIC grids. ScalingFactor is used for
changing the kinetic scales. See Toth et al. 2017 for more details.

If Hall MHD is used, the scaling factors in this command will not be used,
and PIC boxes use the surrounding Hall factors as the scaling factor.

The defaults are the same as described in #PICUNIT.
Do not use #PICUNIT and #PICRGRIDUNIT at the same time.
</command>

<command name="PICGRID">
  <parameter name="nPicGrid" type="integer" min="1"/>
  <for from="1" to="$nPicGrid">
    <parameter name="xMinPic" type="real"/>
    <parameter name="xMaxPic" type="real" min="$xMinPic"/>
    <parameter name="yMinPic" type="real"                if="$nJ != 1" />
    <parameter name="yMaxPic" type="real" min="$yMinPic" if="$nJ != 1" />
    <parameter name="zMinPic" type="real"                if="$nK != 1" />
    <parameter name="zMaxPic" type="real" min="$zMinPic" if="$nK != 1" />
    <parameter name="DxPic"   type="real"/>
    <parameter name="DyPic"   type="real" if="$nJ != 1" />
    <parameter name="DzPic"   type="real" if="$nK != 1" />
  </for>

#PICGRID
2			nPicGrid
  6.			xMinPic
 10.			xMaxPic
 -5.			yMinPic (read for 2D or 3D only)
  5.			yMaxPic (read for 2D or 3D only)
 -5.			zMinPic (read for 3D only)
  5.			zMaxPic (read for 3D only)
1/32			DxPic
1/32			DyPic   (read for 2D or 3D only)
1/32			DzPic   (read for 3D only)
 10.			xMinPic
 40.			xMaxPic
-10.			yMinPic (read for 2D or 3D only)
 10.			yMaxPic (read for 2D or 3D only)
 -6.0			zMinPic (read for 3D only)
  6.0			zMaxPic (read for 3D only)
1/8			DxPic
1/8			DyPic   (read for 2D or 3D only)
1/8			DzPic   (read for 3D only)

This command defines the number of PIC grids, their sizes and resolutions.
All distances are given in the BATSRUS distance units. The grid resolution 
of the PIC grid can be different from the grid resolution of BATSRUS.
When coupling with FLEKS, the number of PIC grid cells in each direction
should be a multiple of the patch sized defined by the #PICPATCH command.

The default is to have no PIC regions at all, so this command is
required for the MHD-EPIC algorithm.
</command>

<command name="PICADAPT">
  <parameter name="DoAdaptPic" type="logical" default="F" />
  <if expr="$DoAdaptPic">
    <parameter name="DnAdaptPic" type="integer" min="-1"
	       default="-1" />
    <parameter name="DtAdaptPic" type="real" min="-1"
	       default="-1" />
  </if>

#PICADAPT
T			DoAdaptPic (rest is read if true)
100			DnAdaptPic
-1.			DtAdaptPic

This command controls the PIC adaptation functionality.
This results in FLEKS
covers a fixed region using PIC by the parameters set up in 
#PICGRID. If DoAdaptPic=.true., the PIC region will be recalculated
based on the frequency (DnAdaptPic and DtAdaptPic) provided. 

Default is DoAdaptPic false.
</command>

<command name="PICPATCH">
  <parameter name="PatchSize" type="integer" default="4" min="2" />

#PICPATCH
4                        PatchSize 

PatchSize is the minimum patch size of the adaptive PIC grid
given as the number of cells in each direction, so a patch is
a square in 2D and a cube in 3D.
The PIC cells in a patch can be switched on and off together.
The number of cells in the PIC grid, which is defined by #PICGRID, 
should be divisible by the PatchSize. 

The smallest patch size is 2, and 4 is the default value. The smaller
the patch size is, the smoother the PIC boundary will be. But the PIC
code may become slower with smaller patch size. 4 or 8 are two typical 
values. 2 may slow down the code significantly.

The default value is 4.
</command>

<command name="PICPATCHEXTEND">
  <parameter name="NxExtend" type="integer" default="0" />
  <parameter name="NyExtend" type="integer" if="$nJ != 1" default="0" />
  <parameter name="NzExtend" type="integer" if="$nK != 1" default="0" />

#PICPATCHEXTEND
5			NxExtend
5			NyExtend
10			NzExtend

This command contains the number of patches extended from the PIC
region defined by #PICCRITERIA on different directions.

Default is no extension.
</command>

<command name="PICBALANCE">
  <parameter name="DoBalancePicBlock" type="logical" default="T"/>
  <parameter name="DoBalanceActivePicBlock" type="logical" default="F"/>

#PICBALANCE
T                      DoBalancePicBlock 
F                      DoBalanceActivePicBlock 

If DoBalancePicBlock is switched on, the BATSRUS blocks that are overlapped 
with the PIC domains (defined by #PICGRID) will be load balanced separatelly.

If DoBalanceActivePicBlock is true, only the BATSRUS blocks that are overlapped
with the active PIC regions, which are determined by #PICREGIONMIN and/or 
#PICREGIONMAX, are load balanced separatelly. If the GM-PC coupling is slow, 
this option is likely speed up the coupling significantly. However, it has 
two known minor side effects, which may change nightly test results but are 
acceptable for a production run:
1. After calling load balance function, the PIC adaptation criteria will be 
re-calculated. For a simulation with physics based PIC region criteria, 
running with 1 MPI or a few MPIs may produce different results, because the 
simulation with 1 MPI does not need to do load balance and the pic 
criteria will not be re-calculated. Load balancing BATSRUS blocks 
frequently may also slow down BATSRUS. 
2. Inside BATS_advance(), set_global_timestep(TimeSimulationLimit) is called, 
and the timestep is limited by TimeSimulationLimit. However, if 
load_balance_blocks() is called later, the global time step will be 
overwritten inside calc_other_vars(). 

The default is DoBalancePicBlock true, and DoBalanceActivePicBlock is false.
</command>

<command name="PICREGIONMIN">
  <parameter name="StringPicRegionMin" type="string" length="$lLine"
	     default="none"/>

#PICREGIONMIN
+daysidefixed -nearbody

The #PICREGIONMIN command sets the regions in the PIC grids that
are always active (on). 
The region strings are defined by the #REGION command.

By default there is no minimal PIC region, so any part of the PIC
domain can be switched off.
</command>

<command name="PICREGIONMAX">
  <parameter name="StringPicRegionMax" type="string" length="$lLine"
	     default="none"/>

#PICREGIONMAX
+tailsidelarge

This command defines the maximum region the PIC can cover cover.
PIC patches outside this region cannot become active. 
The region strings are defined by the #REGION commands.

By default the whole domain covered by PIC grids can become active.
</command>

<command name="PICCRITERIA">
  <parameter name='nPicCriteria' type="integer" default="1"
	     min="0" max="9" />
  <for from="1" to="$nPicCriteria">
    <parameter name="StringPicCriteria" type="string" length="$lLine"
	       input="select" >
      <option name="j/b" default="T"	/>
      <option name="j/bperp"            />
      <option name="rho"		/>
      <option name="beta"		/>
      <option name="divcurv"		/>
      <option name="entropy"            />
      <option name="speed"              />
      <option name="jy"                 />
    </parameter>
    <parameter name="MinCriteriaValue" type="real" default="0" />
    <parameter name="MaxCriteriaValue" type="real" min="$MinCriteriaValue" />
    <parameter name="CriteriaB1" type="real" default="0" if="$StringPicCriteria =~ /j\/b/"/>
  </for>

#PICCRITERIA
4			nPicCriteria
j/b			StringPicCriteria
0.1			MinCriteriaValue
999.0			MaxCriteriaValue
10.0                    CriteriaB1
j/bperp                 StringPicCriteria
0.8                     MinCriteriaValue
999.0                   MaxCriteriaValue
divcurv			StringPicCriteria
-0.1			MinCriteriaValue
999.0			MaxCriteriaValue
entropy                 StringPicCriteria
0.02                    MinCriteriaValue
999.0                   MaxCriteriaValue

This command defines the physical criteria for selecting the PIC
region.  The first input is the number of criteria. For each
criterion, there are three inputs: the name, minimum value and maximum
value.  The cell which satisfies all criteria will be active. This
physics based selection can be limited geometrically by the
#PICREGIONMIN and #PICREGIONMAX commands.

The available criteria are "rho" (for testing), "beta" (the ratio
between plasma pressure and magnetic paressure), "j/b", "j/bperp"
(current divided by magnetic field for finding current sheets),
"divcurv" (the divergence of the curvature of the magnetic field lines
to distinguish X lines from flux ropes), "speed" (bulk flow speed to exclude
magnetosheath), and "jy" (distinguish main current sheet in magnetotail).
Criteria "j/b" and "j/bperp" require an extra input parameter for B1 in the 
denominator to avoid dividing by 0. Default value of B1 is 1 nT.

By default the whole PIC region is active (possibly limited by #PICREGIONMAX).
</command>

</commandgroup>
<commandgroup name="PHYSICS PARAMETERS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!  PHYSICS PARAMETERS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="GAMMA" if="$_IsFirstSession">
  <for from="1" to="$nFluid">
    <parameter name="Gamma" type="real" min="1" default="1.6666666667"/>
  </for>
  <parameter name="GammaElectron" type="real" min="1" default="1.6666666667"
	     if="$UsePe"/> 
#GAMMA
4/3			Gamma for fluid 1
1.4			Gamma for fluid 2
5/3			GammaElectron (if UseElectronPressure)

The adiabatic index gamma = c_p/c_v (ratio of the specific heats for
fixed pressure and fixed volume). The gamma values have to be given for
each fluid and also for the electrons if there is a Pe_ variable
in the equation module.

Default is 5/3 for all the gamma-s.
</command>

<command name="PLASMA">
  <if expr="$nSpecies != 0">
    <for from="1" to="$nSpecies">
      <parameter name="MassSpecies" type="real" min="0" default="1"/>
    </for>
    <for from="1" to="$nSpecies">
      <parameter name="ChargeSpecies" type="real" default="1"/>
    </for>
  </if>
  <if expr="$nSpecies == 0">
    <for from="1" to="$nFluid">
      <parameter name="FluidMass"  type="real" min="0" default="1"/>
    </for>
    <for from="1" to="$nIonFluid">
      <parameter name="IonCharge"  type="real"         default="1"/>
    </for>
  </if>
  <parameter name="ElectronTemperatureRatio" type="real" min="0"
								default="0"/>
#PLASMA
1.0		FluidMass [amu] H+
1.0		IonCharge [e]   H+
0.5		ElectronTemperatureRatio

For single fluid, single species MHD the FluidMass parameter determines the
average mass of ions (and strongly coupled neutrals) in atomic mass units
(amu). The number density is n=rho/FluidMass.
For a pure hydrogen plasma FluidMass=1.0, while for a mix of 90 per cent
hydrogen and 10 per cent helium FluidMass=1.4.

The IonCharge parameter gives the average ion charge in units of the proton
charge. For a fully ionized hydrogen plasma AverageIonCharge=1.0,
for a fully ionized helium plasma IonCharge=2.0, while
for a 10 per cent ionized hydrogene plasma IonCharge=0.1.

For multifluid/multispcies MHD/HD the command reads the mass of all
fluids/species (ions and neutrals), and the charges of all ion
fluids/species. For example for proton and double ionized helium
and neutral oxygen molecule fluids:

#PLASMA
1.0             FluidMass H+ [amu]
4.0             FluidMass He++ [amu]
32.0		FluidMass O2 [amu]
1.0             IonCharge H+ [e]
2.0		IonCharge He++ [e]
0.2             ElectronTemperatureRatio

The ElectronTemperatureRatio determines the ratio of electron
and ion temperatures. The ion temperature Te = T * ElectronTemperatureRatio
where T is the ion temperature. The total pressure p = n*k*T + ne*k*Te,
so T = p/(n*k+ne*k*ElectronTemperatureRatio). If the electrons and ions are
in temperature equilibrium, ElectronTemperatureRatio=1.0.
For multi-fluid MHD the ElectronTemperatureRatio is interpreted as
electron pressure ratio. The electron pressure is taken as
pE = ElectronTemperatureRatio*sum(pIon_I). Note that one can also
solve the electron pressure equation if 'Pe' is present in the
equation module.

Multispecies MHD reads the mass and charge for all species in the same manner
as multifluid. But the ion charge is still assumed to be 1 in the code
and the values read in will not be used so far. ElectronTemperatureRatio
is interpreted as the single fluid case.

In a real plasma all these values can vary in space and time,
but in a single fluid/species MHD description using these constants is
the best one can do. In multispecies MHD the number density can
be determined accurately as n = sum(RhoSpecies_V/(ProtonMass*MassSpecies_V)).

The default ion/molecular masses are given in the equation module.
The default ion charges are always 1.
The default electron temperature ratio is zero, i.e. the electron
pressure is assumed to be negligible relative to the (total) ion pressure,
however in the solar wind boundary the electron pressure is set to equal
to the first ion pressure.

This default is backwards compatible with previous versions of the code.

</command>

<command name="LOOKUPTABLE" multiple="T">
  <parameter name="NameTable" type="string" length="$lLine"/>
  <parameter name="NameCommand" type="string" case="lower" input="select">
    <option name="load" default="T"/>
    <option name="use"/>
    <option name="use param"/>
    <option name="save"/>
    <option name="save param"/>
    <option name="make"/>
    <option name="make param"/>
    <option name="param"/>
  </parameter>
  <parameter name="NameFile" type="string" length="$lLine"
	     if="$NameCommand =~ /load|save|use/" />
  <parameter name="TypeFile" type="string" input="select"
	     if="$NameCommand ne 'param'">
    <option name="real8"/>
    <option name="real4" default="T"/>
    <option name="ascii"/>
    <option name="log/sat" />
  </parameter>
  <if expr="$NameCommand =~ /param/">
    <parameter name="NameTableParam" type="string" length="$lLine"/>
    <for from="1" to="count_split($NameTableParam)">
      <parameter name="TableParam" type="real"/>
    </for>
  </if>
  <if expr="$NameCommand =~ /make|save|use/">
    <parameter name="StringDescription" type="string" length="$lLine"/>
    <parameter name="NameVar"           type="string" length="$lLine"/>
    <parameter name="nIndex"            type="integer" min="1"/>
    <for name="i" from="1" to="$nIndex">
      <parameter name="nIndex$i" type="integer" min="2"/>
      <parameter name="Index${i}Min" type="real"/>
      <parameter name="Index${i}Max" type="real"/>
    </for>
  </if>

#LOOKUPTABLE
p(rho,e)			NameTable
use param			NameCommand (use, load, save, make, param)
table1.out			NameFile (read this if use/load/save)
real4				TypeFile (read this unless "param")
zXe zBe nPl			NameTableParam (if NameCommand has "param")
54.0				TableParam number of protons in Xenon
4.0				TableParam number of protons in Beryllium
4.0				TableParam number of elements in plastic
p(rho,e) for ionized plasma	Description (read this and rest unless "load")
logrho logp pXe pBe pPl		NameVar
2      	    	    		nIndex
100				nIndex1
1e-6				Index1Min
1e+6				Index1Max
50				nIndex2
0.001				Index2Min
100.0				Index2Max

Lookup tables allow interpolating one or more variables from a discrete
table. For sake of efficiency, lookup tables should have uniform indexes,
but non-uniform tables are also supported.
Tables with up to 5 indexes are supported.
Lookup tables are in the same format as structured "IDL" plotfiles.
The file format is described at the beginning of the
source code share/Library/src/ModPlotFile.f90.

Tables are identified by the NameTable string that should be unique for
the table and must agree with the name used in the ModUser module.
The NameCommand tells if we should "load" the table from a file,
"make" the table using some algorithm defined in the ModUser module,
or make the table and then "save" it into a file. The "use" option is
the same as "load" if the table file already exists, otherwise it is
the same as "save".

If NameCommand contains "param" and the table is not loaded from a file,
then the NameTableParam variable and the TableParam values of table
parameters are read from the input file and stored into the table.

The file name and file type ("real4", "real8", "ascii", "log" or "sat")
of the table are read when NameCommand contains "load", "save",
or "use". The TypeFile is also read for "make", because setting it to
"real4" implies the use of single precision storage internally as well.
This saves a factor of two in storage (both disk and memory),
which may be very significant for large lookup tables. In fact,
TypeFile=real4 is the recommended setting.

The "log" or "sat" file type corresponds to a one dimensional lookup table
where the coordinate is usually time. The time can be given by up to 7
integer columns (year, month, day, hour, sec, min, msec). The integer time
description is converted into a double precision time (number of
seconds since 01/01/1965) which is the standard representation of time
in the SWMF. These columns are identified by the space separated variable
names that are just before the "#START" string. Standard variable names
indicating the date-time information are "year" or "yr", "month" or "mo",
"day" or "dy", "min" or "mn", "sec" or "sc" and "msec" or "msc" in this
order. Alternatively the variable name can be "dateN" where N = 2...7
is the number of integers describing the date and time.
The actual data follows the line containing the "\#START" string.

The rest of the parameters are read for commands "make", "save" or "use".
The NameVar string contains the space separated list of the names of
the indexes and the one or more returned value(s). If the index name starts
with a "log", a logarithmic index is assumed (ie. the table will be uniform
in the logarithm of the index value). The nIndex parameter defines the
number of indexes (dimensionality) of the table. The nIndex1 parameter
defines the number of discrete values the first lookup index, and
Index1Min and Index1Max are the smallest and largest values for the first
index, respectively. For nIndex larger than 1, the nIndex2, Index2Min,
Index2Max parameters define the number and range of the second index, etc.

This command can occur multiple times. By default no lookup tables are used.
</command>

<command name="ADVECTION">
  <parameter name="UseAdvectionSource" type="logical" default="T"/>
  <if expr="$UseAdvectionSource">
    <parameter name="NameVarAdvectFirst" type="string" length="20"/>
    <parameter name="NameVarAdvectLast" type="string" length="20"/>
  </if>

#ADVECTION
T                      UseAdvectionSource
Rho                    NameVarAdvectFirst
Rho                    NameVarAdvectLast

If UseAdvectionSource is true, then add a source term Var*div(u) for
all variables from NameVarAdvectFirst to NameVarAdvectLast.
This could be improved to a string of variables. 

No advection source is added by default.
</command>

<command name="FRICTION">
  <parameter name="FrictionSi" type="real" min="0" default="0"/>
  <if expr="$FrictionSi&gt;0">
    <parameter name="FrictionUxDim" type="real" default="0"/>
    <parameter name="FrictionUyDim" type="real" default="0"/>
    <parameter name="FrictionUzDim" type="real" default="0"/>
  </if>

#FRICTION
0.2                    FrictionSi [1/s] (rest read if larger than 0)
0.5                    FrictionUxDim
0.0                    FrictionUyDim
0.0                    FrictionUzDim

Define a friction force against a background fluid moving at velocity
FrictionU = (FrictionUxDim, FrictionUyDim, FrictionUzDim). The force
is F = Friction*Rho*(FrictionU - U), where Friction is in normalized
units (1/time), Rho and U are the density and velocity vector of the
first fluid, respectively. The current implementation is for the first
fluid with an explicit source term.

By default there is no friction. 
</command>

<command name="GRAVITY" if="$_IsFirstSession">
  <parameter name="UseGravity" type="logical" default="F" />
  <parameter name="iDirGravity" type="integer" input="select"
	     if="$UseGravity">
    <option name="central mass" value="0" default="T"	/>
    <option name="X direction"  value="1"			/>
    <option name="Y direction"  value="2"			/>
    <option name="Z direction"  value="3"			/>
  </parameter>
  <parameter name="GravitySi" type="real" default="-10.0"
	     if="$iDirGravity&gt;0"/>

#GRAVITY
T			UseGravity (rest of parameters read if true)
3			iDirGravity(0 - central, 1 - X, 2 - Y, 3 - Z direction)
10.0			GravitySi [m/s^2] (read if iDirGravity is not 0)

If UseGravity is false, the gravitational force of the central body
is neglected. If UseGravity is true and iDirGravity is 0, the
gravity points towards the origin and the gravitational force is
determined by the mass of the central body. If iDirGravity is 1, 2 or 3,
the gravitational force is parallel with the X, Y or Z axes, respectively,
and the gravitational acceleration is given by the GravitySi parameter.

Default values depend on problem_type.

When a second body is used the gravity direction for the second body
is independent of the GravityDir value.  Gravity due to the second body
is radially inward toward the second body.
</command>


<command name="ARTIFICIALVISCOSITY">
  <parameter name="UseArtificialViscosity" type="logical" default="F"/>
  <parameter name="AlphaVisco" type="real" min="0"
	     if="$UseArtificialViscosity"  />
  <parameter name="BetaVisco" type="real" min="0"
	     if="$UseArtificialViscosity"  />

#ARTIFICIALVISCOSITY
T		UseArtificialViscosity
0.3             AlphaVisco
0.3             BetaVisco

This command adds artificial viscosity (diffusion) to the density, moments
and pressure equations based on the section 2.5.2 of the  paper by
P. McCorquodale and P. Colella (2010). The larger/smaller AlphaVisco/BetaVisco
is the larger the artificial viscosity will be. AlphaVisco should be non-negative
and BetaVisco should be positive. The recommended values are shown above.

Default is no artificial viscosity.
</command>


<command name="VISCOSITY">
	 <parameter name="UseViscosity" type="logical" default="F"/>
	 <parameter name="ViscoCoeffSi" type="real" min="0"
	 	    if="$UseViscosity"				  />
#VISCOSITY
T		UseViscosity
0.01		ViscosityCoeffSi [m2/s] (read if UseViscosity is true)

If UseViscosity is true, apply Navier-Stokes type
viscosity using the viscosity coefficient ViscoCoeffSi.

Default is no viscosity.
</command>

<command name="VISCOSITYREGION">
  <parameter name="StringViscoRegion" type="string" length="$lLine"
	     case="lower" default="none"/>

#VISCOSITYREGION
+magnetotail -nearbody		StringViscoRegion

This command is only useful if viscosity is switched on with
the #VISCOSITY command.

The StringViscoRegion string can specify the region(s) where
viscosity is used.  The regions must be described with the #REGION
commands.  Note the 'tapered' option in the shape desciption that can
be used to make the transition smoother.

The default is to apply viscosity everywhere if the it is switched on.
</command>

<command name="RESISTIVITY">
  <parameter name="UseResistivity" type="logical" default="F"	/>
  <if expr="$UseResistivity">
    <parameter name="TypeResistivity" type="string" case="lower"
	       input="select" >
      <option name="constant" default="T"/>
      <option name="spitzer"             />
      <option name="anomalous"           />
      <option name="user"                />
    </parameter>
    <if expr="$TypeResistivity =~ /spitzer/">
      <parameter name="CoulombLogarithm" type="real"
		 default="20" />
    </if>
    <if expr="$TypeResistivity =~ /constant/">
      <parameter name="Eta0Si" type="real" min="0.0"
		 default="1.0E+11"/>
    </if>
    <if expr="$TypeResistivity =~ /anomalous/">
      <parameter name="Eta0Si" type="real" min="0.0"
		 default="1.0E+9"/>
      <parameter name="Eta0AnomSi" type="real"
		 default="2E+09"	/>
      <parameter name="EtaMaxAnomSi" type="real"
		 default="2E+10"	/>
      <parameter name="jCritAnomSi" type="real" min="0"
		 default="1.0E-9"/>
    </if>
    <if expr="$TypeResistivity =~ /user/">
      <parameter name="Eta0Si" type="real" min="0.0"
		 default="1.0"/>
    </if>
  </if>
#RESISTIVITY
T		UseResistivity (rest of parameters read only if set to true)
anomalous	TypeResistivity
1.0E+9		Eta0Si       [m2/s] (read except for Spitzer resistivity)
2.0E+9		Eta0AnomSi   [m2/s] (read for anomalous resistivity only)
2.0E+10		EtaMaxAnomSi [m2/s] (read for anomalous resistivity only)
1.0E-9		jCritAnomSi  [A/m2] (read for anomalous resistivity only)

The true SI units of resistivity are Ohm m = $N m^2 / (A^2 s)$.
In BATSRUS, however, we use "normalized" units, so that the magnetic
permeability $[N/A^2]$ disappers from the equations. So what is
described here as "resistivity", is really eta/mu_0 which has units of $[m^2/s]$,
same as (magnetic) diffusion. Since the normalized current is defined as curl B
(instead of curl B/mu0), the electric field is E = -u x B + eta * J in the
normalized units.

If UseResistitivy is false, no resistivity is included.
If UseResistivity is true, then one can select a constant resistivity,
the classical Spitzer resistivity,
anomalous resistivity with a critical current, or a user defined resistivity.

For TypeResistivity='Spitzer' the resistivity is very low in space plasma.
The only parameter read is the CoulombLogarithm parameter with
typical values in the range of 10 to 30. Note that this can also be
set with the #COULOMBLOG command.

For TypeResistivity='constant' the resistivity is uniformly set to
the parameter Eta0Si.

For TypeResistivity='anomalous' the anomalous resistivity is
Eta0Si + Eta0AnomSi*(j/jCritAnomSi-1) limited by 0 and EtaMaxAnomSi.
Here j is the absolute value of the current density in SI units.
See the example for the order of the parameters.

For TypeResistivity='user' only the Eta0Si parameter is read and it
can be used to scale the resistivity set in subroutine user_set_resistivity
in the ModUser module. Other parameters should be read with
subroutine user_read_inputs of the ModUser file.

The default is UseResistivity=.false.
</command>

<command name="COULOMBLOG">
  <parameter name="CoulombLog" type="real" min="0" default="20.0"/>
#COULOMBLOG
20.0			CoulombLog  

Set the Coulomb logarithm for Spitzer resistivity and heat conduction.
Default value is shown.
</command>
  
<command name="RESISTIVITYOPTIONS">
  <parameter name="UseResistiveFlux" type="logical" default="T"/>
  <parameter name="UseJouleHeating"  type="logical" default="T"/>
  <parameter name="UseHeatExchange"  type="logical" default="T"/>
#RESISTIVITYOPTIONS
T			UseResistiveFlux
T			UseJouleHeating
F			UseHeatExchange

Switch off negligible resistivity effects for sake of computational speed.
If UseResistiveFlux is false, the resistive terms in the induction equation
are neglected. If UseJouleHeating is false and non-conservative equations
are used then the Joule heating is neglected in the electron/ion pressure
equation. If UseHeatExchange is false, the heat exchange between electron
and ion pressures is neglected.

The defaults are true for all three logicals.
</command>

<command name="RESISTIVEREGION" alias="RESISTIVITYREGION">
  <parameter name="StringResistRegion" type="string" length="$lLine"
	     case="lower" default="none"/>

#RESISTIVEREGION
+magnetotail -nearbody		StringResistRegion

This command is only useful is the resistivity is switched on with
the #RESISTIVITY command.

The StringResistRegion string can specify the region(s) where
resistivity is used.  The regions must be described with the #REGION
commands.  Note the 'tapered' option in the shape desciption that can
be used to make the transition smoother.

The default is to apply the resistive MHD scheme everywhere if it is switched on.
</command>

<command name="HALLRESISTIVITY">
  <parameter name="UseHallResist" type="logical" default="F"/>
  <parameter name="HallFactorMax" type="real" min="0"
	     default="1"/>
  <parameter name="HallCmaxFactor" type="real" min="0" max="1"
	     default="1"/>

#HALLRESISTIVITY
T		UseHallResist
1.0		HallFactorMax
0.1		HallCmaxFactor

If UseHallResist is true the Hall resistivity is used.
All parameters are read even if it is false to allow setting
the kinetic scaling equal to HallFactorMax for MHD-EPIC,
although it is better to use the #PICGRIDUNIT command for this purpose.

The off-diagonal Hall elements of the resistivity tensor
are multiplied by HallFactorMax. If HallFactorMax is 1 then the
physical Hall resistivity is used (but also see the #HALLREGION command).
Note that a physically consistent way of changing the strength of the
Hall effect is changing the ion mass and/or charge with the #PLASMA command.

If HallCmaxFactor is 1.0, the maximum propagation speed takes into
account the full whistler wave speed. If it is 0, the wave speed
is not modified. For values betwen 1 and 0 a fraction of the whistler
wave speed is added. The full speed is needed for the stability
of the one or two-stage explicit scheme
(unless the whistler speed is very small and/or the diagonal part of
the resistivity tensor is dominant).
For 3 and 4-stage explicit schemes (see the #RK command) and also
for the semi-implicit and implicit time stepping the HallCmaxFactor
can be reduced, possibly all the way to zero to minimize the discretization
errors. If the (semi-)implicit scheme does not converge well, using
HallCmaxFactor larger than zero (for example 0.1) can help.

Default is UseHallResist false.
</command>

<command name="HALLREGION">
  <parameter name="StringHallRegion" type="string" length="$lLine"
	     case="lower" default="none"/>

#HALLREGION
+magnetotail -nearbody		StringHallRegion

This command is only useful if the Hall MHD scheme is switched on with
the #HALLRESISTIVITY command.

The StringHallRegion string can specify the region(s) where the Hall
resistivity is used.  The regions must be described with the #REGION
commands. Note the 'tapered' option in the shape desciption that can
be used to make the transition smoother.

Each region has its own Hall factor, which is the 'Weight' associated
with the #REGION command. If 'Weight' is not read in, then HallFactorMax,
which is set by #HALLRESISTIVITY, is used as the default. 

The default is to apply the Hall MHD scheme everywhere if it is switched on.
</command>

<command name="BIERMANNBATTERY">
  <parameter name="UseBiermannBattery" type="logical" default="F"/>

#BIERMANNBATTERY
T		UseBiermannBattery

If UseBiermannBattery is true then the Biermann battery term in the
generalized Ohm's law is used, otherwise it is switched off.

If the Hall term is used in combination with the electron pressure
equation then the Biermann battery term is switched on by default.
In that case the BIERMANNBATTERY command is not needed.

Default is UseBiermannBattery false.
</command>

<command name="MINIMUMDENSITY">
  <for from="1" to="$nFluid">
    <parameter name="RhoMinDim" type="real" min="-1" default="-1"/>
  </for>

#MINIMUMDENSITY
0.001		RhoMinDim for fluid 1
-1.0		RhoMinDim for fluid 2

Provide minimum density(s) for the ion/neutral fluid(s). If the minimum
density is positive, the density is kept above this limit for that fluid.
The minimum density is given in the input/output units for density,
which varies from application to application.
A negative value indicates that no minimum density is applied for that fluid.

By default no minimum density limit is applied.
</command>

<command name="MINIMUMPRESSURE">
  <for from="1" to="$nFluid">
    <parameter name="pMinDim" type="real" min="-1" default="-1"/>
  </for>
  <parameter name="PeMinDim" type="real" min="-1" default="-1" if="$UsePe"/>

#MINIMUMPRESSURE
0.001		pMinDim for fluid 1
-1.0		pMinDim for fluid 2
0.002		PeMinDim for electron pressure (if used)

Provide minimum pressure(s) for the ion/neutral fluid(s) and electrons.
If the pMinDim is positive, the pressure is kept above this limit for
that fluid.
The minimum pressure is given in the input/output units for pressure,
which varies from application to application.
A negative value indicates that no minimum density is applied for that fluid.

By default no minimum pressure limit is applied.
</command>

<command name="MINIMUMTEMPERATURE">
  <for from="1" to="$nFluid">
    <parameter name="TminDim" type="real" min="-1" default="-1"/>
  </for>
  <parameter name="TeMinDim" type="real" min="-1" default="-1" if="$UsePe"/>

#MINIMUMTEMPERATURE
5e4		TminDim for fluid 1
-1.0		TminDim for fluid 2
2e4             TeMinDim for electron pressure (if used)

Provide minimum temperature(s) for the ion/neutral fluid(s) and electrons.
If the minimum temperature (TMinDim) is positive, the temperature is kept above
this limit. The minimum temperature is given in Kelvin.
A negative value indicates that no minimum temperature is applied for that
fluid.

By default no minimum temperature limit is applied.
</command>

<command name="MINIMUMRADIALSPEED">
	<parameter name="UseSpeedMin" type="logical" default="F"/>
	<if expr="$UseSpeedMin">
		<parameter name="rSpeedMin" type="real" min="1"
			   default="10"/>
                <parameter name="SpeedMinDim" type="real" min="0"
			   default="250" />
                <parameter name="TauSpeedMinDim" type="real" min="1"
			   default="10 h" />
         </if>

#MINIMUMRADIALSPEED
T		UseSpeedMin
10		rSpeedMin
250		SpeedMinDim
10 h		TauSpeedMinDim

If UseSpeedMin is true, the minimum speed is enforced. If the radial speed
falls below SpeedMin beyond the radial distance rSpeedMin, then
a force is applied (via a source term) to push the solar wind speed 
above SpeedMin with a time rate TauSpeedMinDim.

By default no minimum speed limit is applied.
</command>

<command name="ELECTRONPRESSURE">
  <parameter name="PeMinSi" type="real" min="-1" default="-1"/>

#ELECTRONPRESSURE
1.1e5			PeMinSi

Provide the minimum electron pressure threshold in SI units.
Currently the minimum electron pressure is only used in ModRadDiffusion.
The default value is -1, i.e. no threshold is applied.
</command>

<command name="ELECTRONENTROPY">
  <parameter name="UseElectronEntropy" type="logical" default="T"/>
  <parameter name="UseElectronEnergy"  type="logical" default="F"/>

#ELECTRONENTROPY
T			UseElectronEntropy
F                       UseElectronEnergy

If UseElectronEntropy is true, solve for the electron entropy Se defined as
Se = Pe**(1/GammaE). The electron entropy, unlike electron pressure,
satisfies a pure conservation law, so it is well behaved across shocks.

If UseElectronEnergy is also true, include electron energy into the total
energy equation for the conservative scheme so that total energy is
conserved.

The combination UseElectronEntropy false and UseElectronEnergy true
is not recommended as it requests total energy conservation but using
a non-conservative electron pressure equation, and
some of the implementation may not allow for this combination.

Explicit electron heatconduction is not implemented for the electron entropy,
but the semi-implicit heat conduction works.

The default values are shown above. Note that #SHOCKHEATING switches
both logicals to true.
</command>

<command name="ENTROPY">
  <parameter name="UseIonEntropy" type="logical" default="F"/>
  <parameter name="UseTotalIonEnergy" type="logical" default="F"
	     if="$nIonFluid != 1"/>

#ENTROPY
T			UseIonEntropy
T                       UseTotalIonEnergy (only read for multi-ion equations)

If UseIonEntropy is true and the ion pressure is isotropic,
then  solve for the ion entropy density s defined as
s = P**(1/Gamma). The ion entropy, unlike ion pressure,
satisfies a pure conservation law, so it is well behaved across shocks.
If the ion pressure is anisotropic, then solve for Sperp = Pperp/B
and Spar = Ppar*(B/rho)**2.

For multiion case the UseTotalIonEnergy parameter is read. If it is
true, the total ion energy equation is solved, which is in conservation
form. This is not yet implemented.

The default value of UseIonEntropy and UseTotalIonEnergy are false,
except when the #SHOCKHEATING command is used, which requires and sets
UseIonEntropy=T and UseTotalIonEnergy=T in the multiion case.
</command>

<command name="SHOCKHEATING">
  <parameter name="PeShockHeatingFraction" type="real"
	     min="-1" max="1" default="0" if="$UsePe"/>
  <parameter name="PparShockHeatingFraction" type="real"
	     min="-1" max="1" default="0" if="$UsePpar"/>
  <for from="2" to="$nIonFluid">
    <parameter name="PiShockHeatingFraction" type="real"
	       min="-1" max="1" default="0"/>
  </for>

#SHOCKHEATING
0.5      PeShockHeatingFraction (read if electron pressure is used)
1.0      PparShockHeatingFraction (read if ion pressure is anisotropic)
-0.4     PiShockHeatingFraction for ion fluid 2 (if exists)
-0.1     PiShockHeatingFraction for ion fluid 3 (if exists)

If electron pressure is solved for and PeShockHeatingFraction is
set to a positive value, this fraction of the non-adiabatic
heating is deposited into the electron thermal energy Pe/(GammaE-1)
between the electrons and the first ion fluid. For a negative value
the weights are multiplied by the number densities to the (2-gamma)
power.

If anisotropic ion pressure is solved for and PparShockHeatingFraction
is set to a positive value, then a fraction of
the non-adiabatic heating is deposited into the parallel ion energy,
and the same amount of energy is removed from the perpendicular ion
energy.  If PparShockHeatingFraction is negative, then the fraction of
heating going into the parallel pressure is abs(b.u), where b and u
are the unit vectors for the magnetic field and velocity,
respectively.

If multiple ion fluids are solved for and PiShockHeatingFraction is
set to a positive value for ion fluid iFluid (2...nIonFluid), then this
fraction of the non-adiabatic heating is deposited into fluid iFluid
between the first and iFluid-th ion fluids.
If PiShockHeatingFraction is set to a negative value, then
the fluid weights are multiplied with the number densities to the (2-gamma)
power, which results in correct heating of two fluids with equal
ion masses, velocities and temperatures but different number densities.

If this command is used, UseIonEntropy, UseTotalIonEnergy and
UseElectronEntropy are set to true (see #ENTROPY and #ELECTRONENTROPY).

Note that the fractions describe ratio of entropies, not energies.
The scheme conserves the total energy and the linear combination of
entropies Weight2*Entropy1 - Weight1*Entropy2, where Weight1 and
Weight2=1-Weight1 are obtained from the various fractions defined by
the command, while Entropy1 and Entropy2 are the volumetric
entropy densities, for example $p/rho^\gamma$ for the isotropic case.
For isotropic pressure and the same gamma for ions and electrons
the entropies and thermal energy densities $p/(\gamma-1)$ are closely
related. For anisotropic ion pressure the entropy densities depend on
the magnetic field too, which makes things complicated.

Default values are 0, which means that all shock heating goes to the
(perpendicular) ion pressure. For the multiion case, total energy is
only conserved if UseTotalIonEnergy is set to true (either here or in
the #ENTROPY command), otherwise the magnetic energy is
ignored. Solving for individual ion energies will transfer some shock
heating into both ion fluids, but it may not be the correct
distribution. This can be improved by using this command and
prescribing the energy distribution.
</command>

<command name="ANISOTROPICPRESSURE">
  <for from="1" to="$nFluid">
    <parameter name="UseConstantTau" type="logical" default="F"/>
    <parameter name="TauInstabilitySi" type="real" default="-1"/>
    <parameter name="TauGlobalSi" type="real" default="-1"/>
  </for>

#ANISOTROPICPRESSURE
T			UseConstantTau fluid 1
10			TauInstabilitySi
100			TauGlobalSi
T			UseConstantTau fluid 2
10			TauInstabilitySi
100			TauGlobalSi

Set parameters for the pressure relaxation term for each fluid. Note that
in the previous version, TauInstabilitySi will only be read if UseConstantTau
is true. However, this version TauInstabilitySi will be read even
UseConstantTau is false.

If UseConstantTau is set to false, use the growth-rate based relaxation time.
This is the default for single ion fluid and also recommended.

If UseConstantTau is set to true (default for multiple ion fluids),
then TauInstabilitySi provides the exponential relaxation time
in seconds to restrict the pressure anisotropy in unstable regions. Within the
time, the parallel pressure is pushed towards plasma instability limits.
The default value is -1, i.e, do not apply the pressure relaxation due to
instabilities. If applied, a typical value for magnetospheric simulations
is 10 seconds.

TauGlobalSi provides the global pressure exponential relaxation time in seconds
applied in the whole domain. Within the time, the parallel pressure
is pushed towards the total scalar pressure. In the presence of both
the instability and global relaxation, the one that changes pressure
more will be used for the pressure relaxation term.
The default value for TauGlobalSi is -1, i.e. do not apply the global
relaxation.
The example shows a recommended value for magnetospheric simulations.

When UseConstantTau = T and TauInstabilitySi = -1, the pressure relaxation
term is not applied, thus TauGlobalSi is meaningless in this case.
</command>

<command name="EXTRAINTERNALENERGY">
	 <parameter name="ExtraEintMinSi" type="real" default="0"/>

#EXTRAINTERNALENERGY
-1e3			ExtraEintMinSi

Provide the minimum extra internal energy density threshold in SI units.
The extra internal energy density is the difference between true
internal energy density and the p/(gamma-1) of the ideal gas.
Using a large enough gamma (e.g. 5/3) can guarantee that the
difference is always non-negative. The default value is zero.
</command>

<command name="RADIATION">
  <parameter name="UseRadDiffusion" type="logical" default="F"/>
  <if expr="$UseRadDiffusion">
    <parameter name="UseRadFluxLimiter" type="logical"
	       default="F"/>
    <parameter name="TypeRadFluxLimiter" type="string"
	       case="lower" input="select" if="$UseRadFluxLimiter">
      <option name="larsen"  default="T" />
      <option name="sum"	   	   />
      <option name="max"		   />
    </parameter>
    <parameter name="TradMinSi" type="real" min="0" default="300"/>
  </if>

#RADIATION
T		UseRadDiffusion    (rest of parameters read only if true)
T		UseRadFluxLimiter
larsen		TypeRadFluxLimiter (read only if UseRadFluxLimiter is true)
300.0		TradMinSi

If UseRadDiffusion is true the radiation hydrodynamics with
radiation nonequilibrium diffusion approximation is used.

If the UseRadDiffusion is set to true, then optionally a non-linear
flux limiter can be invoked via UseRadFluxLimiter set to true.
This limits the radiation diffusion flux so that it does not
exceed the optically thin streaming limit, the speed of light.
The type of flux limiter can be selected by setting TypeRadFluxLimiter.

If TypeRadFluxLimiter="sum", then Wilson's sum flux limiter is used.
If TypeRadFluxLimiter="max", then Wilson's max flux limiter is used.
For TypeRadFluxLimiter="larsen" the square-root flux limiter of Larsen is used.

The TradMinSi parameter sets a minimum temperature in Kelvins
for the radiation. This helps avoiding negative radiation temperature due
to numerical errors. A recommended value is 300K.

The default for UseRadFluxLimiter is false.
</command>

<command name="HEATFLUXLIMITER">
  <parameter name="UseHeatFluxLimiter" type="logical" default="F"/>
  <if expr="$UseHeatFluxLimiter">
    <parameter name="HeatFluxLimiter" type="real" min="0"
	       default="0.06"/>
  </if>
#HEATFLUXLIMITER
T			UseHeatFluxLimiter
0.06			HeatFluxLimiter

If UseHeatFluxLimiter is set to false, the original Spitzer-Harm formulation
for the collisional isotropic electron thermal heat conduction is used as set
by the #SEMIIMPLICIT command.

If UseHeatFluxLimiter is set to true, this isotropic heat conduction is
modified to correct the heat conduction coefficient if the electron
temperature length scale is only a few collisonal mean free paths of the
electrons or smaller. The flux limited heat conduction that is used in
this case is the threshold model.

If we define the free streaming flux as  F_fs = n_e*k_B*T_e*v_th,
where v_th = sqrt(k_B*T_e/m_e) is a characteristic thermal velocity, then
the threshold model limits the heat conduction flux F = -kappa*grad(Te),
with heat conduction coefficient kappa, by
   F = -min(kappa, f*F_fs / |grad(Te)|) * grad(Te)
Here, f is the heat flux limiter.

A possible application of interest for the heat flux limiter is
laser-irradiated plasmas. For this limiter to work properly, the
thermodynamic quanties in the user_material_properties subroutine in the
ModUser module need to be defined (see ModUserCrash for an example).

The default for UseHeatFluxLimiter is false.
</command>

<command name="LASERPULSE">
  <parameter name="UseLaserHeating" type="logical" default="F"/>
  <if expr="$UseLaserHeating">
    <parameter name="IrradianceSi" type="real" min="0"/>
    <parameter name="tPulse" type="real" min="0"/>
    <parameter name="tRaise" type="real" min="0"/>
    <parameter name="tDecay" type="real" min="0"/>
  </if>

#LASERPULSE
T		UseLaserHeating (rest of parameters are read if true)
3.8e10		IrradianceSI [J/s]
1.0e-10		tPulse [s]
1.0e-11		tRaise [s]
1.0e-11		tDecay [s]

This command is used for CRASH applications and it requires a CRASH related
user file.

Read parameters for the laser pulse. The irradiance determines the energy
per second. The length, rise, and decay times are given by the other three
parameters. The laser heating is switched off by default.
</command>

<command name="LASERBEAMS">
  <parameter name="TypeBeam" type="string" case="lower" input="select">
    <option name="rz" default="T"/>
    <option name="3d"            />
  </parameter>
  <if expr="$TypeBeam =~ /rz/">
    <parameter name="nRayPerBeam" type="integer" min="1" default="30"/>
  </if>
  <if expr="$TypeBeam =~ /3d/">
    <parameter name="TypeBeamCoordinates" type="string"
	       case="lower" input="select">
      <option name="polar"     default="T"/>
      <option name="cartesian"            />
    </parameter>
    <if expr="$TypeBeamCoordinates =~ /polar/">
      <parameter name="nRayR" type="integer" min="1" default="900"/>
      <parameter name="nRayPhi" type="integer" min="1" default="4"/>
    </if>
    <if expr="$TypeBeamCoordinates =~ /cartesian/">
      <parameter name="nRayY" type="integer" min="1" default="50"/>
      <parameter name="nRayZ" type="integer" min="1" default="50"/>
    </if>
  </if>
  <parameter name="rBeam" type="real" min="0"/>
  <parameter name="xBeam" type="real"/>

#LASERBEAMS
rz		TypeBeam
30		nRayPerBeam
438.0		rBeam
-290.0		xBeam

This command is used for CRASH applications and it requires a CRASH related
user file. This command should be used together with the  #LASERPULSE command.

The TypeBeam determines the geometry of the beams. Currently all beam
definition are only available for rz-geoemrty.

For TypeBeam=rz, each beam consists of 2*nRayPerBeam+1 rays.
The rays are parallel and are up to 1.5 rBeam away from the central ray.
The xBeam determines the starting X position of the rays.

For TypeBeam=3d in rz-geometry there is the option for a beam definition on
a polar or cartesian grid (The grid is defined orthogonal to the initial ray
propagation direction). On a polar grid the rays locations are defined on
a uniform grid with nRayR rays in the radial direction from 0 to 1.5*rBeam and
nRayPhi+1 rays in the angle direction from 0 to pi. Due to symmetry properties
in the laser beams the angle from pi to 2*pi are not needed.
On a cartesian grid the ray locations are defined on a 2*nRayY+1 by nRayZ+1
uniform grid. The y-direction ranges from -1.5*rBeam to 1.5*rBeam. Due to
symmetry in each beam the z-direction is limited between 0 and 1.5*rBeam.

</command>

<command name="LASERBEAM" multiple="T">
  <parameter name="SlopeDeg" type="real"/>
  <parameter name="yBeam"    type="real"/>
  <parameter name="AmplitudeRel" type="real" min="0"/>

#LASERBEAM
10.0		SlopeDeg
0.0		yBeam
1.0		AmplitudeRel

This command is used for CRASH applications and it requires a CRASH related
user file. This command should be used together with the  #LASERPULSE command.

The SlopeDeg parameter determines the direction of the beam relative to the
X axis. The yBeam has to do with the Y coordinate of the initial positions.
The AmplitudeRel gives the relative intensity of the beam.
</command>

<command name="LASERBEAMPROFILE">
         <parameter name="SuperGaussianOrder" type="real"/>

#LASERBEAMPROFILE
4.2             SuperGaussianOrder

This command is used for CRASH applications and it requires a CRASH related
user file. This command should be used together with the  #LASERPULSE command.

The SuperGaussianOrder parameter determines the profile of each laser beam.
The irradiance profile of the beam is of the form
exp[ - (r / rBeam)**SuperGaussianOrder],
where r is the distance to the tilted central ray of the beam and rBeam is
defined by the #LASERBEAMS command. The default value for SuperGaussianOrder
is 4.2
</command>

<command name="MASSLOADING">
  <parameter name="UseMassLoading" type="logical" default="F"/>
  <parameter name="DoAccelerateMassLoading" type="logical" default="F"/>
#MASSLOADING
F			UseMassLoading
F			DoAccelerateMassLoading
</command>

<command name="HEATCONDUCTION">
  <parameter name="UseHeatConduction"    type="logical" default="F"/>
  <if expr="$UseHeatConduction">
    <parameter name="TypeHeatConduction" type="string" case="lower"
               input="select" >
      <option name="spitzer" default="T"/>
      <option name="user"               />
    </parameter>
  </if>

#HEATCONDUCTION
T			UseHeatConduction
spitzer			TypeHeatConduction

If UseHeatConduction is false, no heat conduction is included.
If UseHeatConduction is true, then one can select the collisional
heat conduction of Spitzer or a user defined heat conduction.
Both heat conduction formulations are field-aligned and are only applied
to the electrons.

For TypeHeatConduction='spitzer' a spatially uniform Coulomb logarithm
of 20 is assumed by default, resulting in a heat conduction coefficient of
\begin{verbatim}
9.2e-12 W m^-1 K^-7/2.
\end{verbatim}
Fully ionized hydrogen plasma is assumed. The Coulomb logarithm can
be modified with the #COULOMBLOG command.

For TypeHeatConduction='user' the heat conduction coefficient of the
field-aligned heat conduction is read from the user_material_properties
subroutine in the ModUser module. Optional parameters should be read with
subroutine user_read_inputs of the ModUser file.

The default is UseHeatConduction=.false.

</command>

<command name="IONHEATCONDUCTION">
  <parameter name="UseIonHeatConduction"    type="logical" default="F"/>
  <if expr="$UseIonHeatConduction">
    <parameter name="TypeIonHeatConduction" type="string" case="lower"
               input="select" >
      <option name="spitzer" default="T"/>
      <option name="user"               />
    </parameter>
  </if>

#IONHEATCONDUCTION
T			UseIonHeatConduction
spitzer			TypeIonHeatConduction

If UseIonHeatConduction is false, no proton heat conduction is included.
If UseIonHeatConduction is true, then one can select the classical
Coulomb-mediated ion heat conduction or a user defined heat conduction.
Both heat conduction formulations are field-aligned and are only applied to
the protons.

For TypeIonHeatConduction='spitzer' a spatially uniform Coulomb logarithm
of 20 is assumed by default, resulting in a heat conduction coefficient of
\begin{verbatim}
2.6e-13 W m^-1 K^-7/2
\end{verbatim}
for protons. A non-default value can be set with the #COULOMBLOG command.

For TypeIonHeatConduction='user' the heat conduction coefficient of the
field-aligned heat conduction is read from the user_material_properties
subroutine in the ModUser module. Optional parameters should be read with
subroutine user_read_inputs of the ModUser file.

The default is UseIonHeatConduction=.false.

</command>

<command name="HEATFLUXREGION">
  <parameter name="UseHeatFluxRegion"  type="logical" default="T"/>
  <if expr="$UseHeatFluxRegion">
    <parameter name="rCollisional"   type="real" />
    <parameter name="rCollisionless" type="real" />
  </if>

#HEATFLUXREGION
T                       UseHeatFluxRegion
5.0                     rCollisional
8.0                     rCollisionless

If UseHeatFluxRegion is false, the electron heat conduction (as set by the
#HEATCONDUCTION command), is applied everywhere.

If UseHeatFluxRegion is true, the electron heat conduction is multiplied with
a geometrical function depending on the sign of rCollisionless.
If rCollisionless is smaller than zero, then the electron heat is multiplied by
\[
f_{S} = \frac{1}{1+(r/rCollisional)^2}.
\]
If rCollisionless is positive, then the electron heat conduction coefficient
is multiplied by
\[
f_{S} = exp(-((r-rCollisional)/(rCollisionless-rCollisional))**2).
\]
In both cases, if the #HEATFLUXCOLLISIONLESS command is set, then the
polytropic index in the electron pressure equation is smoothly interpolated
between $\gamma$ in the collisional regime and $\gamma_{H}$ in the
collisionless regime:
\[
\gamma_{e} = \gamma f_{S} + \gamma_{H}(1-f_{S}),
\]
where $\gamma_{H}$ is defined in the #HEATFLUXCOLLISIONLESS command.

The default is UseHeatFluxRegion=.true.

</command>

<command name="HEATFLUXCOLLISIONLESS">
  <parameter name="UseHeatFluxCollisionless"   type="logical" default="F"/>
  <if expr="$UseHeatFluxCollisionless">
    <parameter name="CollisionlessAlpha" type="real" default="1.05" />
  </if>

#HEATFLUXCOLLISIONLESS
T                       UseHeatFluxCollisionless
1.05                    CollisionlessAlpha

If UseHeatFluxCollisionless is true, an empirical model is used to mimic the
collisionless electron heat conduction (Hollweg, J.V., 1978). This empirical model
reduces the polytropic index in the electron pressure equation to
\[
  \gamma_{H} = \frac{\gamma + \frac32(\gamma-1)\alpha}
        {1 + \frac32(\gamma-1)\alpha},
\]
where $\gamma = 5/3$ and $\alpha$ is the input parameter CollisionlessAlpha.
For the default value $\alpha=1.05$, the polytropic index for the electron pressure
equation is reduced to $\gamma_{H} \approx 1.33$. The collisionless heat flux
only works if the equation module contains the state variable Ehot_.
See van der Holst et al. 2014 for more details on this empirical model.

The default is UseHeatFluxCollisionless=.false.

</command>

<command name="SECONDBODY" if="$_IsFirstSession">
  <parameter name="UseBody2" type="logical" default="F"/>
  <if expr="$UseBody2">
    <parameter name="rBody2" type="real" min="0"
	       default="0"/>
    <parameter name="MassBody2Si" type="real" default="0"/>
    <parameter name="Body2NDim" type="real" min="0" default="1" />
    <parameter name="Body2TDim" type="real" min="0" default="1000"/>
    <parameter name="UseBody2Orbit" type="logical" default="F"/>
    <if expr="not $UseBody2Orbit">
      <parameter name="xBody2" type="real" min="$xMin" max="$xMax"
		 default="0"/>
      <parameter name="yBody2" type="real" min="$yMin" max="$yMax"
		 default="0" />
      <parameter name="zBody2" type="real" min="$zMin" max="$zMax"
		 default="0" />
    </if>
  </if>

#SECONDBODY
T			UseBody2 ! Rest of the parameters read if true
1.0			rBody2
0.                      MassBody2Si [kg] ! If 0, the second body gravity is 0
1.0			Body2NDim [/cc] density for fixed BC for rho_BLK
1000.0			Body2TDim [K] temperature for fixed BC for P_BLK
F			UseBody2Orbit
1.			xBody2  ! only read if UseBody2Orbit is false
0.			yBody2  ! only read if UseBody2Orbit is false
0.			zBody2  ! only read if UseBody2Orbit is false

Defines the radius, position, surface density and temperature,
of a second body. The second body may also have magnetic field given by
the #DIPOLEBODY2 command. This command should appear before the
#INNERBOUNDARY command when using a second body. MassBody2Si is used to
calculate the gravity force.

If UseBody2Orbit is .true., the orbit of the second body is traced using
orbit elements set in CON_planet in the shared module, assuming that
the central body is the Sun (or a star set in CON_star), so that the
orbit elements are set in the HGI coordinate system. In this case,
xBody2, yBody2, zBody2 are not read. Otherwise the position of the
second body is defined by xBody2, yBody2, and zBody2.

Default is UseBody2 false.
</command>

<command name="DIPOLEBODY2" if="$_IsFirstSession">
  <parameter name="BdpDimBody2x" type="real" />
  <parameter name="BdpDimBody2y" type="real" />
  <parameter name="BdpDimBody2z" type="real" />

#DIPOLEBODY2
0.0			BdpDimBody2x [nT]
0.0			BdpDimBody2y [nT]
-1000.0			BdpDimBody2z [nT]

The BdpDimBody2x, BdpDimBody2y and BdpDimBody2z variables contain
the 3 components of the dipole vector in the GSE frame.
The absolute value of the dipole vector is the equatorial field strength
in nano Tesla.

Default is no dipole field for the second body.
</command>

</commandgroup>

<commandgroup name="CORONA SPECIFIC COMMANDS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!! CORONA SPECIFIC COMMANDS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

<command name="FACTORB0">
  <parameter name="FactorB0" type="real" min="0.0" default="1.0"/>

#FACTORB0
1e-4                    FactorB0  

FactorB0 is a multiplication factor for the magnetogram based potential
field B0. It can be used to correct the magnetic field units
(default is Gauss) or to change the strength of the field.

Default value is 1.
</command>

<command name="HARMONICSGRID">
  <parameter name="rMagnetogram"   type="real" min="0"  default="1"  />
  <parameter name="rSourceSurface" type="real"          default="2.5"
	                                       min="$rMagnetogram"   />
  <parameter name="IsLogRadius" type="logical"          default="F"  />
  <parameter name="MaxOrder"    type="integer" min="1"  default="30" />
  <parameter name="nR"          type="integer" min="10" default="30" />
  <parameter name="nLon"        type="integer" min="10" default="72" />
  <parameter name="nLat"        type="integer" min="10" default="30" />

#HARMONICSGRID
1.0			rMagnetogram
2.5			rSourceSurface
F                       IsLogRadius
30                      MaxOrder
30                      nR
72                      nLon
30                      nLat

#HARMONICSGRID
1.0			rMagnetogram
25.0			rSourceSurface
T                       IsLogRadius
180                     MaxOrder
400                     nR
180                     nLon
90                      nLat

This command determines the grid used in the B0 and B0New lookup tables
generated from the spherical harmonics.

The radial grid goes from the inner boundary at rMagnetogram (typically 1)
to the source surface radius rSourceSurface where B0 becomes radial.
The longitude goes from 0 to 360 degrees, while the latitude from -90 to 90
degrees. Both angular coordinates are uniform (no sine latitude grid).

Traditionally rSourceSurface is 2.5, but this may not be the best choice.
Setting rSourceSurface to 25.0 eliminates the non-zero curl of B0
inside the SC domain, so #CURLB0 command is not needed
and numerical artifacts are minimized. In essense, B0 should capture
the field near the active regions but it does not need to represent
the helmet streamer or the heliospheric current sheet. Those features
are best captured by the B1 field obtained from solving the MHD equations.
When rSourceSurface is much larger than rMagnetogram, it is
recommended to use a logarithmic radial grid with IsLogRadius set to true.

MaxOrder sets the maximum harmonics order used. This may get reduced to the
order present in the harmonics files read by #HARMONICSFILE and
#NEWHARMONICSFILE. If MaxOrder is less than the order present in the files,
then the higher order harmonics are ignored.

nR, nLon and nLat give number of grid cells in the radial, longitudinal and
latitudinal directions, respectively. The B0 field is stored on the grid
(nR+1)*(nLon+1)*(nLat+1) grid nodes.

Default values are shown by the first example.
</command>

<command name="HARMONICSFILE">
  <parameter name="NameHarmonicsFile" type="string" length="$lLine" />

#HARMONICSFILE
Param/CORONA/CR1935_WSO.dat           NameHarmonicsFile

NameHarmonicsFile is the name of the file containing the harmonics
coefficients.

After reading the harmonics file, the B0 lookup table is generated and saved.
By default this lookup table is saved into "harmonics_bxyz.out" file.
The defaults can be changed with the #LOOKUPTABLE command. Once the
lookup table file is created, it can be loaded directly and there is
no need for this command.

The temporal evolution of the magnetogram can be captured by using
an additional B0NEW lookup table. See also the #NEWHARMONICSFILE command.

By default there is no B0 lookup table.
</command>

<command name="NEWHARMONICSFILE">
  <parameter name="NameHarmonicsFileNew" type="string" length="$lLine"/>

#NEWHARMONICSFILE
Param/CORONA/CR1936_WSO.dat    NameHarmonicsFileNew

NameHarmonicsFileNew is the name of the file containing the harmonics
coefficients for the time at the end of the session.

After reading the harmonics file, the B0NEW lookup table is generated
and saved into the "harmonics_bxyz_new.out" file.
The default parameters of the lookup table can be changed with the
#LOOKUPTABLE command. Once the lookup table file is created,
it can be loaded directly and there is no need for this command.

The potential field contained in the B0 and B0NEW lookup tables
will be interpolated in time during the session. 

By default there is no B0NEW lookup tables.
</command>

<command name="MAGNETOGRAM">
  <parameter name="UseMagnetogram" type="logical" default="F"	/>
  <if expr="$UseMagnetogram">
    <parameter name="rMagnetogram" type="real" default="1.0" />
    <parameter name="rSourceSurface" type="real" default="2.5" />
    <parameter name="HeightInnerBc" type="real" default="0.0" />
    <parameter name="NameHarmonicsFile" type="string" length="$lLine" />
  </if>

#MAGNETOGRAM
T			UseMagnetogram (rest of parameters read if true)
1.0			rMagnetogram
2.5			rSourceSurface
0.0			HeightInnerBc (not used)
Param/CORONA/CR1935_WSO.dat    NameHarmonicsFile

This command is obsolete and has been replaced with the #HARMONICSFILE command.

If UseMagnetogram=T then read the harmonics file for the coronal
magnetic field and use it to set B0 to the potential field solution.

rMagnetogram and rSourceSurface are the photosphere and source surface
heliocentric radii, respectively. B0 becomes radial at rSourceSurface
(typically taken to be 2.5 solar radii).

HeightInnerBc is the height above the photosphere of the boundary surface,
non-zero values for this parameter are not recommended to unexperienced users.

NameHarmonicsFile is the name of the file containing the harmonics.

Default is UseMagnetogram=F.
</command>

<command name="LDEM">
  <parameter name="UseLdem" type="logical" default="F"	/>
  <if expr="$UseLdem">    
    <parameter name="NameLdemFile" type="string" length="$lLine" />
    <parameter name="iRadiusLdem" type="integer" min="0" default="12" />
  </if>

#LDEM
F			UseLdem (rest of parameters read if true)
LDEM_moments.out	NameLdemFile
1			iRadiusLdem

If UseLdem=T then read the LDEM moments file for the coronal density and temperature.

NameLdemFile is the name of the file containing the Ldem moments.

iRadiusLdem gives the index of the desired radius at which data is extracted.
The Ldem moments data is ordered into concentric spherical shells of increasing
radius,  ranging from 1.035Rs to 1.255Rs, in increaments of 0.01Rs. The user can
select the desired radius by varying the iRadiusLdem parameter. The minimal accepted
value of iRadiusLdem is 1, corresponding to 1.035Rs. iRadiusLdem=2 corresponds to
1.045Rs, and so forth.

Default is UseLdem=F, iRadiusLdem=1

</command>

<command name="EMPIRICALSW">
  <parameter name="NameModelSW" type="string" input="select">
    <option name="none" default="T"/>
    <option name="WSA"/>
  </parameter>

#EMPIRICALSW
WSA             NameModelSW

Depending on the expansion factors, calculated using the magnetogram field,
for NameModelSW=WSA the spatial distribution of varied gamma is calculated.
Through the Bernoulli integral the solar wind at 1AU should fit the WSA
solar wind semi-empirical model, with the prescribed distribution of the
varied gamma. Default value is NameModelSW=none.
</command>

<command name="WSACOEFF">
    <parameter name="ConstantSpeed"   type="real" min="0" default="240"/>
    <parameter name="ModulationSpeed" type="real" min="0" default="675"/>
    <parameter name="PowerIndex1"     type="real" min="0" default="4.5"/>
    <parameter name="Coeff1"          type="real"         default="1.0"/>
    <parameter name="coeff2"          type="real"         default="0.8"/>
    <parameter name="Angle"           type="real" min="0" default="2.8"/>
    <parameter name="PowerIndex2"     type="real" min="0" default="1.25"/>
    <parameter name="PowerIndex3"     type="real" min="0" default="3.0"/>
    <parameter name="LowerBound"      type="real" min="0" default="0.0"/>
    <parameter name="UpperBound"      type="real" min="$LowerBound"
							default="9999.0"/>
#WSACOEFF
240.0		ConstantSpeed [km/s]
675.0		ModulationSpeed [km/s]
4.5  		PowerIndex1
1.0  		Coeff1
0.8  		Coeff2
2.8  		Angle [deg]
1.25 		PowerIndex2
3.0  		PowerIndex3
0.0  		LowerBound
9999.0		UpperBound

Read in various parameters for the Wang-Sheely-Arge model. The exact meaning
of the parameters should be obtained from publications on the WSA model.
Default values are show.
</command>

<command name="POYNTINGFLUX">
	 <parameter name="PoyntingFluxPerBSi" type="real" default="1.0E6"/>

#POYNTINGFLUX
0.3E6		PoyntingFluxPerBSi [J/m^2/s/T]

The boundary condition for the Alfven wave energy density is empirically set
by prescribing the Poynting flux $S_{A}$ of the outgoing waves. The wave energy
density $w$ ($w_{+}$ for positive radial magnetic field $B_{r}$ and
$w_{-}$ for negative $B_{r}$) then follows from
$S_{A} = V_{A}w\propto B_{\odot}$, where $V_{A}$ is the Alfven speed,
$B_{\odot}$ is the field strength at the inner boundary and the
proportionality constant is estimated in Sokolov et al. (2013) as
$(S_{A}/B)_{\odot} = 1.1\times 10^6\;{\rm W}\,{\rm m}^{-2}\,{\rm T}^{-1}$.
Under the assumption of sufficiently small returning flux, this estimate of the
Poynting-flux-to-field ratio is equivalent to the following averaged
velocity perturbation
\begin{equation}
  (\delta{\bf u}_{\perp}\cdot\delta{\bf u}_{\perp})^{1/2} \approx
  15\;{\rm km}\,{\rm s}^{-1}\left( \frac{3\cdot10^{-11}\;{\rm kg}\,
      {\rm m}^{-3}}{\rho}\right)^{1/4},
\end{equation}
where the mass density $3\cdot10^{-11}\;{\rm kg}\,{\rm m}^{-3}$ (ion number
density $N_{i}=2\cdot10^{16}\;{\rm m}^{-3}$) corresponds to the
upper chromosphere. This value is compatible with the Hinode
observations of the turbulent velocities of $15\,{\rm km}\,{\rm s}^{-1}$.
Hence, the energy density of the outgoing wave is set to
$w = (S_{A}/B)_{\odot} \sqrt{\mu_{0}\rho}$.

Default value for PoyntingFluxPerBSi is 1.0E6.
</command>

<command name="CORONALHEATING">
  <parameter name="TypeCoronalHeating" type="string" case="lower"
	     input="select" >
    <option name="none"      default="T"/>
    <option name="exponential"          />
    <option name="unsignedflux"         />
    <option name="NonWKB"               />
    <option name="alfvenwavedissipation"/>
    <option name="turbulentcascade"/>
    <option name="usmanov"/>
  </parameter>
  <if expr="$TypeCoronalHeating =~ /exponential/">
    <parameter name="DecayLengthExp" type="real"       default="0.7" />
    <parameter name="HeatingAmplitudeCgs" type="real"  default="6.07E-7" />
  </if>
  <if expr="$TypeCoronalHeating =~ /unsignedflux/">
    <parameter name="DecayLength" type="real"          default="1.0"/>
    <parameter name="HeatNormalization" type="real"    default="1.0"/>
  </if>
  <if expr="$TypeCoronalHeating =~ /alfvenwavedissipation/">
    <parameter name="LperpTimesSqrtBSi" type="real"    default="7.5E4"/>
    <parameter name="Crefl" type="real"                default="0.04"/>
  </if>
  <if expr="$TypeCoronalHeating =~ /turbulentcascade/">
    <parameter name="LperpTimesSqrtBSi"  type="real"    default="1.5E5"/>
    <parameter name="rMinWaveReflection" type="real"    default="0"/>
    <parameter name="UseReynoldsDecomposition" type = "logical" default="F"/>
  </if>
  <if expr="$TypeCoronalHeating =~ /usmanov/">
    <parameter name="UseTransverseTurbulence" type="logical" default="T"/>
    <parameter name="SigmaD"                  type="real"    default="-1/3"/>
    <parameter name="KarmanTaylorAlpha"       type="real"    default="1.0"/>
    <parameter name="KarmanTaylorBeta2AlphaRatio" type="real" default="0.5"/>
  </if>
  
#CORONALHEATING
exponential	TypeCoronalHeating
0.0575		DecayLengthEXP      [Rsun] 	  (read for exp heating only)
7.285E-05	HeatingAmplitudeCgs [ergs/cm^3/s] (read for exp heating only)

#CORONALHEATING
unsignedflux	TypeCoronalHeating
0.0575		DecayLength	  [Rsun] (read for unsignedflux heating only)
1.0		HeatNormalization [none] (read for unsignedflux heating only)

#CORONALHEATING
alfvenwavedissipation	TypeCoronalHeating
7.5E4			LperpTimesSqrtBSi (read for alfvenwavedissipation only)
0.04			Crefl             (read for alfvenwavedissipation only)

#CORONALHEATING
turbulentcascade        TypeCoronalHeating
1.5e5                   LperpTimesSqrtBSi (read for turbulentcascade only)
0.0			rMinWaveReflection 
F			UseReynoldsDecomposition
1.0                     KarmanTaylorBeta  (for UseReynoldsDecomposition only)

#CORONALHEATING
usmanov                 TypeCoronalHeating
T                       UseTransverseTurbulence (read for usmanov only)
-1/3                    SigmaD (read for usmanov only)
1.0                     KarmanTaylorAlpha (read for usmanov only)
0.5                     KarmanTaylorBeta2AlphaRatio (read for usmanov only)

If UseCoronalHeating is false, no CoronalHeating is included.
If UseCoronalHeating is true, then one can select a simple exponential scale
height heating model or B weighted heating model normalized to the amount of
unsigned flux measured at the soalr surface (Abbett 2007). Each model applies a
cell based source term to the Energy equation.

For TypeCoronalHeating='exponential' coronal heating is applied using an
exponential scale height model. DecayLengthExp is the e-folding length in
units of Solar Radii and HeatingAmplitudeCgs is the heating rate at r=1.0

For TypeCoronalHeating='unsignedflux' the coronal heating term is calculated
using the unsigned flux model presented in (Abbett 2007). DecayLengthExp is
the e-folding length in units of Solar Radii to limit the range of influence
of this function. Because the total power in X-Ray emission is not well
constrained to total heating power in the corona, the term HeatNormalization
is used to uniformly multiply the heating rate by this factor (default 1.0).

For TypeCoronalHeating='NonWKB' coronal heating is applied using the wave
dissapation model of Cranmer 2010. No additional input parameters are needed.

For TypeCoronalHeating='alfvenwavedissipation' coronal heating is applied
using an anisotropic formulation of the Kolmogorov-type dissipation.

For TypeCoronalHeating='turbulentcascade', the Alfven wave energy density
equations account for the partial reflection of Alfven waves due to Alfven
speed gradients and field-aligned vorticity. The resulting counter
propagating waves are responsible for the nonlinear turbulent cascade.
The dissipation rate for the wave energy density, $w_{+}$, is controlled
by the amplitude of the oppositely propagating wave,
$|{\bf z}_{-}| =2\sqrt{w_{-}/\rho}$, and is inversely proportional to the
correlation length, $L_{\perp}$, in the transverse (with respect to the
magnetic field) direction. Similar to Hollweg (1986) we use a simple scaling
law $L_{\perp} \propto B^{-1/2}$ with the proportionality constant
$L_{\perp}\sqrt{B}$ as input parameter LperpTimesSqrtBSi.
If rMinWaveReflection > rBody is set, then the wave reflection is switched 
off in the cells, at which R_BLK(i,j,k,iBlock) &lt; rMinWaveReflection. 
If UseReynoldsDecomposition is set true, there are two options, depending on
how the code is configured. If the extra state variable, WDiff is set up,
then switching on UseReynoldsDecomposition will result in solving three
wave energy equations, for W_+, W_- and W_D, the latter being a difference
between the turbulent kinetic and magnetic energy densities, with the intermode
exchange ("reflection") coefficients are properly limited to avoid spurios
oscillations in the numerical solution. Otherwise, if WDiff state variable
is not introduced, however, UseReynoldsDecomposition is set to true, then the
only element of the Reynolds-decomposed new model is employed, namely the
limiter for the reflection coefficient, which, again, may be used to avoid
spurious oscillations.

For TypeCoronalHeating='usmanov' (to be continued: I more or less know what
does this mean, however, it is better to ask Bart to comment on this - may be
not right now -IS).

The default is TypeCoronalHeating="none"
</command>
<command name="LIMITIMBALANCE">
	 <parameter name="MaxImbalance" type="real" default="2.0"/>

#LIMITIMBALANCE
2.0		MaxImbalance

This command allows the user to adjust (usually, reduce) the reflection
of Alfven waves in the coronal hole, if the "turbulentcascade" type of
coronal heating is applied. In brief, the reflected energy flux is limited
by the 1/(MaxImbalance**2) fraction of the outgoing turbulent energy flux.
If MaxImbalance=2 (default value), this agrees with the usual assumption that
80% of the turbulent energy is transported outward, but 20% (which is one fourth
=1/(2**2) of the outward propagated turbulence) is reflected toward the Sun.

</command>

<command name="LONGSCALEHEATING">
  <parameter name="DoChHeat" type="logical" default="F"	/>
  <if expr="$DoChHeat">
    <parameter name="HeatChCgs" type="real" default="5.0E-7" />
    <parameter name="DecayLengthCh" type="real" default="0.7" />
  </if>
#LONGSCALEHEATING
T		DoChHeat (rest of parameters read only if set to true)
7.285E-05	HeatChCgs	[ergs/cm^3/s]
0.0575		DecayLengthCh	[Rsun]

If DoChHeat is false, no long scale height heating is included.
If DoChHeat is true, one supplies parameters for a simple exponential scale
height heating model like that in the CORONALHEATING command. HeatChCgs sets
the base heating rate ar r=1.0 [Rsun] and DecayLengthCh is the e-folding length
in units of Solar Radii.
The idea is to use this commmand in conjunction with any short scale height
heating model selected by the CORONALHEATING command.

The default is DoChHeat=.false.
</command>

<command name="ACTIVEREGIONHEATING">
  <parameter name="UseArComponent" type="logical" default="F"	/>
  <if expr="$UseArComponent">
    <parameter name="ArHeatFactorCgs" type="real" default="4.03E-5" />
    <parameter name="ArHeatB0" type="real"        default="30.0" />
    <parameter name="DeltaArHeatB0" type="real"   default="5.0" />
  </if>
#ACTIVEREGIONHEATING
T		UseArComponent (rest of parameters read only if set to true)
4.03E-05	ArHeatFactorCgs	[ergs/cm^3/s]
30.0		ArHeatB0	[Gauss]
5.0		DeltaArHeatB0	[Gauss]

If UseArComponent is false, no ActiveRegion heating component is used.
If UseArComponent is true, one supplies parameters for a linear B weighted
heating model used to supply strong heating to regions of high magnetic field
strength. This model multiplies ArHeatFactorCgs by the cell magnetic field
strength in gauss to determine a heating rate. ArHeatB0 is the central field
strength for the tanh transition function that selects between the exponential
heating model supplied by the CORONALHEATING command and the ArHeating term.
DeltaArHeatB0 is the width of this transition function.
This transition function has values: approx 0.1 at b0-deltab0, 0.5 at b0,
and approx 0.9 at b0+deltab0.

This heating is ONLY applied when CORONALHEATING is set to the exponential
heating model at the moment.

The default is UseArComponent=.false.
</command>
<command name="OPENCLOSEDHEAT">
  <parameter name="DoOpenClosedHeat" type="logical" default="F"	/>

#OPENCLOSEDHEAT
T               DoOpenClosedField

If DoOpenClosedHeat=.true., then the heating function or the turbulent heating
rate are modulated from closed to open magnetic field. Exponential heating
function as well as the unsigned flux model function are switched off in the
open field region. With the Cranmer heating function, the reflection
coefficient in the closed field region is set to one, intensifying the
heating.

Default is DoOpenClosedField = .false.
</command>

<command name="#NONLINAWDISSIPATION">
  <parameter name="UseNonLinearAWDissipation" type="logical" default="F"/>


#NONLINAWDISSIPATION
T			UseNonLinearAWDissipation

Intensifies the Alfven wave disssipation in the regions of weak field 

</command>

<command name="HEATPARTITIONING">
  <parameter name="TypeHeatPartitioning" type="string" case="lower"
             input="select" >
    <option name="uniform"/>
    <option name="stochasticheating"/>
  </parameter>
  <if expr="$TypeHeatPartitioning =~ /uniform/">
    <for from="1" to="$nIonFluid">
      <parameter name="QionRatio" type="real"          default="0.6" />
    </for>
  </if>
  <if expr="$TypeHeatPartitioning =~ /stochasticheating/">
    <parameter name="StochasticExponent" type="real"   default="0.21" />
    <parameter name="StochasticAmplitude" type="real"  default="0.18"
	       max="0.34" />
  </if>

#HEATPARTITIONING
uniform			TypeHeatPartitioning
0.6			QionRatio
0.0			QionParRatio (if used)

#HEATPARTITIONING
stochasticheating	TypeHeatPartitioning
0.21			StochasticExponent
0.18			StochasticAmplitude

If the #CORONALHEATING command is used in combination with more than one pressure
state variable, then the heat partitioning is automatically called. The type
of heat partitioning can be selected with the #HEATPARTITIONING command.

TypeHeatPartitioning='uniform' is the default. QionRatio is the fraction of the
coronal heating that is used for the ion heating, while QionParRatio is the
fraction of the coronal heating that is used for the parallel ion heating.
The fraction of electron heating is 1.0-QionRatio.

If TypeHeatPartitioning='stochasticheating', then the heat partitioning follows
a strategy based on the dissipation of kinetic Alfven waves. In particular we
employ the stochastic heating mechanism for the perpendicular proton temperature
(chandran, 2011). In this mechanism, the electric field fluctuations due to
perpendicular turbulent cascade can disturb the proton gyro motion enough to
give rise to perpendicular stochastic heating, assuming that the velocity
perturbation at the proton gyro-radius scale is large enough.
See van der Holst et al. (2014) for details of the StochasticExponent and
StochasticAmplitude input parameters. The maximum possible StochasticExponent
is 0.34 for randomly phased kinetic Alfven waves.

</command>

<command name="CHROMOSPHERE">
  <parameter name="UseChromosphereHeating" type="logical" default="F"/>
  <parameter name="NeChromosphereCgs" type="real" default="2e11" min="0"/>
  <parameter name="TeChromosphereSi" type="real" default="5e4" min="0"/>

#CHROMOSPHERE
F			UseChromosphereHeating
2e11                    NeChromosphereCgs
5e4			TeChromosphereSi

Set plasma parameters at top of chromosphere. If desired, the special
heating function may be applied to maintain a hydrostatic density
profile in the chromosphere at constant electron temperature
TeChromosphereSi. May be used if the chromosphere region is included
into a computational domain or to specify the boundary condition for
the analytic emission model from the transition region.
</command>

<command name="RADIATIVECOOLING">
	 <parameter name="UseRadCooling" type="logical" default="F" />
#RADIATIVECOOLING
T			UseRadCooling

Switches the radiation cooling on and off. For coronal solar plasma the
emissivity calculated in the "coronal" approximation (optically thin plasma
with no radiation-induced excitations and ionization). The radiation loss rate
is approximated using CHIANTI tables or approximate interpolation formula (see
comments in src/ModRadiativeCooling.f90). Default value for UseRadCooling is
.false.

</command>

</commandgroup>

<commandgroup name="THREADED LOW SOLAR CORONA">

<command name="FIELDLINETHREAD">
  <parameter name="UseFieldLineThreads" type="logical" default="F"/>
  <parameter name="nPointThreadMax" type="integer"     default="100"/>
  <parameter name="DsThreadMin" type="real"            default="0.002"/>

#FIELDLINETHREAD
T		UseFieldLineThreads
200		nPointThreadMax
0.002   	DsThreadMin

If the logical, UseFieldLineThreads is set to .true., then, from center of 
physical cell near the inner boundary, the magnetic field line (tread) is 
traced toward photosphere, by integrating equation dx/ds = B/ |B| with a step,
ds = DsThreadMin. 

While integrated, the line is not allowed to turn back (outward the Sun). 
Except for this, no other means is used to help the line to reach the 
photosphere. If within nPointThreadMax steps the photosphere is not reached by 
any line, it is traced again, with the integration step being 
ds = 2*DsThreadMin now, and within this second and last (for the given line) 
integration, the angle is limited between the line and radial direction, so 
that the line, is guaranteed to reach the photosphere within nPointThreadMax 
in the course of the second tracing. The line shape is arbitralily distorted
in this case, that is why the product, nPointThreadMax*DsThreadMin, which is 
the maximum length of the undistorted should be not too small: it should well
exceed the straight line distance, D, from the physical cell center to the 
photosphere:

DsThreadMin*nPointThreadMax > (2-3)D 

On the other hand, the physical length of "bad" lines, which may be as long as
2*DsThreadMin*nPointThreadMax, should not be too long, to prevent the heating
instability, which cannot be balanced by heat conduction when the boundaries are
too far. With this regard, the right hand side of the above inequality provides
both lower and, at the same time, upper estimate for the product in the
left hand side.

The set of points on the line obtained in the course of integration form 
equally spaced grid on the thread (with the mesh egual to DsThreadMin for 
the most of threads, and twice this for the other) on which to solve the 
governing equations. The minimum number of gridpoints on thread is reported 
each time when the threads are generated. If this number is too small, the 
resolution and approximation are bad. Particularly, if the above settings
are applied with the low boundary for SC grid at 1.05 Rs, then the distance 
from the physical cell center to the photosphere may be about 0.06, so that 
the grid point nmber, in principle, can be as low as 0.06/(2*0.02) = 15, which 
is evidently too small (nPointThreadMax = 150 and DsThreadMin = 0.001 are 
preferred). 

</command>

<command name="PLOTTHREADS">
  <parameter name="DoPlotThreads" type="logical" default="T"/>
  <if expr="$DoPlotThreads">
    <parameter name="nGUniform"          type="integer" default="10"/> 
    <parameter name="UseTRCorrection"    type="logical" default="T"/>
    <parameter name="UsePlanarTriangles" type="logical" default="F"/>
  </if>

#PLOTTHREADS
T			DoPlotThreads (read rest if true)
10			nGUniform
T			UseTRCorrection
F			UsePlanarTriangles  

Used for plotting images in the solar corona. The threaded gap
contributes to the line-of-site integrals determining the intensity of
the image pixel if DoPlotThreads is true. The threaded gap is split into
nGUniform intervals uniformly in the first generalized coordinate. 

If UseTRCorrection is true, the contribution frop the threaded
gap to the LOS plots is corrected to account for the contribution from
transition region.

When triangulation on sphere as described above is completed,
interpolation weights can be assigned in two ways: via the areas of
spherical triangles (UsePlanarTriangle=F) or via areas of planar
triangles (UsePlanarTriangle=T).  The latter is the
interpolation algorithm by Renka, who proved its good theoretical
properties, such as continuity of the interpolated valiable across the
boundary of the interpolation stencil.

Default values are shown above.
</command>

<command name="THREADEDBC">
  <parameter name="UseAlignedVelocity" type="logical" default="T"/>
  <parameter name="DoConvergenceCheck" type="logical" default="F"/>
  <parameter name="TypeBc" type="string" input="select">
    <option name="first" />
    <option name="second"/>
    <option name="limited"  default="T"/>
  </parameter>
  <parameter name="Tolerance" type="real" min="0" default="1e-6"/>
  <parameter name="MaxIter" type="integer" min="1" default="20"/>

#THREADEDBC
T			UseAlignedVelocity
F			DoConvergenceCheck
limited			TypeBc (first/second/limited)
1e-6			Tolerance
20			MaxIter

This command sets things for the threaded field line algorithm.
Ask Igor Sokolov if you want to learn more.
Default values are shown.

</command>

<command name="CHROMOEVAPORATION">
  <parameter name="UseChromoEvaporation" type="logical" default="T"/>

#CHROMOEVAPORATION
F	  UseChromoEvaporation

By default, this logical is .false. the entholpy increase needed to
heat the plasma flow across the transition region to the top temperature
is neglected. If logical set is true, the energy flux to/from the first
control volume is accounted for.
</command>

<command name="TRANSITIONREGION">
  <parameter name="DoExtendTransitionRegion" type="logical" default="F"/>
  <parameter name="TeTransitionRegionSi" type="real"        default="3.0E+5" />
  <parameter name="DeltaTeModSi" type="real"                default="1.0E+4"
		   if="$DoExtendTransitionRegion"/>
#TRANSITIONREGION
T                    DoExtendTransitionRegion
3.0E+5               TeTransitionRegionSi
1.0E+4               DeltaTeSi  (read if DoExtendTransitionRegion is true)

The artificial expansion of the transition region is needed to resolve the
Transition Region (TR) which is an extremely thin region in reality.
To achieve the expansion, at temperatures below TeTransitionRegionSi the heat
conduction coefficient is artificially enhanced and the radiation loss
rate is modified accordingly. The profile of temperature and density
in this case are maintained to be the same as in the actual transition
region, however, the spatial scale becomes much longer, so that the TR
may be modelled with feasible grid resolution.

If DoExtendTransitionRegion is false, the #TRANSITIONREGION command
can be used to set the temperature of the top of the transition region.
Then the special boundary condition (REB - radiation energy balance)
is used at the "coronal base", while the temperature is fixed at
Te=TeTopTransitionRegion.

Default value is DoExtendTransitionRegion = .false.
and TeTransitionRegionSi = 4e5.
</command>
<command name="THREADRESTART">
  <parameter name="DoThreadRestart" type="logical" default="F"/>
	 
#THREADRESTART
T              DoThreadRestart

If the logical DoThreadRestart is set to true, at the initial iteration the
plasma state on the threaded field lines is recovered from the saved files
otherwise it is calculated from scratch.
</command>

</commandgroup>

<commandgroup name="HELIOSPHERE SPECIFIC COMMANDS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!! HELIOSPHERE SPECIFIC COMMANDS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="THINCURRENTSHEET">
  <parameter name="DoThinCurrentSheet" type="logical" default="F"/>

#THINCURRENTSHEET
F			DoThinCurrentSheet

The thin current sheet option is based on the thin current sheet method of
the ENLIL code. Numerical reconnection of magnetic field about the
heliospheric current sheet is avoided by reversing the field direction in one
hemisphere (the hemisphere for which the radial magnetic is negative). This
method assumes that there is no guide field, which would otherwise start to
reconnection. It is only intended for inner and outer heliosphere simulations,
assuming no coronal mass ejections are present.

This method requires an equation model that contains the SignB variable.
This variable is used to track where the field is reversed and where the
current sheet is located by using a level set method for the sign.

Default value is DoThinCurrentSheet = .false.
</command>

<command name="ALIGNBANDU">
  <parameter name="UseSaMhd" type="logical" default="F"/>
  <if expr="$UseSaMhd">
    <parameter name="RsourceSaMhd" type="real" min="0" default="0"/>
    <parameter name="RminSaMhd" type="real" min="-1" default="-1"/>
  </if>
  
#ALIGNBANDU
T                       UseSaMhd  (rest read if UseSaMhd is true)
1.1                     RsourceSaMhd
3.5                     RminSaMhd

To use this command, the BperU variable of the state vector should be
declared in the ModEquation (the possible choice is -e=AwsomSA).
Given proper boundary conditions, in steady state the
streamlineas and magnetic field lines are aligned and the ratio of
magnetic flux to mass flux is constant along the magnetic flux tube,
hence the ratio of the magnetic field strength to velocity obeys a
conservation law.

Below RsourceSaMhd the UperB variable is set as $U.B/U^2$.
If RsourceSaMhd is zero, then the SaMhd variable is either
obtained from the model below, for example from SC to IH, or set to
zero identically.

Above RminSaMhd, the magnetic field is enforced to be aligned with the
velocity vector and equal to the velocity vector multipled by the
local value of the SaMhd variable. If RminSaMhd is zero, then the
magnetic field is aligned everywhere.  If it is negative or larger
than the size of the domain, then it is not aligned anywhere. The
above setting is recommended for the steady-state SC.  The recommended
setting for the coupled steady state IH is

#ALIGNBANDU
T                       UseSaMhd
0.0                     RsourceSaMhd    ! Coupled 
0.0                     RminSaMhd       ! Applied everywhere

For the time accurate run in SC one can set UseSaMhd to false,
while in IH one may want to gradually increase RminSaMhd to keep good
steady-state solution in the region not affected by the time-accurate
perturbation prropagating outward.

Default is UseSaMhd false.
</command>

<command name="HELIOUPDATEB0" if="$NameComp ne 'GM'">
  <parameter name="DtUpdateB0" type="real" min="-1" default="0.0001"/>

#HELIOUPDATEB0
-1.0			DtUpdateB0 [s]

Set the frequency of updating the B0 field for the solar corona.
A negative value means that the B0 field is not updated.
</command>

<command name="HELIODIPOLE" if="$NameComp ne 'GM'">
  <parameter name="HelioDipoleStrengthSi" type="real" />
  <parameter name="HelioDipoleTilt" type="real" min="-90" max="90"
	     default="0"/>

#HELIODIPOLE
-0.0003                 HelioDipoleStrengthSi [Tesla]
 0.0                    HelioDipoleTilt     [deg]

Variable HelioDipoleStrengthSi defines the equatorial field strength in Tesla,
while HelioDipoleTilt is the tilt relative to the ecliptic North
(negative sign means towards the planet) in degrees.

Default value is HelioDipoleStrengthSi = 0.0.
</command>

<command name="B0WAVE">
  <parameter name="UseB0Wave" type="logical" default="F"/>
  <if expr="$UseB0Wave">
    <parameter name="B0Wave0X" type="real" default="0"/>
    <parameter name="B0Wave0Y" type="real" default="0"/>
    <parameter name="B0Wave0Z" type="real" default="0"/>
    <parameter name="B0Wave1X" type="real" default="0"/>
    <parameter name="B0Wave1Y" type="real" default="0"/>
    <parameter name="B0Wave1Z" type="real" default="0"/>
    <parameter name="B0Wave1LengthX" type="real" min="-1" default="-1"/>
    <parameter name="B0Wave1LengthY" type="real" min="-1" default="-1" if="$nDim != 1"/>
    <parameter name="B0Wave1LengthZ" type="real" min="-1" default="-1" if="$nDim == 3"/>
    <parameter name="B0WavePhase" type="real" min="0" max="360" default="0"/>
  </if>

#B0WAVE
T			UseB0Wave (rest read if true)
0.0			B0Wave0X
0.5			B0Wave0Y
0.0			B0Wave0Z
0.0			B0Wave1X
0.3			B0Wave1Y
0.0			B0Wave1Z
32.0			B0WaveLengthX
-1.0			B0WaveLengthY (read if nDim>1)
-1.0			B0WaveLengthZ (read if nDim=3)
0.0			B0WavePhase

Define the B0 vector field as a cosine wave: B0 = B0Wave0 + B0Wave1*cos(k.x + Phase).
Here B0Wave0 and B0Wave1 have 3 components. The wave number vector and the coordinate
vector x have nDim components. The wave number vector is obtained from the corresponding
wavelength vector given by B0WaveLength*. A negative wavelength sets
the corresponding wavenumber to 0, positive value is converted as k=2*pi/WaveLength.
The B0WavePhase is given in degrees and converted to Phase in radians.

By default there B0 is not defined as a wave.
</command>

<command name="HELIOBUFFERGRID" if="$_IsFirstSession and $NameComp =~ /IH|OH/">
        <parameter name="nRBuff"     type="integer" min="2" default="2"/>
  	<parameter name="nLonBuff"   type="integer" min="36" default="90"/>
	<parameter name="nLatBuff"   type="integer" min="18" default="45"/>
	<parameter name="RBuffMin"   type="real" min="0" default="19"/>
	<parameter name="RBuffMax"   type="real" min="0" default="21"/>

#HELIOBUFFERGRID
2		nRBuff	
90		nLonBuff
45		nLatBuff	
19.0		RBuffMin
21.0		RBuffMax


Define the radius and the grid resolution for the uniform
spherical buffer grid which passes information
from the SC(IH) component to the IH(OH) component. The resolution should
be similar to the grid resolution of the coarser of the SC(IH) and IH(OH) grids.
The buffer grid will only be used if 'buffergrid' is chosed for TypeBcBody in the
#INNERBOUNDARY command of the target (IH or OH) component.
This command can only be used in the first session by the IH(OH) component.
Default values are shown above.
</command>

<command name="RESTARTBUFFERGRID">
  <parameter name="DoRestartBuffer" type="logical" default="F"/>
  <parameter name="TypeCoordSource" type="string" input="select"
	     if="$DoRestartBuffer">
    <option name="GEO"/>
    <option name="GSE"/>
    <option name="GSM"/>
    <option name="MAG"/>
    <option name="SMG"/>
    <option name="HGR"/>
    <option name="HGI"/>
    <option name="HGC"/>
    <option name="hgr"/>
    <option name="hgi"/>
    <option name="hgc"/>
  </parameter>

#RESTARTBUFFERGRID
T		DoRestartBuffer
HGR             TypeCoordSource

If DoRestartBuffer is true, the MHD state on the buffer grid is
restored from the restart file.  The coordinate system is defined by
TypeCoordSource. This command is usually read from the restart.H file.

Default value is DoRestartBuffer false.
</command>

</commandgroup>

<commandgroup name="WAVE SPECIFIC COMMANDS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!! WAVE SPECIFIC COMMANDS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

<command name="ADVECTWAVES">
  <parameter name="DoAdvectnWaves" type="logical" default="T"/>

#ADVECTWAVES
T                   DoAdvectWaves

If DoAdvectWaves = .true. the waves are advected in the energy dimension.
This term may be very small and it can be switched off for purposes of
testing or comaparison with other codes that do not have this term.

The default is false.
</command>

<command name="ALFVENWAVES">
  <parameter name="UseAlfvenWaves" type="logical" default="F"/>

#ALFVENWAVES
T                   UseAlfvenWaves

If UseAlfvenWaves = .true. the waves are separated into
two sets, one of them ('plus') propagate parallel to the magnetic
field, the second one ('minus') is for waves propagating anti-parallel
to the field. The propagation speed with respect to the background
plasma is $\pm V_A=\pm|B|/\sqrt{\rho}$.
</command>

<command name="WAVEPRESSURE">
  <parameter name="UseWavePressure" type="logical" default="T"/>
  <parameter name="UseWavePressureLtd" type="logical" default="F"/>

#WAVEPRESSURE
T                   UseWavePressure
F                   UseWavePressureLtd

When Alfven waves or radiation groups are uses, the wave pressure
shows up in the momentum equation. This term is used if UseWavePressure
is true. If UseWavePressureLtd is true, then the total pressure of multiple
wave groups is put into a variable Ew, which is then limited with slope limiters.

Default values are shown.
</command>

<command name="AWREPRESENTATIVE">
  <parameter name="UseAwRepresentative" type="logical" default="F"/>

#AWREPRESENTATIVE
F			UseAwRepresentative

If UseAlfvenWaveRepresentative is true, in ExplicitAdvance at the beginning
the wave energy densities are divided by sqrt(Rho)*PoyntingFluxPerB, to get
representative functions, for which the equations and boundary conditions are
easier to handle. After the stage loop, the functions are converted back
to physically meaningful wave energy densities.

Default value is false.
</command>

</commandgroup>

<commandgroup name="PARTICLES">

<command name="PARTICLELINE" if="$_IsFirstSession">
  <parameter name="UseParticles" type="logical"     default="F"/>
  <parameter name="nFieldLineMax" type="integer"    default="-1"/>
  <parameter name="nParticlePerLine" type="integer" default="-1"/>
  <parameter name="SpaceStepMin" type="real" />
  <parameter name="SpaceStepMax" type="real" />
  <parameter name="InitMode" type="string" input="select">
    <option name="preset"/>
    <option name="import"/>
  </parameter>
  <parameter name="UseBRAlignment" type="logical" default="F"/>
  <parameter name="CosBRAngleMax" type="real" min="0.01" max="0.99"
	     default="0.1" if="$UseBRAlignment"/>
  <parameter name="UseBUAlignment" type="logical" default="F"/>
  <parameter name="CosBUAngleMax" type="real" min="0.01" max="0.99"
	     default="0.85" if="$UseBUAlignment"/>

Recommended version for IH/OH (the field line and particle numbers depend
on both pratical needs and available computational resources)

#PARTICLELINE
T			UseParticles
16			nFieldLineMax
1000			nParticlePerLine
-1			SpaceStepMin
-1			SpaceStepMax
import			InitMode
T			UseBRAlignment
0.1			CosBRAngleMax
T			UseBUAlignment
0.85			CosBUAngleMax

Recommended version for SC 
  
#PARTICLELINE
T			UseParticles
16			nFieldLineMax
1000			nParticlePerLine
-1			SpaceStepMin
-1			SpaceStepMax
import			InitMode
T			UseBRAlignment
0.7			CosBRAngleMax
F			UseBUAlignment



The command defines the class of advected magnetic field lines, consisting of
"particles" which are essentially the Lagrangian grid points. Initially, the
magnetic field lines are traced starting from the origin point set, determined
by the value of InitMode parameter (their coordinated are imported from another
model or just preset in the parameter file).

Based on values of SpaceStepMin and SpaceStepMax space step may be
 - both negative => automatic (defined by grid resolution)
 - otherwise     => restricted by min and/or max, whichever is positive

Field lines may need to be corrected during tracing. If the line 'too much
deviates' from radial direcction (turns toward the Sun or tends to turn), its
direction is corrected to keep outward direction. If the tracing occurs just
after computing the steady state solution of the solar wind the corrrection
limits the angle between the line direction (= the magnetic field vector
direction) and that of the solar wind velocity in the corotating frame of
reference. The magnetic field and velocity vectors may be parallel or
antiparallel. In case the magnetic field line intersects the current sheet,
the traced line is gradually switched between parallel and antiparallel
directions, keeping the general direction along the Parker spiral.  

</command>
</commandgroup>

<commandgroup name="SCRIPT COMMANDS">
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!! SCRIPT COMMANDS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<command name="INCLUDE">
  <parameter name="NameIncludeFile" type="string" length="$lLine" />

#INCLUDE
GM/restartIN/restart.H		NameIncludeFile

Include a file. The most useful application is including the restart
header file as show by the example. Including this file helps making sure
that the original and restarted runs use consistent settings.
The #INCLUDE command can also be useful if a sequence of commands is used
many times in different parameters files. For example one can define
a typical grid for some application and reuse it. Nested include files are
allowed but not recommended, because it makes things difficult to track.
Using #INCLUDE can make the main PARAM.in file shorter. On the other hand,
distributing the input information over several files is more error prone
than using a single file. A PARAM.in file with included files
can be expanded into a single file with the
\begin{verbatim}
share/Scripts/ParamConvert.pl run/PARAM.in run/PARAM.expand
\end{verbatim}
script. Note that the include command for the restart header file
is not expanded.

The default is to use a single PARAM.in file.
</command>

</commandgroup>
<!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!! GLOBAL RULES !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->
<rule expr="$MaxBlock>0">
        Number of grid blocks should be set in the first session!
</rule>

<rule expr="$_OUTERBOUNDARY or $_BOXBOUNDARY">
  Either #OUTERBOUNDARY or #BOXBOUNDARY must be set in first session
</rule>

</commandList>
